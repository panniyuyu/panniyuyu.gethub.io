title: get限流姿势
author: YyWang
date: 2020-05-14 21:06:35
tags: Java
categories: Java
---
限流通常用作服务的降级策略，以牺牲一部分请求的方式换来系统的部分可用；在高并发的场景下保护系统不会挂掉，比如大促、秒杀这类的场景保护像交易这样的核心服务可用，通过学习限流的代码之后，掌握了通常的限流姿势，分享一下


### 计数器

类似于滑动窗口，给定一个时间段的最大请求数（窗口，比如1秒最多100个请求），再将窗口设置多个小段（一个时间的偏移量，比如100ms，一个窗口就被分成了10小段）每一小段记录当前正在处理的请求数量，每次移动一小段，滑出的一段中的请求数量被释放，新进入窗口的一段最多可以处理被释放的请求数量

#### 总结
* 简单粗暴好实现，偏移量取值越小限流越精细，每次滑动需要获取当前一段中的请求数，计算窗口中的总的请求数是否超过限定值
* 如果在中间一小段涌入大量请求到达限定值，那就需要等待这段滑出窗口后才能处理新的请求，从宏观的角度来说，可以保证窗口期内的平均处理请求的量，但是从微观来看处理请求的方式不均衡，存在风险

### 漏桶算法

一个破桶一边以一个速度漏水（处理请求）一边以一个速度往里加水（新的请求到来）；假设向桶里加水的速度很快（大量新的请求到来）一会就把桶占满了，此后再向桶里加水就会漏出去（新的请求会被丢弃）


#### 实现

```
// 生产者和消费者
// 用阻塞队列来实现桶
BlockingQueue bucket = new BlockingQueue(MAX_SIZE);
// 请求来 -> 入队
if (!bucket.offer();{
    // 大于桶的最大值入队失败，做进一步操作（拒绝、保存到mq或者db中）
}

while (true) {
    bucker.take();
    // 出队成功 异步处理请求 等待下一个周期后再次从队列中获取请求，队列为空阻塞在原地
    sleep(10);
}

```
#### 总结
	
* 通过计算每次请求的最小时间间隔，当大量的请求到来时让系统以一个恒定的速度去处理请求，保护系统不会被超过本身处理能力的请求打挂
* 不足之处是不够优雅；当某个时间点有大量的请求到来很快将桶塞满，多于的请求直接丢弃，而突然有大量请求的场景有很多（例如秒杀，大促等）这些都是正常的请求，不应该被丢弃；

### 令牌桶

以一个速度向桶里生产令牌，当桶内令牌满了时将暂停生产，处理请求需要从桶里拿到令牌才可以，如果桶里没有令牌拒绝该请求（通常的做法是返回一个限流信息，类似于非阻塞的方式）

#### 实现

```
// 一个请求周期的类
class Cycle{
    lastTime;// 上一次请求的时间戳
    curTokenCount;// 当前桶内有效token数量
}

public boolean getLicense() {
	// 是否可以执行请求
	boolean license = false;
	do {
	    // 请求到来，计算从限流开始到现在的时间间隔，通过当前时间戳-开始时间戳
		curTime = currentTime - startTime;
		// 计算从上一次请求开始到现在的时间间隔，lastTime是从限流开始到上一次请求的时间间隔
		curDuration = curTime - lastTime;
		// 计算这段时间产生的令牌数量
		incrementTokenCount = curDuration * createTokenSpeed;
		// 计算当前时间内有效的token数量 curTokenCount是当前桶里的token数量
		curTokenCount = Min(maxTokenCount, currentTokenCount + incrementTokenCount);
		// 如果有效的token数量大于0，数量减一处理请求，
		if (curToken > 0) {
		    incrementTokenCount--;
		    license = true;
		} 
		lastTime = curTime;
	} while (!CAS(curCycle, new Cycle(lastTime, curTokenCount)));// CAS操作设置当前请求周期为下一个周期，操作成功进入下一周期，返回是否可以执行请求
	// 要进入下一周期需要CAS操作lastTime和curTokenCount两个变量，分别CAS不能保证一致性，所以封装成一个对象做CAS操作
	return license;
}

```
#### 总结

* 相较与漏桶算法，令牌桶可以应对一些突发流量的变大，最大同时处理令牌桶中最大令牌数量的请求，所有设置令牌桶中最大令牌数量要非常小心，否则会把服务器压垮
* Guava中实现了漏桶算法的限流器，还具有一定的超额消费的能力，更灵活了一下，具体实现原理也差不多，可以直接用

以上是单机模式下的限流实现，只需要拦截每次请求，执行上面的逻辑根据是否满足条件决定处不处理请求，分布式环境下的限流可以使用lua+redis来实现




