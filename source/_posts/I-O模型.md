title: 阻塞非阻塞，同步异步，网络I/O模型概念
author: YyWang
date: 2019-12-20 10:59:28
tags:
---
### I/O

* 进程或线程会产生I/O，后面都以线程为例，真正操作I/O的是操作系统，也就是说线程线程向操作系统发送I/O请求，由操作系统来完成I/O执行，整个过程为应用程序的I/O调用；
* I/O调用的过程就是将进程中（用户空间）的数据输出到进程外部的的空间（系统空间），或者是将进程外部空间（系统空间）的数据输入到进程中（用户空间）；例如一个输入类型的I/O调用，线程首先向操作系统请求外部数据，操作系统将外部数据拷贝到内核缓冲区，进程中的线程再将内核缓冲区的数据拷贝到进程缓冲区，线程针对这部分数据继续后面的操作；
* 一个线程发出I/O请求后，需要等待I/O数据就绪（操作系统将I/O数据从外部拷贝到系统空间）

### 阻塞、非阻塞、同步、异步

#### 阻塞非阻塞

* 阻塞和非阻塞；等待I/O数据就绪是否可以做其他操作；一个线程请求I/O并且I/O数据未就绪，如果线程会一直等待不会做其他事情这种方式为阻塞，如果线程立即收到I/O数据未就绪的返回值，并不需要一直等待这个方式为非阻塞，通常是轮询去访问I/O数据是否就绪，虽然没有一直等也是需要不断去询问；

#### 同步异步
* 同步和异步；可以类比线程的同步和异步，同步必须拿到I/O数据才能进行后面的操作，有很强顺序性，没有I/O数据就不能完成后面的操作，而异步不需要拿到I/O数据，去做别的操作没有顺序性；或者我觉得是不是可以这么理解（I/O数据从内核空间到用户空间拷贝是用户线程还是内核线程；同步在I/O数据就绪后用户线程自己将数据拷贝到用户空间；异步不关心I/O数据是否就绪，只是发去I/O请求有内核线程将数据拷贝到用户空间再通知给用户线程）
* 我来理解一下：简单来说同步异步的区别在于是否需要很强的顺序性；就是说同步异步区别在于用户线程是否需要拿到I/O数据再进行后面的操作，同步必须要用到这部分数据，I/O数据没有就绪就一直会等待，而异步不需要用到这部分数据，仅仅发送I/O请求等待操作系统通知即可，（这里同样提了等待，和阻塞的等待差不多都是等待I/O数据是否就绪，同步异步的关注点是是否需要等待I/O数据就绪完成下面的操作，类比于线程的同步和异步；而阻塞的关注点是等待I/O数据就绪的过程是否是一直在死等还是在做其他操作，非阻塞就是没有在死等，这段时间可以做其他的操作但是通常我们都会不断去询问I/O数据是否就绪）
* 总结：上面同步异步给了两种不同的解释，我觉得不冲突都可以理解，看哪一种好理解就用哪一种吧，后续两种解释都会尝试说明一下，觉得混乱就看其中一种吧，括号里或者括号外

#### 组合概念
* 同步阻塞；线程发起I/O请求，I/O数据未就绪线程等待，这是阻塞，拿到I/O数据之后才进行进一步操作（I/O数据就绪后用户线程从系统空间拷贝数据到用户空间），这是同步；从程序的角度来看线程一直阻塞直到I/O数据就绪
* 同步非阻塞；线程发起I/O请求，I/O数据未就绪会立即收到一个返回值不用等待，这是非阻塞，拿到I/O数据之后才进行进一步操作（I/O数据就绪用户线程从系统空间拷贝数据到用户空间），这是同步；这里虽然不需要等待I/O数据就绪，但是由于是同步的，用户线程必须拿到I/O数据（数据需要用户线程来拷贝），此时由于I/O数据未就绪，用户线程无法对数据进行拷贝用户线程只能通过轮询的方式去询问I/O数据是否就绪，再进行下一步操作；从程序的角度来看线程只是卡在了等待I/O数据就绪这里，不会阻塞，此时可以去做其他的操作，只是通常是去做询问I/O数据是否就绪的操作
* 异步阻塞；其实这种情况是不存在的，异步和阻塞是矛盾的；
* 异步非阻塞；用户线程发起I/O请求后，无须关心I/O数据是否就绪，待I/O数据就绪后由操作系统将数据拷贝到用户空间，再向用户线程发送通知进行下一步操作；从程序的角度看现场不会阻塞

#### 网络I/O模型
* 阻塞I/O
	* 线程发起I/O请求会一直阻塞等待I/O条件就绪
* 非阻塞I/O
	* 线程发起I/O请求后，如果I/O条件不是就绪状态立即返回一个状态不会一直等待，可以先做其他的任务，间隔一段时间查看I/O条件是否就绪，如果就绪进行下一步操作
* 多路复用I/O
	* 非阻塞I/O线程需要一直去询问I/O事件是否就绪，如果线程很多必将造成资源的浪费；多路复用I/O将所有线程的I/O请求注册到一个新的线程中（select），由这个线程进行轮询去查看I/O条件是否就绪，有就绪状态就通知对应的线程进行处理；相当于是把非阻塞I/O中多线程查看I/O条件的事情委托给了单独的一个线程，提高了系统的吞吐量
* 信号驱动I/O
	* 这个感觉和多路复用I/O差不多，这里将多线程的I/O操作注册为一个信号，信号中有回调函数，当信号发生call回调函数通知用户线程，与本节无关先简单这么理解
* 异步I/O
	* 线程发出I/O请求后不需要做任何操作，I/O操作完全由操作系统内核完成，之后会通知线程
    
![upload successful](/images/pasted-23.png)