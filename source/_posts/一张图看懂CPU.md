title: 一张图看懂CPU
author: YyWang
tags: Linux
categories: Linux
date: 2020-03-20 15:38:43
---
废话不说，直接上图

![upload successful](/images/一张图看懂CPU.png)

CPU可以拆解为三个部分

1. 控制单元 理解为软件设计中的controller，控制数据的流向以及执行计算机指令
2. 数据单元 用做内存的缓存，存放CPU运算的中间结果
3. 运算单元 负责运算，例如加、减、移位这样

简单来说CPU的工作过程是这样的：获取进程中的的指令（程序代码编译运行后的二进制），然后执行这些指令，在此过程中控制单元执行的一些指令，从内存中加载数数据到数据单元，指挥运算单元进行运算，将结果返回数据单元，最后将结果从数据单元写会内存

往细了说

* 控制单元中有一个指令指针寄存器和一个指令寄存器，控制单元通过下一条指令在内存中的地址，找到该指令并存入指令寄存器；控制单元中还有一个指令起始寄存器和一个数据起始寄存器，这就是进程切换中上下文的概念了，进程1切换到进程2，将进程1的状态分别保存在指令起始地址寄存器（进程1执行到了哪一行代码）和数据起始地址寄存器（进程1数据读到了哪一行）；

再往细了说

* 先看数据单元，数据寄存器用来保存数据段（内存中分配给进程存放变量的区域，代码段指内存中存放运行代码的区域）的偏移量，数据段的起始地址在控制单元的寄存器中，起始地址+偏移量 就可以得出读出的数据；
* 就以x86架构的经典处理器8086来说，数据寄存器有8个16位通用寄存器 AX、BX、CX、DX、SP、BP、SI、DI ，其中前4个寄存器分别可以单独拆分为2个8位的寄存器来使用，这就可以获取短的数据或者长的数据，很灵活；
* 再看控制单元，CS和DS分别保存代码段的起始地址（指令的起始地址）和数据段的起始地址，C为code，D为data；SS是栈寄存器，存放函数的调用关系；IP寄存器存放下一条指令的地址
* 8086的寄存器都是16位的，可地址总线是20位的，所以说在内存中寻址的时候起始地址需要左移4位再加偏移量得到最终的地址

再再往细了说

* 32位处理器的数据单元将原来16位的寄存器扩展到32位，并且为了兼容保持了原始16位寄存器的结构；控制单元中的段寄存器（CS,DS,SS,ES）变化较大，其中CS,DS,SS,ES还是16位，只是不在存起始地址，真正的地址在后面16位中的段描述符缓存器里，而端寄存器中存的东西叫做选择子，来选择段描述符缓存器中的地址信息

再再再往细了说呢

* 没有了，哈哈，我就学习到这里了
