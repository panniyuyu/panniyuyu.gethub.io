<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YyWang&#39;s Blog</title>
  
  <subtitle>永远没时间的王先森</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-27T10:33:32.272Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YyWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>揭秘京东微服务框架的负载均衡算法</title>
    <link href="http://yoursite.com/2020/03/27/%E6%8F%AD%E7%A7%98%E4%BA%AC%E4%B8%9C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/27/揭秘京东微服务框架的负载均衡算法/</id>
    <published>2020-03-27T14:38:43.000Z</published>
    <updated>2020-03-27T10:33:32.272Z</updated>
    
    <content type="html"><![CDATA[<p>在京东广泛使用的微服务框架是JSF(Jingdong Service Framework)，中文名叫杰夫，今天给大家分享一下JSF的负载均衡算法。先串一下服务调用的过程，consumer在向provider发起远程调用之前会从注册中心拿到自己订阅的provider列表，然后和列表中的provider建立连接缓存起来，当发起调用的时候会从缓存的provider中选择一个进行调用，从多个provider选择一个进行调用，那么具体选择哪一个就用到了负载均衡算法，下面分别介绍一下JSF中的负载均衡算法：</p><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><ul><li>无权重或权重相等则从provider列表中随机选择一个发起调用；</li><li>有权重，假定总的权重值为x，随机生成[0-x)的偏移量，然后遍历减去provider列表的权重，当偏移量为负是选择当前的provider发起调用</li></ul><p>附伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ...初始化总权重值totalWeight和权重是否相同sameWeight,length为providerList长度</span><br><span class="line"></span><br><span class="line">if (totalWeight &gt; 0 &amp;&amp; !sameWeight) &#123;</span><br><span class="line">    offset = random.nextInt(totalWeight);// 偏移量</span><br><span class="line">    for (item : providerList) &#123;</span><br><span class="line">        offset -= item.getWeight(i);</span><br><span class="line">        if (offset &lt; 0) &#123;</span><br><span class="line">            return item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;// 没有权重或权重相同随机选择</span><br><span class="line">    return providerList.get(random.nextInt(length));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析： 有权重值或无权重值都需要先初始化总权重值及权重值是否相等的变量复杂度为O(n)；没有权重值随机选择一个发起调用复杂度为O(1)；有权重值且权重值不同通过偏移量随机选择的复杂度为O(n)；<strong>无权重时的复杂度为O(n)，有权重时总的复杂度为2O(n)</strong></p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><ul><li>无权重，方法级别的轮询，方法的调用次数和provider列表数量取余的结果为选择的provider</li><li>有权重，在无权重的基础上，将调用次数和providerList中最大权重值取余，在List中筛选权重值大于余数的provider，最后调用次数和筛选结果长度取余的结果就是最终选择的provider<ul><li>取余的操作是让结果在[0-被取余数)之间循环，第一次和最大权重取余，是让权重从小到大循环起来；第二次在筛选的结果中取余，就是在权重值大于第一次余数的结果中循环选择</li><li>eg：第一次取余的结果大，筛选出来的List就相对较小，且List都是权重较大的provider，第二次取余是在权重较大的provider中进行轮询选择；反之，第一次取余的结果小，筛选出来的List相对较大，第二次取余是在相对较大的List中进行轮询选择；这样在轮询的基础上保证权重值大的provider的节点有更多次机会被轮询到</li></ul></li></ul><p>验证一下这个算法：假设有3个Provider A、B、C，他们的权重分别为3、3、4，进行10次调用试一下，每一行的结果分别为 调用次数、%最大权重、筛选出List长度、调用次数%List长度、最后选择</p><ul><li>0    0    3    0    A</li><li>1    1    3    1    B</li><li>2    2    3    2    C</li><li>3    3    1    -        C</li><li>4    0    3    1    B</li><li>5    1    3    2    C</li><li>6    2    3    0    A</li><li>7    3    1    -    C</li><li>8    0    3    2    B</li><li>9    1    3    0    A</li></ul><p>可以看到结果10次调用，基本是轮询的状态，而且权重为4的C节点被调用4次</p><p>附伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// key = className+alias+method</span><br><span class="line">// 初始化最小和最大权重 minWeight maxWeight</span><br><span class="line">if (maxWeight &gt; 0 &amp;&amp; minWeight &lt; maxWeight) &#123;</span><br><span class="line">    currentWeight = count % maxWeight;</span><br><span class="line">    subList = getSubList(providerList);// 选择权重大于当前权重的子集</span><br><span class="line">    return subList.get(count%subList.size());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 无权重或权重相等</span><br><span class="line">    count = getAndIncrement(key);// 通过key获取调用次数并自增1</span><br><span class="line">    return providerList.get(count%length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析：初始化最小和最大权重复杂度为O(n)，无权重或权重相同直接取余选择即可复杂度O(1)；有权重时需要筛选大于当前权重的自己复杂度为O(n)，对子集轮询算账复杂度为O(1)；<strong>无权重轮询的复杂度为O(n)，有权重轮询的复杂度为2O(n)</strong></p><h3 id="最少活跃优先"><a href="#最少活跃优先" class="headerlink" title="最少活跃优先"></a>最少活跃优先</h3><p>每次选择最少活跃的provider发起调用，当最少活跃的节点多时，在最少活跃的节点中使用随机算法，有权重随机或者无权重随机选择；</p><ul><li><p>最少活跃可以理解为最少并发数，并发数少的节点表示节点处理请求的速度快，性能强</p></li><li><p>最少活跃数以最近100次连接中的失败数量为准，如果为0表示最近没有失败连接，直接返回真实的并发数；如果大于0，限制最大值为90，在[0,100)中产生随机数，当随机数比失败连接数大时返回真实的并发数，否自返回最大值；也就是说节点中最近100次连接有失败的记录，该节点则有一定几率不会被选中调用，且失败的连接数越多，不被选中的几率越大</p><ul><li>当节点快速抛异常会被认为是处理请求速度快的节点，所以最大失败值限制90，provider抛异常最低有10%选中的概率，等provider恢复并不再抛异常了恢复正常</li></ul></li></ul><p>附伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 初始化 最小活跃数leastActive、最小活跃数的数量leastCount等</span><br><span class="line"></span><br><span class="line">if (leastCount == 1) &#123;</span><br><span class="line">    // 最少活跃数的provider列表只有1个直接返回</span><br><span class="line">&#125; else  &#123;</span><br><span class="line"> // 采用随机算法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析：初始化工作复杂度O(n)，最少活跃数量为1直接返回O(1)，否则使用随机算法；<strong>最少活跃优先算法，无权重情况下2O(n)，有权重情况下3O(n)</strong></p><h3 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h3><ul><li>以方法维度定义了选择器，保存映射关系，以interfaceName+methodName为key，自定义的选择器为value；</li><li>当首次对一个方法发起调用或者providerList发生变化时，初始化选择器<ul><li>每个节点创建128个虚拟节点，以 ip+port+index 为key得到128个hash值，保存虚拟节点的映射关系（要有序）</li></ul></li><li>如果当前方法存在选择器且providerList没变，用方法的第一个参数得到hash值，从虚拟节点的映射中get，命中直接返回，不命中选择第一个大于该hash值的节点，没有则选择虚拟节点中的第一个</li></ul><p>hash算法：通过对一个key使用MD5算法得到一个摘要，这个摘要是byte[16]类型，将数组按照索引 0-3 4-7 8-11 12-15 分成4段，每一个段有4个byte，组成一个32位的hash值，一个摘要可以生成4个hash值</p><p>附伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">selector = selectorMap.get(key);</span><br><span class="line">if (selector == null || selector.hash() != hashCode)&#123;</span><br><span class="line">    // 首次调用或者providerList发生变化</span><br><span class="line">    selectorMap.put(key, new Selector());</span><br><span class="line">&#125; </span><br><span class="line">return selecotr.select();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Selector&#123;</span><br><span class="line"></span><br><span class="line">    Selector()&#123;</span><br><span class="line">        // 初始化选择器</span><br><span class="line">        for(item : providerList) &#123;</span><br><span class="line">            for (0 : 31) &#123;</span><br><span class="line">                digest = md5.digist(key);// byte[16]类型，4个hash值</span><br><span class="line">                for (0 : 3) &#123;</span><br><span class="line">                    virtualNodes.put(hash(digest,index));// hash()就是将摘要分段返回index个段作为hash值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Provider select()&#123;</span><br><span class="line">        digest = md5.digest(arg[0]);// 方法的第一个参数作为key生成摘要</span><br><span class="line">        hashCode = hash(digest,0);// 将摘要的第一个端最为hash值</span><br><span class="line">        provider = virtualNodes.get(hashCode)</span><br><span class="line">        if (provider == null) &#123;</span><br><span class="line">            // 选择大于hashCode的第一个key对应的节点，没有就选择第一个key的节点</span><br><span class="line">        &#125;</span><br><span class="line">        return provider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析：<strong>在最坏的情况下，每次选择都要初始化选择器的复杂度为128O(n)，当provider列表不变时只需进行1次初始化，后续的选择操作复杂度为O(1)</strong></p><h3 id="本地优先随机算法"><a href="#本地优先随机算法" class="headerlink" title="本地优先随机算法"></a>本地优先随机算法</h3><p>判断provider列表中是否存在本地ip，有则发起调用，没有就使用随机算法</p><p>算法复杂度分析：<strong>最坏的情况下每次都找不到本地ip则比随机算法多O(n)的复杂度，如果能找到本地ip的复杂度为O(n)</strong></p><p>总结：</p><ul><li>随机算法和轮询算法，适用于节点差异不大的情景，节点有差异需要设置权重值<ul><li>优点，简单高效</li><li>缺点，需要找到最合适的权重值</li></ul></li><li>最少活跃优先算法，适用节点之间有差异的情景<ul><li>优点，无权重值下，可以均衡节点之间的差异，不用去设置权重值</li><li>缺点，算法复杂度较高</li></ul></li><li>一致性hash 适用于节点中有缓存数据的情景，相同的请求总是选择同样的节点<ul><li>缺点，算法复杂度较高</li></ul></li><li>本地IP调用优先 适用于本地同时提供服务的情景</li></ul><p><strong>综上，理论上，本地有自己要调用的服务配置本地IP调用优先，其他情况使用随机或者轮询都可以，默认随机算法不用管就好了</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在京东广泛使用的微服务框架是JSF(Jingdong Service Framework)，中文名叫杰夫，今天给大家分享一下JSF的负载均衡算法。先串一下服务调用的过程，consumer在向provider发起远程调用之前会从注册中心拿到自己订阅的provider列表，然后
      
    
    </summary>
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>一张图看懂CPU</title>
    <link href="http://yoursite.com/2020/03/20/%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%9C%8B%E6%87%82CPU/"/>
    <id>http://yoursite.com/2020/03/20/一张图看懂CPU/</id>
    <published>2020-03-20T07:38:43.000Z</published>
    <updated>2020-03-20T08:22:02.251Z</updated>
    
    <content type="html"><![CDATA[<p>废话不说，直接上图</p><p><img src="/images/pasted-33.png" alt="upload successful"></p><p>CPU可以拆解为三个部分</p><ol><li>控制单元 理解为软件设计中的controller，控制数据的流向以及执行计算机指令</li><li>数据单元 用做内存的缓存，存放CPU运算的中间结果</li><li>运算单元 负责运算，例如加、减、移位这样</li></ol><p>简单来说CPU的工作过程是这样的：获取进程中的的指令（程序代码编译运行后的二进制），然后执行这些指令，在此过程中控制单元执行的一些指令，从内存中加载数数据到数据单元，指挥运算单元进行运算，将结果返回数据单元，最后将结果从数据单元写会内存</p><p>往细了说</p><ul><li>控制单元中有一个指令指针寄存器和一个指令寄存器，控制单元通过下一条指令在内存中的地址，找到该指令并存入指令寄存器；控制单元中还有一个指令起始寄存器和一个数据起始寄存器，这就是进程切换中上下文的概念了，进程1切换到进程2，将进程1的状态分别保存在指令起始地址寄存器（进程1执行到了哪一行代码）和数据起始地址寄存器（进程1数据读到了哪一行）；</li></ul><p>再往细了说</p><ul><li>先看数据单元，数据寄存器用来保存数据段（内存中分配给进程存放变量的区域，代码段指内存中存放运行代码的区域）的偏移量，数据段的起始地址在控制单元的寄存器中，起始地址+偏移量 就可以得出读出的数据；</li><li>就以x86架构的经典处理器8086来说，数据寄存器有8个16位通用寄存器 AX、BX、CX、DX、SP、BP、SI、DI ，其中前4个寄存器分别可以单独拆分为2个8位的寄存器来使用，这就可以获取短的数据或者长的数据，很灵活；</li><li>再看控制单元，CS和DS分别保存代码段的起始地址（指令的起始地址）和数据段的起始地址，C为code，D为data；SS是栈寄存器，存放函数的调用关系；IP寄存器存放下一条指令的地址</li><li>8086的寄存器都是16位的，可地址总线是20位的，所以说在内存中寻址的时候起始地址需要左移4位再加偏移量得到最终的地址</li></ul><p>再再往细了说</p><ul><li>32位处理器的数据单元将原来16位的寄存器扩展到32位，并且为了兼容保持了原始16位寄存器的结构；控制单元中的段寄存器（CS,DS,SS,ES）变化较大，其中CS,DS,SS,ES还是16位，只是不在存起始地址，真正的地址在后面16位中的段描述符缓存器里，而端寄存器中存的东西叫做选择子，来选择段描述符缓存器中的地址信息</li></ul><p>再再再往细了说呢</p><ul><li>没有了，哈哈，我就学习到这里了</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;废话不说，直接上图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-33.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt;CPU可以拆解为三个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;控制单元 理解为软件设计中的controller，控制数据
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>将Hexo博客迁移到docker（二）</title>
    <link href="http://yoursite.com/2020/02/14/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0docker%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/14/将Hexo博客迁移到docker（二）/</id>
    <published>2020-02-14T13:33:34.000Z</published>
    <updated>2020-03-20T08:22:02.332Z</updated>
    
    <content type="html"><![CDATA[<p>本篇将进行迁移的第二阶段，主要步骤为</p><ul><li>在git上备份博客中的文件</li><li>进入docker容器中还原</li><li>验证</li><li>修改Dockerfile</li><li>验证</li></ul><h4 id="在git上备份博客中的文件"><a href="#在git上备份博客中的文件" class="headerlink" title="在git上备份博客中的文件"></a>在git上备份博客中的文件</h4><p>hexo d 是将静态文件发布到git上，内容是 public 文件夹中的文件，hexo g 命令会重新生成静态文件；那么其他文件就是我要转移的文件了，将其他文件备份到git仓库中的新分支中 （.gitignore 里给出存放不需要备份的文件，至于为什么后面慢慢了解，本篇重点不在这） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 新建分支 hexo</span><br><span class="line">git clone $&#123;git path&#125;</span><br><span class="line">cd username.github.io</span><br><span class="line">git batch hexo</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;初次提交&apos;</span><br><span class="line">git push origin hexo</span><br><span class="line"># 删除所有文件 后提交分支</span><br><span class="line">rm -rf *</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;删除文件&apos;</span><br><span class="line">git push origin hexo</span><br><span class="line"></span><br><span class="line"># 这时候在username.github.io的文件夹下就有了.git文件，将其拷贝的博客目录中</span><br><span class="line">mv .git /usr/local/myblog</span><br><span class="line">cd /usr/local/myblog</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;备份博客文件&apos;</span><br><span class="line">git push origin hexo</span><br><span class="line"></span><br><span class="line"># 在 themes/next/ 目录下的部分文件没得了，博客里的相册功能依赖这里的文件，需要处理一下</span><br><span class="line">rm -rf /usr/local/myblog/themes/next/.gitignore</span><br><span class="line">cd /usr/local/myblog</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;next主题相关文件&apos;</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure><p>到这里已经将自己博客下面的文件都提交到git的hexo分支中了</p><h4 id="进入docker容器中还原"><a href="#进入docker容器中还原" class="headerlink" title="进入docker容器中还原"></a>进入docker容器中还原</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">git clone $&#123;git path&#125;</span><br><span class="line">cd /usr/local/$&#123;username&#125;.github.io</span><br><span class="line">git checkout hexo</span><br><span class="line"># 由于我已经有myblog的文件夹了这离要删除一下</span><br><span class="line">rm -rf /usr/local/myblog</span><br><span class="line">mv /usr/local/$&#123;username&#125;.github.io /usr/local/myblog</span><br><span class="line"># 安装package.json中的依赖</span><br><span class="line"># 修改下载源，安装更快</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">npm install hexo --save</span><br><span class="line">npm install hexo-admin --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-helper-live2d --save</span><br><span class="line">npm install hexo-renderer-ejs --save</span><br><span class="line">npm install hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-stylus --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-tag-cloud --save</span><br><span class="line">npm install hexo-wordcoun --save</span><br><span class="line"></span><br><span class="line"># 重新生成静态文件</span><br><span class="line">cd /usr/local/myblog</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>在浏览器中访问 http://${ip}:8088 效果相同即为成功</p><h4 id="修改Dockerfile"><a href="#修改Dockerfile" class="headerlink" title="修改Dockerfile"></a>修改Dockerfile</h4><p>因为要相册相关要用到python3，镜像中自带的时python2，所以要安装一下python3，在第二阶段的Dockerfile基础上增加下面操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># 安装依赖</span><br><span class="line">RUN yum update -y &amp;&amp; yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make \</span><br><span class="line"># 备份原始的python</span><br><span class="line">&amp;&amp; mv /usr/bin/python /usr/bin/python.bak \ </span><br><span class="line"># 下载解压</span><br><span class="line">&amp;&amp; cd /usr/local \</span><br><span class="line">&amp;&amp; wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz \</span><br><span class="line">&amp;&amp; tar -xvJf  Python-3.6.2.tar.xz \</span><br><span class="line"># 编译安装</span><br><span class="line">&amp;&amp; cd Python-3.6.2 \</span><br><span class="line">&amp;&amp; ./configure prefix=/usr/local/python3 \</span><br><span class="line">&amp;&amp; make &amp;&amp; make install \</span><br><span class="line">&amp;&amp; rm -rf /usr/local/Python-3.6.2.tar.xz \</span><br><span class="line"># 添加软链</span><br><span class="line">&amp;&amp; ln -s /usr/local/python3/bin/python3 /usr/bin/python3 \</span><br><span class="line">&amp;&amp; ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 \</span><br><span class="line"># 安装依赖</span><br><span class="line">&amp;&amp; pip3 install Pillow \</span><br><span class="line"></span><br><span class="line"># 迁移博客 由于clone速度极其慢，改用本地先clone好复制过去</span><br><span class="line">&amp;&amp; rm -rf /usr/local/myblog</span><br><span class="line">COPY myblog /usr/local/myblog/</span><br><span class="line"># &amp;&amp; cd /usr/local \</span><br><span class="line"># &amp;&amp; git clone git@github.com:panniyuyu/panniyuyu.github.io.git \</span><br><span class="line"># &amp;&amp; cd /usr/local/panniyuyu.github.io \</span><br><span class="line"># &amp;&amp; git checkout hexo \</span><br><span class="line"># 由于我已经有myblog的文件夹了这离要删除一下</span><br><span class="line"># &amp;&amp; rm -rf /usr/local/myblog \</span><br><span class="line"># &amp;&amp; mv /usr/local/panniyuyu.github.io /usr/local/myblog \</span><br><span class="line"></span><br><span class="line"># 安装package.json中的依赖</span><br><span class="line"># 修改下载源，安装更快</span><br><span class="line">RUN npm config set registry https://registry.npm.taobao.org \</span><br><span class="line">&amp;&amp; npm install hexo --save \</span><br><span class="line">&amp;&amp; npm install hexo-admin --save \</span><br><span class="line">&amp;&amp; npm install hexo-deployer-git --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-archive --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-baidu-sitemap --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-category --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-feed --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-index --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-search --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-searchdb --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-sitemap --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-tag --save \</span><br><span class="line">&amp;&amp; npm install hexo-helper-live2d --save \</span><br><span class="line">&amp;&amp; npm install hexo-renderer-ejs --save \</span><br><span class="line">&amp;&amp; npm install hexo-renderer-marked --save \</span><br><span class="line">&amp;&amp; npm install hexo-renderer-stylus --save \</span><br><span class="line">&amp;&amp; npm install hexo-server --save \</span><br><span class="line">&amp;&amp; npm install hexo-tag-cloud --save \</span><br><span class="line">&amp;&amp; npm install hexo-wordcoun --save \</span><br><span class="line"></span><br><span class="line"># 重新生成静态文件</span><br><span class="line">&amp;&amp; cd /usr/local/myblog \</span><br><span class="line">&amp;&amp; hexo clean \</span><br><span class="line">&amp;&amp; hexo g</span><br></pre></td></tr></table></figure><h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p>启动docker容器 绑定端口映射 8088:80 浏览器访问 http://${ip}:8088 查看效果无误，完成</p><p><strong>最后总结一下需要迁移的步骤</strong></p><ul><li>git push origin hexo推送博客所有文件</li><li>编辑Dockerfile</li><li>在Dokerfile目录下git clone 博客文件 再切换hexo分支 重命名为myblog</li><li>在Dockerfile目录下编辑nginx.conf文件</li><li>使用Dockerfile生成镜像</li><li>启动容器 绑定端口 </li><li>进入容器启动nginx</li><li>使用Dockerfile生成镜像</li><li>启动容器 绑定端口</li></ul><p>是不是迁移起来非常简单，可以将生成的镜像备份成tar包，在任意的服务器上安装docker后，还原镜像启动容器即可</p><p><em>相册相关</em></p><p>我的相册是参考<a href="https://malizhi.cn/HexoAlbum/" target="_blank" rel="noopener">这里</a>弄得；我将它移至博客文件的hexo分支，一起备份起来，要上传新的文件运行目录中的tool.py脚本，将照片裁剪后上传至github仓库，这时照片就有了URL，在博客中就可以看到了</p><p><em>发布博客相关</em></p><ul><li>docker容器中的 /usr/local/source/_posts/ 目录下的文件名为乱码，下面方法可以解决，但是我这里没有成功，通过tab补全是正常的ls和ll看就有问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install convmv</span><br><span class="line"></span><br><span class="line">convmv -f GBK -t UTF-8 --notest -r /usr/local/source/_posts/</span><br></pre></td></tr></table></figure><p>所有我觉得在宿主机建立文件映射，然后进入docker中hexo g -d更新</p><ul><li>hexo d 会失败，这里要重新生成sshkey</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;$&#123;email&#125;&quot;</span><br><span class="line"># 拷贝sshkey到github中</span><br><span class="line"># 配置</span><br><span class="line">git config --global user.name &quot;$&#123;username&#125;&quot;</span><br><span class="line">git config --global user.email &quot;$&#123;email&#125;&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇将进行迁移的第二阶段，主要步骤为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在git上备份博客中的文件&lt;/li&gt;
&lt;li&gt;进入docker容器中还原&lt;/li&gt;
&lt;li&gt;验证&lt;/li&gt;
&lt;li&gt;修改Dockerfile&lt;/li&gt;
&lt;li&gt;验证&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;在gi
      
    
    </summary>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>将Hexo博客迁移到docker（一）</title>
    <link href="http://yoursite.com/2020/02/13/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0docker%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/13/将Hexo博客迁移到docker（一）/</id>
    <published>2020-02-13T02:21:32.000Z</published>
    <updated>2020-03-20T08:22:02.331Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是迁移工作的第一阶段</p><h4 id="docker入门"><a href="#docker入门" class="headerlink" title="docker入门"></a>docker入门</h4><p>移步到<a href="http://yywang.top/2020/02/12/Docker%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">这里</a></p><h4 id="在docker容器中重新搭建Hexo博客系统并记录步骤"><a href="#在docker容器中重新搭建Hexo博客系统并记录步骤" class="headerlink" title="在docker容器中重新搭建Hexo博客系统并记录步骤"></a>在docker容器中重新搭建Hexo博客系统并记录步骤</h4><p>拉取centos镜像 -&gt; 启动容器 -&gt; 进入容器bash -&gt; 搭建博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"># 拉取镜像</span><br><span class="line">docker pull centos:7</span><br><span class="line"># 启动容器</span><br><span class="line">docker run -di --name=centos7 centos:7</span><br><span class="line"># 进入命令行</span><br><span class="line">docker exec -it centos7 /bin/bash</span><br><span class="line"></span><br><span class="line"># 搭建hexo博客</span><br><span class="line"></span><br><span class="line"># 安装node.js</span><br><span class="line"></span><br><span class="line"># 安装wget</span><br><span class="line">yum install -y wget</span><br><span class="line"># 新建目录 </span><br><span class="line">mkdir /usr/local/nodejs</span><br><span class="line"># 下载tar</span><br><span class="line">wget https://nodejs.org/dist/v12.15.0/node-v12.15.0-linux-x64.tar.xz</span><br><span class="line"># 解压</span><br><span class="line">xz -d node-v12.15.0-linux-x64.tar.xz</span><br><span class="line"># 部署bin文件</span><br><span class="line">ln -s /usr/local/nodejs/node_12.15.0/bin/node /usr/local/bin/node</span><br><span class="line">ln -s /usr/local/nodejs/node_12.15.0/bin/npm /usr/local/bin/npm</span><br><span class="line"></span><br><span class="line"># 安装hexo</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"># 安装git</span><br><span class="line">yum install git-core</span><br><span class="line"># 配置环境变量</span><br><span class="line">ln -s /usr/local/nodejs/node_12.15.0/bin/hexo /usr/local/bin/hexo</span><br><span class="line"># 创建网站文件夹</span><br><span class="line">mkdir myblog</span><br><span class="line">cd myblog</span><br><span class="line"># 初始化hexo</span><br><span class="line">hexo init</span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"># 安装NGINX</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel</span><br><span class="line"># 下载NGINX</span><br><span class="line">wget https://nginx.org/download/nginx-1.16.1.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar -zxf nginx-1.16.1.tar.gz</span><br><span class="line">cd nginx-1.16.1</span><br><span class="line"># 编译安装</span><br><span class="line">./configure </span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"># 配置NGINX</span><br><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line"># 启动NGINX</span><br><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure><p>其中nginx.conf为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># http中server模块做修改即可</span><br><span class="line">server &#123;</span><br><span class="line">       listen       80 default_server;</span><br><span class="line">       listen       [::]:80 default_server;</span><br><span class="line">       server_name  _;</span><br><span class="line">       root         /usr/local/myblog/public/;</span><br><span class="line"></span><br><span class="line">       # Load configuration files for the default server block.</span><br><span class="line">       include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">       location / &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       error_page 404 /404.html;</span><br><span class="line">           location = /40x.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       error_page 500 502 503 504 /50x.html;</span><br><span class="line">           location = /50x.html &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>完成上述步骤后开始验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 将容器保存为镜像</span><br><span class="line">docker commit centos7 mycentos:7.1</span><br><span class="line"># 启动新的容器</span><br><span class="line">docker run -di --name=centos7.1 -p 8088:80 mycentos:7.1 </span><br><span class="line"># 进入容器启动NGINX（从镜像启动容器并没有把NGINX启动）</span><br><span class="line">docker extc -it centos7.1 /bin/bash</span><br><span class="line"># 浏览器中访问 http://$&#123;ip&#125;:8088 验证</span><br></pre></td></tr></table></figure><h4 id="编写dockerfile"><a href="#编写dockerfile" class="headerlink" title="编写dockerfile"></a>编写dockerfile</h4><p>根据上述的步骤一步步编写Dockerfile；然后进行 build -&gt; 报错 -&gt; 进入容器查看错误（我太菜了不能看日志直接修改Dockerfile） -&gt; 修改Dockerfile -&gt; build -&gt; … 直到成功 最终Dockerfile如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER yywang sbsbjs@qq.com</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">RUN yum update -y &amp;&amp; yum install -y wget git-core vim* gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel \</span><br><span class="line"></span><br><span class="line"># 安装nodejs</span><br><span class="line"></span><br><span class="line"># 新建目录 </span><br><span class="line">WORKDIR /usr/local</span><br><span class="line"># 下载tar</span><br><span class="line">RUN wget https://nodejs.org/dist/v12.15.0/node-v12.15.0-linux-x64.tar.xz \</span><br><span class="line"># 解压</span><br><span class="line">&amp;&amp; tar -xvf node-v12.15.0-linux-x64.tar.xz \</span><br><span class="line">&amp;&amp; mv node-v12.15.0-linux-x64 node_12.15.0 \</span><br><span class="line">&amp;&amp; mkdir /usr/local/nodejs \</span><br><span class="line">&amp;&amp; mv node_12.15.0 /usr/local/nodejs/ \</span><br><span class="line">&amp;&amp; rm -rf node-v12.15.0-linux-x64.tar.xz \</span><br><span class="line"># 部署bin文件</span><br><span class="line">&amp;&amp; ln -s /usr/local/nodejs/node_12.15.0/bin/node /usr/local/bin/node \</span><br><span class="line">&amp;&amp; ln -s /usr/local/nodejs/node_12.15.0/bin/npm /usr/local/bin/npm \</span><br><span class="line"></span><br><span class="line"># 安装hexo</span><br><span class="line">&amp;&amp; npm install -g hexo-cli \</span><br><span class="line"></span><br><span class="line"># 配置环境变量</span><br><span class="line">&amp;&amp; ln -s /usr/local/nodejs/node_12.15.0/bin/hexo /usr/local/bin/hexo \</span><br><span class="line"># 创建网站文件夹</span><br><span class="line">&amp;&amp; mkdir /usr/local/myblog \</span><br><span class="line">&amp;&amp; cd /usr/local/myblog \</span><br><span class="line"># 初始化hexo</span><br><span class="line">&amp;&amp; hexo init \</span><br><span class="line">&amp;&amp; hexo generat \</span><br><span class="line"></span><br><span class="line"># 安装NGINX依赖</span><br><span class="line">&amp;&amp; cd /usr/local \</span><br><span class="line"># 下载NGINX</span><br><span class="line">&amp;&amp; wget https://nginx.org/download/nginx-1.16.1.tar.gz \</span><br><span class="line"># 解压</span><br><span class="line">&amp;&amp; tar -zxf nginx-1.16.1.tar.gz \</span><br><span class="line">&amp;&amp; cd /usr/local/nginx-1.16.1 \</span><br><span class="line"># 编译安装</span><br><span class="line">&amp;&amp; ./configure \</span><br><span class="line">&amp;&amp; make &amp;&amp; make install \</span><br><span class="line">&amp;&amp; rm -rf /usr/local/nginx-1.16.1 \</span><br><span class="line">&amp;&amp; rm -rf /usr/local/nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure><p>最后~ 验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 构建镜像</span><br><span class="line">docker build -t mycentos:7.2</span><br><span class="line"># 启动容器</span><br><span class="line">docker run -di --name=centos7.2 -p 8088:80 mycentos:7.2</span><br><span class="line"># 进入容器修改nginx.conf并启动NGINXß</span><br><span class="line">docker extc -it centos7.1 /bin/bash</span><br><span class="line"># 浏览器中访问 http://$&#123;ip&#125;:8088 验证</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇是迁移工作的第一阶段&lt;/p&gt;
&lt;h4 id=&quot;docker入门&quot;&gt;&lt;a href=&quot;#docker入门&quot; class=&quot;headerlink&quot; title=&quot;docker入门&quot;&gt;&lt;/a&gt;docker入门&lt;/h4&gt;&lt;p&gt;移步到&lt;a href=&quot;http://yywang.
      
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>将Hexo博客迁移到docker中（总）</title>
    <link href="http://yoursite.com/2020/02/13/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0docker%EF%BC%88%E6%80%BB%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/13/将Hexo博客迁移到docker（总）/</id>
    <published>2020-02-13T02:20:45.000Z</published>
    <updated>2020-03-20T08:22:02.332Z</updated>
    
    <content type="html"><![CDATA[<p>博客已经运行了大半年了，马上就要到期了，我得着手把搭建的博客备份一下了，续费很贵的话我得找一个便宜的用（我就是一个抠门怪哈哈），最简单的就是做系统的镜像，这也太low了吧。当下流行的是容器技术，决定把先把博客迁移到docker中，如果要换服务器的话直接备份docker就好了呀。</p><p>难点：搭建博客的时间过去很久，没有记录，完全忘了如何搭建，不知道都需要迁移哪些文件而且我还搞了很多花里胡哨的东西，这些东西也需要保留</p><p>这个就麻烦了，相当于重新搭建Hexo的博客了，没办法谁让我之前没有记录总要还的嘛</p><p>迁移步骤分为两个阶段：</p><h4 id="第一阶段-重新搭建Hexo博客系统"><a href="#第一阶段-重新搭建Hexo博客系统" class="headerlink" title="第一阶段 重新搭建Hexo博客系统"></a>第一阶段 重新搭建Hexo博客系统</h4><ul><li>入门docker</li><li>在docker容器中重新搭建Hexo博客系统并记录步骤（启动容器进行端口映射 8088:80，在公网验证）</li><li>根据记录的步骤编写Dockerfile，生成镜像（启动容器进行端口映射 8088:80 在公网验证）</li></ul><h4 id="第二阶段-迁移博客"><a href="#第二阶段-迁移博客" class="headerlink" title="第二阶段 迁移博客"></a>第二阶段 迁移博客</h4><ul><li>总结需要的文件</li><li>拷贝文件到容器中</li><li>修改Dockerfile</li><li>在公网验证</li><li>验证成功后，将宿主NGINX端口映射到docker容器中</li></ul><p>最终将容器打包成tar做备份，或者将镜像提交到仓库中直接拉取即可，非常完美</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客已经运行了大半年了，马上就要到期了，我得着手把搭建的博客备份一下了，续费很贵的话我得找一个便宜的用（我就是一个抠门怪哈哈），最简单的就是做系统的镜像，这也太low了吧。当下流行的是容器技术，决定把先把博客迁移到docker中，如果要换服务器的话直接备份docker就好了
      
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="http://yoursite.com/2020/02/12/Docker%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/02/12/Docker入门/</id>
    <published>2020-02-12T09:33:34.000Z</published>
    <updated>2020-03-20T08:22:02.222Z</updated>
    
    <content type="html"><![CDATA[<p>开门见山，docker是一种新的虚拟化技术，体积小，启动快，减小了开发和运维成本；下面就简单扫个盲入个门</p><h4 id="虚拟技术"><a href="#虚拟技术" class="headerlink" title="虚拟技术"></a>虚拟技术</h4><ul><li>传统的虚拟机技术</li></ul><p><img src="/images/pasted-30.png" alt="upload successful"></p><p>它的层次结构为： 个人pc（硬件） -&gt; 操作系统（Host OS） -&gt; 虚拟机管理系统（Hypervisor）-&gt; 虚拟机（VM）</p><p>虚拟机中的层次为：操作系统（windos/macos…） -&gt; 依赖库（C++…） -&gt; 应用（tomcat/nginx…）</p><ul><li>docker虚拟技术</li></ul><p><img src="/images/pasted-32.png" alt="upload successful"></p><p>它的层次结构为： 个人pc -&gt; 操作系统 -&gt; docker -&gt; 依赖库 -&gt; 容器</p><p>容器中的层次接口给为：依赖库（可以复用宿主机的依赖库） -&gt; 应用</p><ul><li>总结</li></ul><p>docker虚拟技术的层级更少，而且还可以复用宿主机的一些文件（依赖库等），所以docker容器的大小比虚拟机要小很多，并且启动也非常快；大致原理是利用Linux中namespace机制将进程进行隔离，从外部来看就像是运行在容器中一样，docker可以说是进程间的隔离，而虚拟机技术是基于硬件的隔离，在虚拟的硬件基础上又有着不同的操作系统，相比之下docker容器又小又快</p><p>比如部署一个nginx；在传统的虚拟机技术下，要先安装一个Linux操作系统的虚拟机，然后在虚拟机上部署nginx；而在docker技术下，无需再安装Linux操作系统，直接复用宿主机的文件和内核即可（若宿主机是Centos，容器是Ubuntu，那就使用Ubuntu的文件，复用宿主机的内核），在此基础上启动nginx进程，并与宿主机的进程隔离，这样nginx容器就部署起来了</p><p>除此以外，将自己的应用和环境打包成docker镜像，只要有docker的地方都可以运行相同的容器，不再会有因为环境不同应用运行效果不一样的问题，减小了运维成本，一句话说docker技术解决了应用打包发布的问题</p><h4 id="docker一些概念"><a href="#docker一些概念" class="headerlink" title="docker一些概念"></a>docker一些概念</h4><ul><li>镜像 用于创建容器的模板</li><li>容器 独立运行的一个或一组应用 镜像相当于类，容器相当于类的实例</li><li>仓库 用于保存镜像，有公有私有两种，类似于git仓库</li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><h5 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><h5 id="启动-停止-重启-查看状态"><a href="#启动-停止-重启-查看状态" class="headerlink" title="启动/停止/重启/查看状态"></a>启动/停止/重启/查看状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start/stop/restart/status docker</span><br></pre></td></tr></table></figure><h5 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h5 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search $&#123;image name&#125;</span><br></pre></td></tr></table></figure><h5 id="拉取镜像-不指定版本号拉去最新的"><a href="#拉取镜像-不指定版本号拉去最新的" class="headerlink" title="拉取镜像 不指定版本号拉去最新的"></a>拉取镜像 不指定版本号拉去最新的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search pull $&#123;image name&#125;:$&#123;version&#125;</span><br></pre></td></tr></table></figure><h5 id="删除镜像-f-强制删除"><a href="#删除镜像-f-强制删除" class="headerlink" title="删除镜像 -f 强制删除"></a>删除镜像 -f 强制删除</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $&#123;image name/id&#125;</span><br></pre></td></tr></table></figure><h5 id="查看正在运行的容器-a-查看所有"><a href="#查看正在运行的容器-a-查看所有" class="headerlink" title="查看正在运行的容器 -a(查看所有)"></a>查看正在运行的容器 -a(查看所有)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h5 id="容器运行相关参数"><a href="#容器运行相关参数" class="headerlink" title="容器运行相关参数"></a>容器运行相关参数</h5><ul><li>-i：表示运行容器</li><li>-t：表示容器启动进入命令行   交互式容器 exit退出命令行，容器也退出（守护式容器不会退出）</li><li>–name：为创建的容器命名</li><li>-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录）</li><li>-d: 守护模式容器</li><li>-p: 表示端口映射 前者宿主机端口 后者容器内映射端口</li><li>-e: 指定环境变量</li></ul><h5 id="启动交互式容器"><a href="#启动交互式容器" class="headerlink" title="启动交互式容器"></a>启动交互式容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=$&#123;name&#125; $&#123;image name&#125;:$&#123;version&#125; /bin/bash</span><br></pre></td></tr></table></figure><h5 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=$&#123;name&#125; $&#123;image name&#125;:$&#123;version&#125;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mysql_test -p 3316:3306 -e MYSQL_ROOT_PASSWORD=root centosz:7</span><br></pre></td></tr></table></figure><h5 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it $&#123;container name&#125; /bin/bash</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql_test /bin/bash</span><br></pre></td></tr></table></figure><h5 id="启动-停止容器"><a href="#启动-停止容器" class="headerlink" title="启动/停止容器"></a>启动/停止容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start/stop $&#123;container name/id&#125;</span><br></pre></td></tr></table></figure><h5 id="宿主机和容器文件互拷"><a href="#宿主机和容器文件互拷" class="headerlink" title="宿主机和容器文件互拷"></a>宿主机和容器文件互拷</h5><p>宿主-&gt;容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp $&#123;file&#125; $&#123;container name&#125;:$&#123;path&#125;</span><br></pre></td></tr></table></figure><p>容器-&gt;宿主 要在宿主机中使用命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp $&#123;name&#125;:$&#123;file&#125; $&#123;path&#125;</span><br></pre></td></tr></table></figure><h5 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di -v $&#123;source path&#125;:$&#123;target path&#125; --name=$&#123;container name&#125; $&#123;image name&#125;:$&#123;version&#125;</span><br></pre></td></tr></table></figure><h5 id="查看容器ip"><a href="#查看容器ip" class="headerlink" title="查看容器ip"></a>查看容器ip</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect $&#123;container name/id&#125;</span><br></pre></td></tr></table></figure><h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $&#123;container name/id&#125;</span><br></pre></td></tr></table></figure><h5 id="将容器保存为镜像"><a href="#将容器保存为镜像" class="headerlink" title="将容器保存为镜像"></a>将容器保存为镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit $&#123;container name&#125; $&#123;inage name&#125;</span><br></pre></td></tr></table></figure><h5 id="将镜像保存为tar包"><a href="#将镜像保存为tar包" class="headerlink" title="将镜像保存为tar包"></a>将镜像保存为tar包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o $&#123;tar name&#125;.tar $&#123;path&#125;</span><br></pre></td></tr></table></figure><h5 id="恢复镜像"><a href="#恢复镜像" class="headerlink" title="恢复镜像"></a>恢复镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i $&#123;tar name&#125;.tar</span><br></pre></td></tr></table></figure><h5 id="停止全部容器"><a href="#停止全部容器" class="headerlink" title="停止全部容器"></a>停止全部容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q)</span><br></pre></td></tr></table></figure><h5 id="删除全部容器"><a href="#删除全部容器" class="headerlink" title="删除全部容器"></a>删除全部容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><h5 id="停止并删除全部容器"><a href="#停止并删除全部容器" class="headerlink" title="停止并删除全部容器"></a>停止并删除全部容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><h4 id="dockerfile-创建镜像"><a href="#dockerfile-创建镜像" class="headerlink" title="dockerfile 创建镜像"></a>dockerfile 创建镜像</h4><p>简单来说记录一系列命令和参数，然后docker根据dockerfile中的命令来构建镜像</p><h5 id="From"><a href="#From" class="headerlink" title="From"></a>From</h5><p>从哪个基础镜像进行构建</p><h5 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h5><p>镜像创建者</p><h5 id="ENV-key-value"><a href="#ENV-key-value" class="headerlink" title="ENV key value"></a>ENV key value</h5><p>设置环境变量</p><h5 id="RUN-command"><a href="#RUN-command" class="headerlink" title="RUN command"></a>RUN command</h5><p>运行shell指令（多个RUN会有多层嵌套，不期望使用多个RUN，多个指令以 \ 结尾 &amp;&amp; 开头）</p><h5 id="ADD-source-file-dest-file"><a href="#ADD-source-file-dest-file" class="headerlink" title="ADD source_file dest_file"></a>ADD source_file dest_file</h5><p>将宿主文件复制到容器内，压缩文件自动解压</p><h5 id="COPY-source-file-dest-file"><a href="#COPY-source-file-dest-file" class="headerlink" title="COPY source_file dest_file"></a>COPY source_file dest_file</h5><p>将宿主文件复制到容器内，压缩文件不自动解压</p><h5 id="WORKDIR-path"><a href="#WORKDIR-path" class="headerlink" title="WORKDIR path"></a>WORKDIR path</h5><p>设置工作目录，相当于 cd</p><h5 id="构建镜像命令"><a href="#构建镜像命令" class="headerlink" title="构建镜像命令"></a>构建镜像命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t $&#123;image name&#125;:$&#123;tag&#125; .</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开门见山，docker是一种新的虚拟化技术，体积小，启动快，减小了开发和运维成本；下面就简单扫个盲入个门&lt;/p&gt;
&lt;h4 id=&quot;虚拟技术&quot;&gt;&lt;a href=&quot;#虚拟技术&quot; class=&quot;headerlink&quot; title=&quot;虚拟技术&quot;&gt;&lt;/a&gt;虚拟技术&lt;/h4&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>2019年终总结（新的开始）</title>
    <link href="http://yoursite.com/2019/12/31/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%88%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2019/12/31/2019年终总结（新的开始）/</id>
    <published>2019-12-31T12:39:27.000Z</published>
    <updated>2020-03-20T08:22:02.222Z</updated>
    
    <content type="html"><![CDATA[<p>光阴似箭岁月如梭，时光如水生命如歌，转眼间2019年到了最后的时刻，这一年对我来说是不平凡的，来盘点一下自己这一年都做了什么，主要有两件大事，一个是研究生毕业，一个是入职，上半年忙着毕业，下半年忙着上班。接下来进入回忆</p><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><ul><li>上半年基本一心扑在毕业的事情上，在等发毕业证的时间比较无聊，游戏已经打吐了，随后和马哥（实验室同门）一起租了服务器搭了博客，我选了Next，他选了另一个主题，我们俩就各自开始装修，再后来我弄好了相册功能，奈何他的主题相册的资料很少，所以这个不要脸的就复制了我的主题，博客搭好了之后也更新什么，打算工作后再说</li></ul><h4 id="EOS"><a href="#EOS" class="headerlink" title="EOS"></a>EOS</h4><ul><li>这个EOS入坑也是马哥带的，记得是18年第二季度忘了是哪个月，比特币大涨在马哥的蛊惑下研究了一番当时EOS很火，是第三代区块链技术吹得特别的牛，没忍住入坑，￥58左右入坑，后面涨到了￥158，心态开始膨胀，当时的舆论也是一片看好，能够复现比特币的辉煌，随后我记得是马老师的一句话，对就是提前退休的那个马老师，大概意思是区块链是个好东西，比特币不是，接着开始大跌到底已经￥20左右，就被套了，就当交学费了。今年也是第二季度忘了哪个月EOS回涨了，到￥53想都没想马上脱坑，及时止损</li><li>不经历一下真的很难感受到人的欲望是无限的，当时在最高点的心态现在想想都后怕，还好及时止损了没亏多少，但也买了教训，期间看到各种人梭哈，想着翻盘不顾一切的那种，最后被套就很恐怖，和赌博很像，经历过就深有体会，关爱生命远离币圈，哈哈</li></ul><h4 id="西北大环线"><a href="#西北大环线" class="headerlink" title="西北大环线"></a>西北大环线</h4><ul><li>拿着EOS脱坑的钱我换了一身行头，和同学去了西北大环线，青海湖，大柴旦，翡翠湖，最美公路，魔鬼城，莫高窟，丹霞，祁连大草原这些地方（都忘的差不多了，看微博想起来的），感受了祖国的大好河山</li><li>我的梦想就是能够和另一半读万卷书，行万里路，看遍天下的奇闻异事，这次是4个同学一起还都是男的，也算完成了一点点梦想吧</li></ul><h4 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h4><ul><li>研究生阶段让我收获最大的是鱼人沟通和思考问题的方式，从开始的愣头青变成了会思考的愣头青；简单总结一下研究生的生活吧，心态从抱怨-&gt;无望-&gt;庆幸，抱怨开始工作学习太多被压着喘不过气，无望是看不到自己毕业的希望以出路-&gt;庆幸自己能够到这个实验室遇见最好的各位，也正是和优秀的各位一起学习和努力，顺利毕业，找到满意的工作，也有了新的规划</li><li>毕业前我还玩了一个月的尤克里里，会了几个和弦，能弹两个简单的曲子不过现在忘了，还有个小插曲马哥分手了，给我打电话嚎啕大哭，7年的感情说没就没，周哥说就像满级的号被盗了一样，我瞬间感受到了马哥的痛苦，哈哈；按照实验室的传统，毕业三顿饭，吃一顿少一顿，今年由于不可抗力因素变成两顿，最后一顿也是玩的非常开心，也说了我一直想说的话，即使没有结果，起码没留遗憾，之后我便回家呆了几天就去入职了</li></ul><h4 id="入职"><a href="#入职" class="headerlink" title="入职"></a>入职</h4><ul><li>入职前，我一直关注脉脉，都是职场环境不好的言论，各种甩锅，扯皮，明争暗斗，看的我十分害怕，给自己定的基调就是多听多看少说话，保证不出错，进了这个部门非常和谐，所有人都很nice，我的问题所有都会被解答，非常庆幸能够加入这个团队</li><li>到现在入职已有半年了，有过几次培训认识了很多人，发现身边大多都是97年以后的，很多活动自己已经提不起兴趣了，而他们还激情满满，暗暗感叹自己心态老了,中秋节是个转折点我有了新的收获</li><li>技术上自己成长了很多，这段时间刷新了对很多知识的理解，遇到的所有知识点都写下来，到现在为止已经写了26篇博客，目前来看都是偏应用和概念性的，大多都是扫盲，之前没有接触过这些东西，只能先了解一个大概，到后期再细细钻研</li></ul><p>总结我的2019—-&gt;有自己的小确幸</p><p>2020年继续加油，目标（暂时这么些吧，刚毕业还是积累为主）</p><ul><li>每月平均两篇博客的更新</li><li>把19年欠下的博客补上：spring/spring boot、WAL、设计模式 netty </li><li>把部门核心业务吃透，核心产品源码看完，最好能开始学习下一代微服务学习</li><li>一次5天以上旅行</li></ul><p>奥利给<del>~</del>~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;光阴似箭岁月如梭，时光如水生命如歌，转眼间2019年到了最后的时刻，这一年对我来说是不平凡的，来盘点一下自己这一年都做了什么，主要有两件大事，一个是研究生毕业，一个是入职，上半年忙着毕业，下半年忙着上班。接下来进入回忆&lt;/p&gt;
&lt;h4 id=&quot;博客&quot;&gt;&lt;a href=&quot;#博
      
    
    </summary>
    
      <category term="生活杂谈" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="生活杂谈" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>2019的最后一天踩坑正则表达式</title>
    <link href="http://yoursite.com/2019/12/31/2019%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%E8%B8%A9%E5%9D%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/12/31/2019的最后一天踩坑正则表达式/</id>
    <published>2019-12-31T07:37:54.000Z</published>
    <updated>2020-03-20T08:22:02.222Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>2019年的最后一天，和往常一样高高兴兴写着bug，遇到一个了需求</p><p>需要判断字符串前后是否有空白，返回true和false即可</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>正则表达式呗（条件反射的方案）</p><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><ul><li>第一步，打开浏览器用Google百度一下判断字符前后空白的正则 <ul><li>/(^\s<em>)|(\s</em>$)/g （看了一眼没毛病）</li></ul></li><li>第二步，command+c出来</li><li>第三步，编写代码，把正则command+v过去</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern.matches(&quot;/(^\\s*)|(\\s*$)/g&quot;, ” test “)</span><br></pre></td></tr></table></figure><ul><li>第四步，验证，run之后，返回false，嗯，bug来了</li></ul><h4 id="挣扎"><a href="#挣扎" class="headerlink" title="挣扎"></a>挣扎</h4><p>是我拷贝的姿势不对吗？换姿势试试</p><ul><li>(^\s<em>)|(\s</em>$)</li><li>^\s<em>|\s</em>$</li><li>^\s*</li><li>\s*$</li></ul><p>结果还是false，团灭</p><p>字符串改成 ” “，返回true了，emmm…想不到了</p><p>看看源码是怎么说的，Pattern的matches方法底层调用的时Matcher的matches方法，先看注释</p><p>Attempts to match the <strong>entire</strong> region against the pattern. </p><p>entire-&gt;整个的，意思是说matches方法是会匹配整个字符串</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>知道原因了，正则不对，网上的正则是匹配字符串前后的空白字符，并不是整个一起匹配，所以得重写正则</p><ul><li>复制的正则  /(^\s<em>)|(\s</em>$)/g</li><li>修改后正则  (^\s<em>.</em>)|(.<em>\s</em>$)  试一下，所有都能匹配 是 * 的问题</li><li>修改一下    (^\s+.<em>)|(.</em>\s+$)  完美</li></ul><p>中间补了一下正则表达式 <a href="https://juejin.im/post/5dab30c26fb9a04de818face" target="_blank" rel="noopener">五分钟搞定正则表达式，如果没搞定，再加两分钟</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;2019年的最后一天，和往常一样高高兴兴写着bug，遇到一个了需求&lt;/p&gt;
&lt;p&gt;需要判断字符串前后是否有空白，返回true和false即可
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP</title>
    <link href="http://yoursite.com/2019/12/26/TCP/"/>
    <id>http://yoursite.com/2019/12/26/TCP/</id>
    <published>2019-12-26T13:05:23.000Z</published>
    <updated>2020-03-20T08:22:02.251Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h4><p><img src="/images/pasted-24.png" alt="upload successful"></p><ul><li>源端口 16bit</li><li>目的端口 16bit</li><li>序号 32bit seq 发送SYN时（SYN控制位是1）会初始化序列码（Initial Sequence Number, ISN），会用一个算法生产随机数</li><li>确认序号 32bit ack 伴随ACK（ACK控制位是1）报文一起，表示下一个要接收包的序列开始</li><li>4位首部长度 4bit </li><li>保留 6bit</li><li>标志 6bit<ul><li>URG 紧急标志</li><li>ACK 应答标志</li><li>PSH 推</li><li>RST 重置连接标志 用于重置连接</li><li>SYN 同步标志 用于建立连接</li><li>FIN 完成数据发送标志 用于释放连接</li></ul></li><li>窗口大小 16bit</li><li>校验和 16bit</li><li>紧急指针 16bit</li></ul><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/images/pasted-25.png" alt="upload successful"></p><ul><li>客户端向服务器发送请求，等待服务器响应，客户端进入SYN_SENT状态；SYN=1, seq=x</li><li>服务器收到客户端建立连接的请求（SYN=1表示建立连接），向客户端发送响应，随后服务器进入SYN_RCVD状态；SYN=1，ACK=1，ack=x+1，seq=y</li><li><p>客户端收到响应确认后（确认ack=x+1，表示服务器接收到x+1前的所有的数据，没有丢包），进入到ESTAPLISHED状态（表示客户端向服务器发送的数据x可以被接收到，单方向连通），再向服务器发送响应，服务器接收到响应确认后（确认ack=y+1，表示接收到y+1前的所有的数据，没有丢包）进入ESTABLISHED状态（表示服务器想客户端发送的数据y可以被接收到，单方向连通）；ACK=1 ack=y+1</p></li><li><p>SYN=1 表示建立连接的请求</p></li><li>ACK=1 表示确认收到请求</li><li>seq 表示初始序列，相当于发送数据的开始索引</li><li><p>ack 表示收到数据后的序列，相当于下一次发送数据的开始索引（比如 ack=x+1 表示x+1前的数据接收到了，下次发送从x+1开始）</p></li><li><p>三次握手其实就是为了建立连接，客户端&lt;——&gt;服务器两个方向，一次连接建立的过程必须是发送seq序列并收到ack=seq+1的确认</p></li><li><p>为什么不是2次握手或者是4次握手</p><ul><li>2次握手；当客户端发送了SYN=1 seq=x的连接请求，服务器返回ack=x+1的响应，如果是两次握手此时已经建立连接；这时候只能保证客户端向服务器发送的数据能被成功接收，而不能确定服务器给客户端发送的数据是否能被接收，相当于只是建立了 客户端——&gt;服务器单方向的连接</li><li>4次握手，参照2次握手发现建立单方向的连接往往需要2次握手，两个方向建立必然会4次握手，其实是第二次握手做了两件事，一是收到服务器的响应并确认，二是发送想服务器建立连接的请求；这两件事一起做相当于是3次握手</li></ul></li><li><p>TCP不会重传ACK=1的报文，只能通过重发SYN=1的请求来尝试重新建立连接，比如（A是客户端，B是服务端）</p><blockquote><p>第一个包，即A发给B的SYN没有到达B，A会超时重传，直到收到B的确认</p></blockquote><blockquote><p>第二个包，即B发送给A的SYN+ACK没有到达A，B会超时重传，直到收到A的确认</p></blockquote><blockquote><blockquote><p>这里的报文虽然是ACK但是也包含SYN，所以可以重传</p></blockquote></blockquote><blockquote><p>第三个包，即A发送给B的ACK没有到达B</p></blockquote><blockquote><blockquote><p>a.如双方果没有数据发送，B会超时重传，知道收到A的确认</p></blockquote></blockquote><blockquote><blockquote><p>b.如果A有数据发送，因为第二个包已经成功接收，A为ESTABLISHED状态，A-&gt;B的连接已经建立，A会发送Data+ACK的确认，当B接收到的时候会改变状态为ESTABLISHED</p></blockquote></blockquote><blockquote><blockquote><p>c.如果B有数据发送，由于B没有收到确认还不是ESTABLISHED状态，还不能发送数据，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据</p></blockquote></blockquote></li><li><p>TCP会不会重复建立连接呢？</p><ul><li>场景：客户端A和服务器B建立连接，第一个连接请求a没有收到，重新发送第二个请求b，请求b被接收后建立连接，过一会B又收到请求a</li><li>答案：不会，服务器B接收到请求a，认为a是无效请求，返回rst报文拒绝连接</li><li>假设如果已经建立了连接，服务器B发现请求a是失效的（因为是重发的请求源IP、端口和目标IP、端口是一样的，此时端口已经打开，连接建立）并向客户端A返回rst包，拒绝连接；</li><li>假设还连接还没建立，服务器B向客户端A返回ACK+SYN，A收到后验证发现该请求是无效的，回复rst关闭连接，B收不到回复会重发ACK+SYN到一定次数（可设置）不再重发并关闭这个未建立起来的连接</li></ul></li></ul><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/images/pasted-26.png" alt="upload successful"></p><ul><li>客户端发送向服务器发送关闭请求（FIN=1，seq=x），请求关闭客户端——&gt;服务器的连接，客户端进入FIN_WAIT_1的状态；客户端停止向服务器发送数据</li><li>服务器接收到关闭请求后，回复（ACK=1 ack=x+1 seq=y）给客户端，表示接收到关闭请求，服务器进入到CLOSE_WAIT状态，客户端收到回复后进入FIN_WAIT_2的状态</li><li>服务器发送向客户端发送关闭请求（FIN=1，ACK=1，seq=z，ack=x+1），服务器进入LAST_ACK状态；服务端停止向客户端发送数据，等待客户端响应</li><li>客户收到服务端的关闭请求，回复（ACK=1，seq=x+1，ack=z+1），客户端进入TIME_WAIT状态，等待2MSL（报文的最大生存时间）时间后，客户端进入CLOSED状态，服务器收到客户端的响应后进入CLOSED状态</li></ul><ul><li>等待2MSL的作用<ul><li>1.为了保证客户端发送的ACK能够到达服务器，服务器的连接能够正常关闭；</li><li>假设ACK丢失，等待1个MSL的时间服务器重新发送FIN关闭连接，客户端在1个MSL的时间内收到重发的FIN请求就知道刚刚的ACK没有送到，重新发送ACK确认并重新计算MSL的时间；假设第四次挥手后直接关闭，服务端没有收到ACK重发FIN，此时客户端发送rst报文关闭连接，这时是异常的关闭，太暴力了不优雅</li><li>2.可以防止已经失效的数据包在下次的连接中传输</li><li>失效的数据包由于网络延迟，还未发送到目的地，这时数据包虽然已经生效但是生命周期还没有结束（在MSL的时间内），假如第四次挥手后马上关闭连接，此时又有新的连接建立，刚好是相同的IP和端口，旧的数据包传输可以在MSL时间内传输，等待2MSL后所有失效的数据包都已不存在</li></ul></li></ul><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>用来加速数据传输，假设A发送序列seq=x的包，必须等待收到ack=x+1的回复才继续发送后面的包，滑动窗口相当于规定了一个范围，只要发送seq的范围没有超过滑动窗口就能继续发送；这样发送端不需要长时间等待前一个ack就能继续发送后面的数据包，接收端可以收到多个数据包后只发送一个ack来表示确认，加速了传输速度</p><h4 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><p>发生在三次握手的第三次过程中，服务器还没接收到客户端ack，状态是SYN_RCVD的时间段中，客户端伪造大量不存在的IP的SYN包，请求建立连接，服务器回复并等待，源ip是伪造的并不存在，服务器一直超时重发，造成网络堵塞，检测SYN攻击的方式很简单，服务器上有大量SYN_RCVD状态的链接，并且IP地址是随机的，可以用命令（#netstat -nap | grep SYN_RECV）判断 </p><h4 id="RST攻击"><a href="#RST攻击" class="headerlink" title="RST攻击"></a>RST攻击</h4><p>客户端A与服务器B已经建立连接，C伪装成A发送RST包，B接收到后强制断开连接；亦或者C伪装A发送SYN包，B接收后发现该请求无效返回RST包要A断开连接；所以客户端的端口设置是随机的，不然很容易被猜到从而受到攻击 </p><h4 id="长连接短连接"><a href="#长连接短连接" class="headerlink" title="长连接短连接"></a>长连接短连接</h4><ul><li>短连接，客户端和服务器完成一次请求和响应，相当于完成一次读写，一般由客户端发起关闭连接操作，（服务器收到消息后关闭连接不优雅）；优点是便于管理，存活的连接都是有用的连接</li><li>长连接，客户端和服务器的连接不会主动关闭，后续的请求响应继续使用这个连接，通过保活机制维护连(2小时内没有请求和响应，服务器会想客户端发送一个探测报文)</li></ul><blockquote><blockquote><p>客户端响应正常，时间刷新，2小时没有操作后继续探活</p></blockquote></blockquote><blockquote><blockquote><p>客户端不能响应探测报文（客户端异常无法发送响应或发送的响应无法到达服务器），75s后会超时，服务器共发送10个这样的探测，间隔75秒，10次结束后仍然没有收到回应，关闭连接</p></blockquote></blockquote><h4 id="半连接队列和全连接队列"><a href="#半连接队列和全连接队列" class="headerlink" title="半连接队列和全连接队列"></a>半连接队列和全连接队列</h4><ul><li>指的是服务器的状态，SYN_RCVD状态的连接会加入到半连接队列，服务器收到客户端的确认报文状态改为ESTABLISHED状态会从半连接队列中删除，加入到全连接队列</li><li>半连接队列满<ul><li>不开启net.ipv4.tcp_syncookies，直接丢弃新来的SYN请求</li><li>开启net.ipv4.tcp_cookies，假设全连接队列满，并且qlen_young的值（半连接队列中还没有进行SYN+ACK的连接数量）大于1，丢弃这个SYN请求；假设全连接队列没满，生产syncookie并返回SYN+ACK包    </li><li>syncookies用来防止syn floods攻击（攻击方不停发送SYN请求，不去回应ACK，使得半连接队列满，其他连接无法建立），通过将接收到的源ip源端口序列号进行hash，称为hash值，将hash值作为seq发送SYN+ACK，收到ACK响应验证cookie是否正确（ack-1），正确才能建立连接；但是对于没有受到攻击的服务器来说syncookies会造成负担</li></ul></li><li>假设全连接队列满，会根据tcp_abort_on_overflow的值，执行相应的策略（值为0，服务器丢弃该连接，连接信息仍然保留在半连接队列中，服务器会重发SYN+ACK，直到队列不满，建立连接；值为1，服务器发送rst报文关闭连接）</li></ul><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>控制网络流量，寻找一个合适的数据传输速度，防止造成网络堵塞或者传输速度过慢效率低的问题；拥塞窗口（cwnd）也就是发送数据的最大值，防止拥塞窗口过大，需要设置一个阈值（ssthresh）来控制窗口的大小，在阈值上下使用不同的算法</p><ul><li>慢开始（cwnd &lt; ssthresh）；开始不会就发送大量的数据，由小到大慢慢增加拥塞窗口的大小，探测网络的拥塞程度，每收到一个ACK拥塞窗口（cwnd）增加一倍，从1开始（2的指数增加）</li></ul><p><img src="/images/pasted-27.png" alt="upload successful"></p><ul><li>拥塞避免（cwnd &gt; ssthresh）；让窗口慢慢增大，经过一个往返时间RTT（收到一个ACK），窗口大小加1</li><li>在慢启动和拥塞避免的阶段中当出现网络拥塞（有报文超时），窗口会重置为1，ssthresh的阈值会重置为发生拥塞时窗口的一半，再重新开始传输数据</li><li>快重传；发送方按顺序传递报文，当出现丢失数据，接收方会发送重复的确认告知发送方报文丢失，发送方收到三个重复的确认立即重发报文，不必等待报文超时再重传</li></ul><p><img src="/images/pasted-28.png" alt="upload successful"></p><ul><li>快恢复；发送方收到3个重发确认，将ssthresh减半，不执行慢开始（因为收到重复确认所以此时网络并没有拥塞，执行拥塞避免窗口加1，缓慢增大即可）</li></ul><p><img src="/images/pasted-29.png" alt="upload successful"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">TCP为什么是三次握手，而不是两次或四次</a></p><p><a href="https://www.zhihu.com/question/276693714/answer/415714916" target="_blank" rel="noopener">TCP建立连接时三次握手的一个疑问点</a></p><p><a href="https://blog.csdn.net/a_tu_/article/details/80389878" target="_blank" rel="noopener">TCP中的RST标志(Reset)详解</a></p><p><a href="https://www.cnblogs.com/buxiangxin/p/8336022.html" target="_blank" rel="noopener">TCP协议详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/37379780" target="_blank" rel="noopener">TCP流量控制、拥塞控制</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;TCP报文&quot;&gt;&lt;a href=&quot;#TCP报文&quot; class=&quot;headerlink&quot; title=&quot;TCP报文&quot;&gt;&lt;/a&gt;TCP报文&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/pasted-24.png&quot; alt=&quot;upload successful&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阻塞非阻塞，同步异步，网络I/O模型概念</title>
    <link href="http://yoursite.com/2019/12/20/I-O%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/12/20/I-O模型/</id>
    <published>2019-12-20T02:59:28.000Z</published>
    <updated>2020-04-10T09:52:42.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><ul><li>进程或线程会产生I/O，后面都以线程为例，真正操作I/O的是操作系统，也就是说线程线程向操作系统发送I/O请求，由操作系统来完成I/O执行，整个过程为应用程序的I/O调用；</li><li>I/O调用的过程就是将进程中（用户空间）的数据输出到进程外部的的空间（系统空间），或者是将进程外部空间（系统空间）的数据输入到进程中（用户空间）；例如一个输入类型的I/O调用，线程首先向操作系统请求外部数据，操作系统将外部数据拷贝到内核缓冲区，进程中的线程再将内核缓冲区的数据拷贝到进程缓冲区，线程针对这部分数据继续后面的操作；</li><li>一个线程发出I/O请求后，需要等待I/O数据就绪（操作系统将I/O数据从外部拷贝到系统空间）</li></ul><h3 id="阻塞、非阻塞、同步、异步"><a href="#阻塞、非阻塞、同步、异步" class="headerlink" title="阻塞、非阻塞、同步、异步"></a>阻塞、非阻塞、同步、异步</h3><h4 id="阻塞非阻塞"><a href="#阻塞非阻塞" class="headerlink" title="阻塞非阻塞"></a>阻塞非阻塞</h4><ul><li>阻塞和非阻塞；等待I/O数据就绪是否可以做其他操作；一个线程请求I/O并且I/O数据未就绪，如果线程会一直等待不会做其他事情这种方式为阻塞，如果线程立即收到I/O数据未就绪的返回值，并不需要一直等待这个方式为非阻塞，通常是轮询去访问I/O数据是否就绪，虽然没有一直等也是需要不断去询问；</li></ul><h4 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h4><ul><li>同步和异步；可以类比线程的同步和异步，同步必须拿到I/O数据才能进行后面的操作，有很强顺序性，没有I/O数据就不能完成后面的操作，而异步不需要拿到I/O数据，去做别的操作没有顺序性；或者我觉得是不是可以这么理解</li><li>我来理解一下：简单来说同步异步的区别在于是否需要很强的顺序性；就是说同步异步区别在于用户线程是否需要拿到I/O数据再进行后面的操作，同步必须要用到这部分数据，I/O数据没有就绪就一直会等待，而异步不需要用到这部分数据，仅仅发送I/O请求等待操作系统通知即可，（这里同样提了等待，和阻塞的等待差不多都是等待I/O数据是否就绪，同步异步的关注点是是否需要等待I/O数据就绪完成下面的操作，类比于线程的同步和异步；而阻塞的关注点是等待I/O数据就绪的过程是否是一直在死等还是在做其他操作，非阻塞就是没有在死等，这段时间可以做其他的操作但是通常我们都会不断去询问I/O数据是否就绪）</li></ul><h4 id="组合概念"><a href="#组合概念" class="headerlink" title="组合概念"></a>组合概念</h4><ul><li>同步阻塞；线程发起I/O请求，I/O数据未就绪线程等待，这是阻塞，拿到I/O数据之后才进行进一步操作，这是同步；从程序的角度来看线程一直阻塞直到I/O数据就绪</li><li>同步非阻塞；线程发起I/O请求，I/O数据未就绪会立即收到一个返回值不用等待，这是非阻塞，拿到I/O数据之后才进行进一步操作，这是同步；这里虽然不需要等待I/O数据就绪，但是由于是同步的，用户线程必须拿到I/O数据，此时由于I/O数据未就绪，用户线程无法对数据进行拷贝用户线程只能通过轮询的方式去询问I/O数据是否就绪，再进行下一步操作；从程序的角度来看线程只是卡在了等待I/O数据就绪这里，不会阻塞，此时可以去做其他的操作，只是通常是去做询问I/O数据是否就绪的操作</li><li>异步阻塞；其实这种情况是不存在的，异步和阻塞是矛盾的；</li><li>异步非阻塞；用户线程发起I/O请求后，无须关心I/O数据是否就绪，待I/O数据就绪后由操作系统将数据拷贝到用户空间，再向用户线程发送通知进行下一步操作；从程序的角度看现场不会阻塞</li></ul><h4 id="网络I-O模型"><a href="#网络I-O模型" class="headerlink" title="网络I/O模型"></a>网络I/O模型</h4><ul><li>阻塞I/O<ul><li>线程发起I/O请求会一直阻塞等待I/O条件就绪</li></ul></li><li>非阻塞I/O<ul><li>线程发起I/O请求后，如果I/O条件不是就绪状态立即返回一个状态不会一直等待，可以先做其他的任务，间隔一段时间查看I/O条件是否就绪，如果就绪进行下一步操作</li></ul></li><li>多路复用I/O<ul><li>非阻塞I/O线程需要一直去询问I/O事件是否就绪，如果线程很多必将造成资源的浪费；多路复用I/O将所有线程的I/O请求注册到一个新的线程中（select），由这个线程进行轮询去查看I/O条件是否就绪，有就绪状态就通知对应的线程进行处理；相当于是把非阻塞I/O中多线程查看I/O条件的事情委托给了单独的一个线程，提高了系统的吞吐量</li></ul></li><li>信号驱动I/O<ul><li>这个感觉和多路复用I/O差不多，这里将多线程的I/O操作注册为一个信号，信号中有回调函数，当信号发生call回调函数通知用户线程，与本节无关先简单这么理解</li></ul></li><li>异步I/O<ul><li>线程发出I/O请求后不需要做任何操作，I/O操作完全由操作系统内核完成，之后会通知线程</li></ul></li></ul><p><img src="/images/pasted-23.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;I-O&quot;&gt;&lt;a href=&quot;#I-O&quot; class=&quot;headerlink&quot; title=&quot;I/O&quot;&gt;&lt;/a&gt;I/O&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;进程或线程会产生I/O，后面都以线程为例，真正操作I/O的是操作系统，也就是说线程线程向操作系统发送I/O请求，由操作系
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>回调与监听器模式</title>
    <link href="http://yoursite.com/2019/11/22/%E5%9B%9E%E8%B0%83%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/11/22/回调与监听器模式/</id>
    <published>2019-11-22T10:15:48.000Z</published>
    <updated>2020-03-20T08:22:02.331Z</updated>
    
    <content type="html"><![CDATA[<p>监听器模式是基于Java回调机制的，首先了解一下回调</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>类似于多线程中new Thread(){run()} 这样，其实run方法就是回调方法，jdk并不关注你怎么去实现run方法，将其以接口的方式暴露出来，让你去填空；就好像你的同事和你配合写代码，挖了一个坑让你填，哈哈，这么比喻有些不妥，其实是为了解耦，不想让你的代码侵入进去，直接看类图</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="/images/pasted-21.png" alt="upload successful"></p><p>回调就包含两个部分，分别是调用者和回调接口，实现也很简单，调用者中维护回调接口的对象并增加set方法，调用者中直接使用接口中的方法，具体实现在调用set方法时填写即可，我可能没有说清楚，直接上代码</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>回调接口 Callback</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Callback &#123;</span><br><span class="line">    void doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者 Caller</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Caller &#123;</span><br><span class="line">// 维护一个回调接口</span><br><span class="line">    private Callback callback;</span><br><span class="line"></span><br><span class="line">    public void setCallback(Callback callback) &#123;</span><br><span class="line">        this.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;do something before&quot;);</span><br><span class="line">        callback.doSomething();// 使用回调接口中的方法，不需要在这里关系实现</span><br><span class="line">        System.out.println(&quot;do something behind&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Caller caller = new Caller();</span><br><span class="line">    // 具体实现在set方法中填写</span><br><span class="line">    caller.setCallback(new Callback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void doSomething() &#123;</span><br><span class="line">            System.out.println(&quot;do something in callback&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    caller.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听器模式"><a href="#监听器模式" class="headerlink" title="监听器模式"></a>监听器模式</h3><p>监听器模式是监听感兴趣的事件，事件发生做出相应的操作；是回调的一种拓展，是在包括监听器接口，事件源和事件对象三个部分，先看类图</p><h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><p><img src="/images/pasted-22.png" alt="upload successful"></p><p>相较于回调，监听器接口相当于回调方法接口，事件源相当于调用者，监听器模式是在此基础上多了事件对象，并传给接口的方法中，我的理解是事件对象是对事件的一个封装，感兴趣的事件可能有多个，可以针对不同事件（不同的event对象）做不同的操作，这些操作也被封装在不同event对象中</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>监听器接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface EventListener &#123;</span><br><span class="line">    void doSomething(Event event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class EventSource &#123;</span><br><span class="line">    // 维护监听器对象</span><br><span class="line">    private EventListener listener;</span><br><span class="line"></span><br><span class="line">    public void setListener(EventListener listener) &#123;</span><br><span class="line">        this.listener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eventHappend(Event event) &#123;</span><br><span class="line">        System.out.println(&quot;do something before&quot;);</span><br><span class="line">        listener.doSomething(event);// 不关心方法具体实现，并传入event对象参数</span><br><span class="line">        System.out.println(&quot;do something behind&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Event &#123;</span><br><span class="line">    // 事件类型</span><br><span class="line">    private String eventInfo;</span><br><span class="line"></span><br><span class="line">    public Event(String eventInfo)&#123;</span><br><span class="line">        this.eventInfo = eventInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getEventInfo() &#123;</span><br><span class="line">        return eventInfo;</span><br><span class="line">    &#125;</span><br><span class="line">// 对于事件的操作</span><br><span class="line">    void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;do something in event object&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    EventSource eventSource = new EventSource();</span><br><span class="line">    eventSource.setListener(new EventListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void doSomething(Event event) &#123;</span><br><span class="line">            event.doSomething();// 不管事件是什么直接执行方法</span><br><span class="line">            // 有感兴趣的事件做对应的操作</span><br><span class="line">            if (&quot;event interested&quot;.equals(event.getEventInfo())) &#123;</span><br><span class="line">                System.out.println(&quot;interesting event happened&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    eventSource.eventHappend(new Event(&quot;event interested&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉事件对象还没有理解到位，针对不同的事件做不同的操作，可以设置不同的监听器，在不同的监听器中做对应的操作，相当于回调不用封装时间对象；也可以封装不同的监听事件作为参数传入，唯一的监听器中，针对不同的事件对象再做不同的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;监听器模式是基于Java回调机制的，首先了解一下回调&lt;/p&gt;
&lt;h3 id=&quot;回调&quot;&gt;&lt;a href=&quot;#回调&quot; class=&quot;headerlink&quot; title=&quot;回调&quot;&gt;&lt;/a&gt;回调&lt;/h3&gt;&lt;p&gt;类似于多线程中new Thread(){run()} 这样，其实run方
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SQL Explain记录</title>
    <link href="http://yoursite.com/2019/11/16/SQL-Explain%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/11/16/SQL-Explain记录/</id>
    <published>2019-11-16T06:43:30.000Z</published>
    <updated>2020-03-20T08:22:02.250Z</updated>
    
    <content type="html"><![CDATA[<p>要优化SQL必须得使用Explain，这里记录一下Explain的使用，直接查看即可，摘自<a href="https://www.cnblogs.com/tufujie/p/9413852.html" target="_blank" rel="noopener">MySQL Explain详解</a></p><p>explain 直接加载SQL语句之前，然后一起执行即可，只能分析查询语句，会出现以下结果<br><img src="/images/pasted-20.png" alt="upload successful"></p><h3 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h3><p>select的查询顺序标识，SQL顺序由大到小执行，id相同从上往下顺序执行</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select的类型</p><ul><li><p>SIMPLE(简单SELECT，不使用UNION或子查询等)</p></li><li><p>PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p></li><li><p>UNION(UNION中的第二个或后面的SELECT语句)</p></li><li><p>DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p></li><li><p>UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p></li><li><p>SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p></li><li><p>DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p></li><li><p>DERIVED(派生表的SELECT, FROM子句的子查询)</p></li><li><p>UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p></li></ul><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。</p><p>常用的类型有： ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）</p><ul><li><p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p></li><li><p>index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p></li><li><p>range:只检索给定范围的行，使用一个索引来选择行</p></li><li><p>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p></li><li><p>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p></li><li><p>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</p></li><li><p>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p></li></ul><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）</p><p>该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中</p><p>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</p><p>不损失精确性的情况下，长度越短越好 </p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>该列包含MySQL解决查询的详细信息,有以下几种情况：</p><ul><li><p>Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p></li><li><p>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p></li><li><p>Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</p></li><li><p>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p></li><li><p>Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p></li><li><p>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p></li><li><p>No tables used：Query语句中使用from dual 或不含任何from子句</p></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>EXPLAIN不考虑各种Cache</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>部分统计信息是估算的，并非精确值</li><li>EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</li></ul><h3 id="重点关注："><a href="#重点关注：" class="headerlink" title="重点关注："></a>重点关注：</h3><p><strong>type至少达到range级别</strong></p><p><strong>key列有值，并且key_len越少越好，做到有索引的查询</strong></p><p><strong>rows列越少越好</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要优化SQL必须得使用Explain，这里记录一下Explain的使用，直接查看即可，摘自&lt;a href=&quot;https://www.cnblogs.com/tufujie/p/9413852.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQ
      
    
    </summary>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL级联查询一些总结</title>
    <link href="http://yoursite.com/2019/11/16/SQL/"/>
    <id>http://yoursite.com/2019/11/16/SQL/</id>
    <published>2019-11-16T06:34:28.000Z</published>
    <updated>2020-03-20T08:22:02.250Z</updated>
    
    <content type="html"><![CDATA[<p>子查询导致索引失效</p><p>连接查询（连接条件为索引）的效率更高</p><h5 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h5><p>微服务相关管理端的系统，用户会在自己对应服务的地方查询所需的server，新增需求为要查看自己的服务所在的app</p><h5 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h5><p>server在单独的一张表，可以根据服务名称（interface_name）来查询；AppName在另外的一张表中；两张表没有联系需要通过一个中间表来连接；interface_name有索引，三个表之间的链接字段都有索引</p><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>需要联合3张表来查询所需要的数据，每张表的数据量都比较大，而且这个SQL是系统使用最频繁的部分查询的频率还特别高，所以要尽可能快的出结果</p><h5 id="我的心路历程："><a href="#我的心路历程：" class="headerlink" title="我的心路历程："></a>我的心路历程：</h5><p>先通过interface_name条件筛选出一部分数据再链接另外两张表查询，都有索引一定是最优的，SQL如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">app_name </span><br><span class="line">FROM</span><br><span class="line">saf_app </span><br><span class="line">WHERE</span><br><span class="line">app_id IN </span><br><span class="line">( </span><br><span class="line">SELECT DISTINCT app_id FROM saf_ins_hb WHERE ins_key IN </span><br><span class="line">(SELECT ins_key FROM saf_server WHERE interface_name = &apos;xxx&apos;) </span><br><span class="line">)</span><br><span class="line"> ORDER BY app._name</span><br></pre></td></tr></table></figure><p>查询时间竟然需要6s多，这绝对是不能忍的，接着我又试了一下级联查询，SQL如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT app.app_name </span><br><span class="line">FROM saf_server s </span><br><span class="line">LEFT JOIN saf_ins_hb hb ON s.ins_key = hb.ins_key</span><br><span class="line">LEFT JOIN saf_app app ON hb.app_id = app.app_id</span><br><span class="line">WHERE s.interface_name = &apos;xxx&apos; </span><br><span class="line">ORDER BY app.app_name</span><br></pre></td></tr></table></figure><p>这次的结果只需0.05s,相差100倍还多</p><p>explain看下呢</p><p>IN子查询如下</p><p><img src="/images/pasted-19.png" alt="upload successful"></p><p>可以看到id为2和3的查询都用到了索引并且只需扫描的很少的行数，到了最外层的查询就变成了全表扫描了，索引就失效了</p><p>级联查询如下</p><p><img src="/images/pasted-18.png" alt="upload successful"></p><p>级联查询全部使用到了索引，而且扫描的行数比子查询的要少很多，扫描的最终行数是乘积的关系，级联查询有两个子查询的rows为1所以要比IN子查询要小很多</p><p>所以说IN子查询会导致部分索引失效，我有了新的想法，既然连接查询会很快那么我先通过条件筛选出数据再做级联查询不是更快了，开整~ SQL如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT app.app_name </span><br><span class="line">    FROM (SELECT ins_key FROM saf_server WHERE interface_name = &apos;xxx&apos;) s </span><br><span class="line">LEFT JOIN saf_ins_hb hb ON s.ins_key = hb.ins_key</span><br><span class="line">LEFT JOIN saf_app app ON hb.app_id = app.app_id</span><br><span class="line">    ORDER BY app.app_name</span><br></pre></td></tr></table></figure><p>查询0.02s左右，我非常满意，explain一下呢</p><p><img src="/images/pasted-17.png" alt="upload successful"></p><p>相较于级联查询还多了7000多次的遍历？？？子查询害人啊，查询结果0.02s左右应该是有缓存</p><p>看了一篇文章说在on后面加限制条件会比where中加限制条件用时要少，on后面加条件在两张表做连接的同时过滤掉一些数据后再和第三张表做连接，where是将连接了所有表之后的结果进行筛选，听着很有道理，那我试一下呢，SQL如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT app.app_name </span><br><span class="line">    FROM saf_server s </span><br><span class="line">LEFT JOIN saf_ins_hb hb ON s.ins_key = hb.ins_key and s.interface_name = &apos;xxx&apos;</span><br><span class="line">LEFT JOIN saf_app app ON hb.app_id = app.app_id</span><br><span class="line">    ORDER BY app.app_name</span><br></pre></td></tr></table></figure><p>explain看下</p><p><img src="/images/pasted-16.png" alt="upload successful"></p><p>结果非常意外，不仅时间没有省下来，索引也没有使用，进行全表扫描，还好我验证了一下，原因的话还不知道，对mysql底层不是很熟悉，先暂时把遇到的问题记录下来吧 ^_^</p><p><strong>结论：子查询会导致索引失效，尽量不使用子查询，用级联查询代替，并将级联查询的条件设置建立索引</strong></p><h5 id="级联查询的原理"><a href="#级联查询的原理" class="headerlink" title="级联查询的原理"></a>级联查询的原理</h5><p>mysql会首先找到一张表作为驱动表，就是首先要进行查询的表，以驱动表为基础匹配剩下的表，inner join的情况mysql会选择数据量小的表作为驱动表，left/right join分别以左/右表作为驱动表；接着会根据on的条件过滤结果，最终将连接的表都筛选完成后如果有where语句指定条件将进行最后的筛选得到结果</p><p>连接的算法也很简单，连接条件没有索引则进行全表扫描然后进行匹配，如果还有表连接则将匹配的结果继续与剩余的表进行扫描匹配，这种方法简单粗暴，叫做嵌套循环连接（Nested-Loop Join）；Mysql对这种方式有了优化，增加了join buffer，是将驱动表关联条件的相关列缓存起来，并将多次匹配合并，减少的匹配的次数，以此方式来加速查询结果，叫做BLJ算法（Block Nested-Loop Join）；有索引则会先匹配索引，匹配后的结果再插到对应的数据返回</p><p>综上，级联查询的查询条件最好是加索引，虽然mysql对没有索引的链接做了优化，那也是没有索引的方式快的，而且最好链接的条件是主键索引，这是由于非主键索引指向的时主键索引，要得到数据还要跑一次主键索引；还有我想到了阿里巴巴java开发规范中写道多余三张表不能使用join，用多次简单查询代替这个也要注意一下</p><p>参考： <a href="https://www.jianshu.com/p/048d93d3ee54" target="_blank" rel="noopener">MySQL查询优化——连接以及连接原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;子查询导致索引失效&lt;/p&gt;
&lt;p&gt;连接查询（连接条件为索引）的效率更高&lt;/p&gt;
&lt;h5 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h5&gt;&lt;p&gt;微服务相关管理端的系统，用户会在自己对应服务的
      
    
    </summary>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>踩坑记录</title>
    <link href="http://yoursite.com/2019/11/06/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/11/06/踩坑记录/</id>
    <published>2019-11-06T05:52:26.000Z</published>
    <updated>2020-03-20T08:22:02.332Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在xml文件中if条件判断字符串相等时要用双引号而不是单引号"><a href="#在xml文件中if条件判断字符串相等时要用双引号而不是单引号" class="headerlink" title="在xml文件中if条件判断字符串相等时要用双引号而不是单引号"></a>在xml文件中if条件判断字符串相等时要用双引号而不是单引号</h4><ul><li><p>错误栗子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;if test=&quot;params.appName != null and params.appName != &apos;&apos; and params.appName != &apos;*&apos;&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>正确栗子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;if test=&apos;params.appName != null and params.appName != &quot;&quot; and params.appName != &quot;*&quot;&apos;&gt;</span><br></pre></td></tr></table></figure></li><li><p>MyBatis会将’*’转化为数字，并且会报NumberFormatException</p></li><li><p>原因百度了一下大概是这样，MyBatis使用OGNL表达式来解析，在OGNL表达式中单引号和其中的字符会被解析成一个字符，java对于没有引号的等式/不等式认为是数字类型并进行转化</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;在xml文件中if条件判断字符串相等时要用双引号而不是单引号&quot;&gt;&lt;a href=&quot;#在xml文件中if条件判断字符串相等时要用双引号而不是单引号&quot; class=&quot;headerlink&quot; title=&quot;在xml文件中if条件判断字符串相等时要用双引号而不是单引号&quot;&gt;
      
    
    </summary>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>maven-assembly插件打zip包</title>
    <link href="http://yoursite.com/2019/10/11/maven-assembly%E6%8F%92%E4%BB%B6%E6%89%93zip%E5%8C%85/"/>
    <id>http://yoursite.com/2019/10/11/maven-assembly插件打zip包/</id>
    <published>2019-10-11T09:50:37.000Z</published>
    <updated>2020-03-20T08:22:02.251Z</updated>
    
    <content type="html"><![CDATA[<p>web工程通过maven打包通常都是war包，Tomcat会自动将war包解压并发布出来，但如果本身做的不是web工程，是普通java项目如何发布到服务器上并运行main方法呢？公司里使用maven-assembly这个插件，将项目打包成zip压缩包，里面包含bin、conf和lib三个文件夹，bin目录中保存启动和停止的shell脚本，conf中保存配置文件，lib目录中保存编译好的jar和所依赖的jar；然后将zip包抽取并解压到服务器启动start.sh脚本来运行java项目。</p><p>在这个过程中就用到了maven-assembly这个插件来进行编译并打包，步骤如下</p><p>目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">  |--assembly</span><br><span class="line">         |----bin</span><br><span class="line">               |---start.sh</span><br><span class="line">               |---stop.sh</span><br><span class="line">               |---jvm.properties</span><br><span class="line">         |----assembly.xml</span><br></pre></td></tr></table></figure><ul><li><ol><li>pom中配置assembly插件</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!--打包规则的配置--&gt;</span><br><span class="line">&lt;descriptors&gt;</span><br><span class="line">&lt;descriptor&gt;src/main/assembly/assembly.xml&lt;/descriptor&gt;</span><br><span class="line">&lt;/descriptors&gt;</span><br><span class="line">&lt;tarLongFileMode&gt;posix&lt;/tarLongFileMode&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;executions&gt;</span><br><span class="line">&lt;execution&gt;</span><br><span class="line">&lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">&lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">&lt;goals&gt;</span><br><span class="line">&lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">&lt;/goals&gt;</span><br><span class="line">&lt;/execution&gt;</span><br><span class="line">&lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>注：使用assembly插件编译要讲该插件的配置放在plugins标签中的第一个，在我的工程中开始在前面的时spring-boot-maven-plugin插件导致编译失败了</p><ul><li>2.创建并配置assembly.xml文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;assembly&gt;</span><br><span class="line"></span><br><span class="line">    &lt;id&gt;assembly&lt;/id&gt;</span><br><span class="line"></span><br><span class="line">    &lt;formats&gt;</span><br><span class="line">        &lt;format&gt;zip&lt;/format&gt;</span><br><span class="line">        &lt;format&gt;dir&lt;/format&gt;</span><br><span class="line">    &lt;/formats&gt;</span><br><span class="line"></span><br><span class="line">    &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--输出文件的配置  3个属性分别是 编译路径 输出路径 文件权限--&gt;</span><br><span class="line">    &lt;fileSets&gt;</span><br><span class="line">        &lt;fileSet&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;outputDirectory&gt;conf&lt;/outputDirectory&gt;</span><br><span class="line">            &lt;fileMode&gt;0644&lt;/fileMode&gt;</span><br><span class="line">        &lt;/fileSet&gt;</span><br><span class="line">        &lt;fileSet&gt;</span><br><span class="line">            &lt;directory&gt;src/main/assembly/bin&lt;/directory&gt;</span><br><span class="line">            &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;start.sh&lt;/include&gt;</span><br><span class="line">                &lt;include&gt;stop.sh&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">            &lt;fileMode&gt;0755&lt;/fileMode&gt;</span><br><span class="line">        &lt;/fileSet&gt;</span><br><span class="line">        &lt;fileSet&gt;</span><br><span class="line">            &lt;directory&gt;src/main/assembly/bin&lt;/directory&gt;</span><br><span class="line">            &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;jvm.properties&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">            &lt;filtered&gt;true&lt;/filtered&gt;</span><br><span class="line">            &lt;fileMode&gt;0644&lt;/fileMode&gt;</span><br><span class="line">        &lt;/fileSet&gt;</span><br><span class="line">    &lt;/fileSets&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencySets&gt;</span><br><span class="line">        &lt;dependencySet&gt;</span><br><span class="line">            &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt;</span><br><span class="line">        &lt;/dependencySet&gt;</span><br><span class="line">    &lt;/dependencySets&gt;</span><br><span class="line"></span><br><span class="line">&lt;/assembly&gt;</span><br></pre></td></tr></table></figure><ul><li>3.编写脚本</li></ul><p>start.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">BASEDIR=`dirname $0`/..</span><br><span class="line">BASEDIR=`(cd &quot;$BASEDIR&quot;; pwd)`</span><br><span class="line">echo current path:$BASEDIR</span><br><span class="line"></span><br><span class="line">BASEBIN_DIR=$BASEDIR&quot;/bin&quot;</span><br><span class="line">cd $BASEBIN_DIR</span><br><span class="line"></span><br><span class="line">LAF_REG_INSTANCE=&quot;test-jsf-demo&quot;</span><br><span class="line">LOGPATH=&quot;&quot;</span><br><span class="line">LAF_REG_PIDPATH=&quot;$BASEBIN_DIR&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; != &quot;&quot; ] &amp;&amp; [ &quot;$2&quot; != &quot;&quot; ]; then</span><br><span class="line">    LAF_REG_INSTANCE=&quot;$1&quot;</span><br><span class="line">    LOGPATH=&quot;$2&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$3&quot; != &quot;&quot; ]; then</span><br><span class="line">    LAF_REG_PIDPATH=&quot;$3&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ------ check if server is already running</span><br><span class="line">PIDFILE=$LAF_REG_PIDPATH&quot;/&quot;$LAF_REG_INSTANCE&quot;_startup.pid&quot;</span><br><span class="line">if [ -f $PIDFILE ]; then</span><br><span class="line">    if kill -0 `cat $PIDFILE` &gt; /dev/null 2&gt;&amp;1; then</span><br><span class="line">        echo server already running as process `cat $PIDFILE`.</span><br><span class="line">        exit 0</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># ------ set JAVACMD</span><br><span class="line"># If a specific java binary isn&apos;t specified search for the standard &apos;java&apos; binary</span><br><span class="line">if [ -z &quot;$JAVACMD&quot; ] ; then</span><br><span class="line">  if [ -n &quot;$JAVA_HOME&quot;  ] ; then</span><br><span class="line">    if [ -x &quot;$JAVA_HOME/jre/sh/java&quot; ] ; then</span><br><span class="line">      # IBM&apos;s JDK on AIX uses strange locations for the executables</span><br><span class="line">      JAVACMD=&quot;$JAVA_HOME/jre/sh/java&quot;</span><br><span class="line">    else</span><br><span class="line">      JAVACMD=&quot;$JAVA_HOME/bin/java&quot;</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">    JAVACMD=`which java`</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -x &quot;$JAVACMD&quot; ] ; then</span><br><span class="line">  echo &quot;Error: JAVA_HOME is not defined correctly.&quot;</span><br><span class="line">  echo &quot;  We cannot execute $JAVACMD&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># ------ set CLASSPATH</span><br><span class="line">CLASSPATH=&quot;$BASEDIR&quot;/conf/:&quot;$BASEDIR&quot;/root/:&quot;$BASEDIR&quot;/lib/*</span><br><span class="line">echo &quot;$CLASSPATH&quot;</span><br><span class="line"></span><br><span class="line"># ------ set jvm memory</span><br><span class="line">sed &quot;s/\r$//g&quot; jvm.properties &gt; 1.properties</span><br><span class="line">mv 1.properties jvm.properties</span><br><span class="line">if [ -z &quot;$OPTS_MEMORY&quot; ] ; then</span><br><span class="line">    OPTS_MEMORY=&quot;`sed -n &apos;1p&apos; jvm.properties`&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;`sed -n &apos;2p&apos; jvm.properties`&quot; != &quot;&quot; ] ; then</span><br><span class="line">    JAVA_CMD=&quot;`sed -n &apos;2p&apos; jvm.properties`&quot;</span><br><span class="line">    if [ -f $JAVA_CMD ]; then</span><br><span class="line">        JAVACMD=$JAVA_CMD</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#DEBUG_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000&quot;</span><br><span class="line">#JPDA_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n&quot;</span><br><span class="line"># ------ run proxy</span><br><span class="line">nohup &quot;$JAVACMD&quot; $JPDA_OPTS \</span><br><span class="line">  $OPTS_MEMORY $DEBUG_OPTS \</span><br><span class="line">  -classpath &quot;$CLASSPATH&quot; \</span><br><span class="line">  -Dbasedir=&quot;$BASEDIR&quot; \</span><br><span class="line">  -Dfile.encoding=&quot;UTF-8&quot; \</span><br><span class="line">  com.jd.testjsfdemo.TestjsfdemoApplication \</span><br><span class="line">  &gt; /Users/Logs/testjsfdemo_std.out &amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ------ wirte pid to file</span><br><span class="line">if [ $? -eq 0 ]</span><br><span class="line">then</span><br><span class="line">    if /bin/echo -n $! &gt; &quot;$PIDFILE&quot;</span><br><span class="line">    then</span><br><span class="line">        sleep 1</span><br><span class="line">        echo STARTED SUCCESS</span><br><span class="line">    else</span><br><span class="line">        echo FAILED TO WRITE PID</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">#    tail -100f $LOGFILE</span><br><span class="line">else</span><br><span class="line">    echo SERVER DID NOT START</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>stop.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">BASEDIR=`dirname $0`</span><br><span class="line">BASEDIR=`(cd &quot;$BASEDIR&quot;; pwd)`</span><br><span class="line">echo current path $BASEDIR</span><br><span class="line"></span><br><span class="line">LAF_REG_INSTANCE=&quot;test-jsf-demo&quot;</span><br><span class="line">LAF_REG_PIDPATH=&quot;$BASEDIR&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; != &quot;&quot; ]; then</span><br><span class="line">    LAF_REG_INSTANCE=&quot;$1&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$2&quot; != &quot;&quot; ]; then</span><br><span class="line">    LAF_REG_PIDPATH=&quot;$2&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">PIDFILE=$LAF_REG_PIDPATH&quot;/&quot;$LAF_REG_INSTANCE&quot;_startup.pid&quot;</span><br><span class="line">echo $PIDFILE</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;$PIDFILE&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;no registry to stop (could not find file $PIDFILE)&quot;</span><br><span class="line">else</span><br><span class="line">    kill $(cat &quot;$PIDFILE&quot;)</span><br><span class="line">    sleep 10</span><br><span class="line">    kill -9 $(cat &quot;$PIDFILE&quot;)</span><br><span class="line">    rm -f &quot;$PIDFILE&quot;</span><br><span class="line">    echo STOPPED</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br><span class="line"></span><br><span class="line">echo stop finished.</span><br></pre></td></tr></table></figure><p>jvm.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m -Xmx1024m -Xmn400m</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin/java</span><br></pre></td></tr></table></figure><ul><li>4.编译后就成功啦，之后在jdos上配置一下就可以自动部署了</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;web工程通过maven打包通常都是war包，Tomcat会自动将war包解压并发布出来，但如果本身做的不是web工程，是普通java项目如何发布到服务器上并运行main方法呢？公司里使用maven-assembly这个插件，将项目打包成zip压缩包，里面包含bin、con
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://yoursite.com/2019/09/19/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/19/观察者模式/</id>
    <published>2019-09-19T11:43:41.000Z</published>
    <updated>2020-03-20T08:22:02.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>包含观察者和被观察者两个部分，原理也很简单，被观察者类中维护观察者对象的集合，当感兴趣的事件发生，遍历观察者的集合回调观察者对象中的相应方法（update）即可</p><p>被观察者除了维护观察者的集合外，还有对该集合的增（注册）、删（取消）及通知等操作</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">    update(String msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ObserverImpl implements Observer &#123;</span><br><span class="line">private String name = &quot;&quot;;</span><br><span class="line">Observer(String name)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">@override</span><br><span class="line">public void update(String msg)&#123;</span><br><span class="line">// 感兴趣的事件发生</span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="被观察者"><a href="#被观察者" class="headerlink" title="被观察者"></a>被观察者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Observed&#123;</span><br><span class="line">registerObserver(Observer observer);</span><br><span class="line">removeObserver(Observer observer);</span><br><span class="line">notify(Observer observer);</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ObservedImpl implements Observed&#123;</span><br><span class="line">    private static List&lt;Observer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void registerObserver(Observer observer)&#123;</span><br><span class="line">        list.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void removeObserver(Observer observer)&#123;</span><br><span class="line">        list.remove(Observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void notify(Observer observer)&#123;</span><br><span class="line">        list.stream().filter(n -&gt; n.equals(observer)).update(&quot;notify&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void notifyAll()&#123;</span><br><span class="line">        list.stream().map(n -&gt; n.update(&quot;notifyAll&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observed o = new ObservedImpl();</span><br><span class="line">Observer o1 = new ObserverImpl(&quot;o1&quot;);</span><br><span class="line">Observer o2 = new ObserverImpl(&quot;o2&quot;);</span><br><span class="line">o.registerObserver(o1);</span><br><span class="line">o.registerObserver(o2);</span><br><span class="line">o.notifyAll();</span><br></pre></td></tr></table></figure><h4 id="Observer-和-Observable"><a href="#Observer-和-Observable" class="headerlink" title="Observer 和 Observable"></a>Observer 和 Observable</h4><p>jdk中提供了观察者模式的API，java.util包下的Observer接口和Observable类，原理是一样的，这里只是进行的封装</p><p>上源码</p><h5 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">    void update(Observable o, Object arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面观察者的部分一样，实现一个回调方法，当感兴趣的事件发生回调该方法</p><p>使用时，实现Observer接口，重写update方法即可，当感兴趣的事件发生会回调update方法，这里会写增加的业务逻辑</p><h5 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class Observable &#123;</span><br><span class="line">    private boolean changed = false;</span><br><span class="line">    private Vector&lt;Observer&gt; obs;</span><br><span class="line">    </span><br><span class="line">    public Observable() &#123;</span><br><span class="line">        obs = new Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void addObserver(Observer o) &#123;</span><br><span class="line">        if (o == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        if (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void deleteObserver(Observer o) &#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void notifyObservers() &#123;</span><br><span class="line">        notifyObservers(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void notifyObservers(Object arg) &#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (!changed)</span><br><span class="line">                return;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = arrLocal.length-1; i&gt;=0; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(this, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void deleteObservers() &#123;</span><br><span class="line">        obs.removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected synchronized void setChanged() &#123;</span><br><span class="line">        changed = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected synchronized void clearChanged() &#123;</span><br><span class="line">        changed = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized boolean hasChanged() &#123;</span><br><span class="line">        return changed;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public synchronized int countObservers() &#123;</span><br><span class="line">        return obs.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同样，这里维护一个观察者的集合Vector，这里考虑了线程安全的问题，说明这种方式实现的观察者模式是线程安全的</li><li>除此之外还有一个bool类型的变量changed表示被观察者是否发生改变（也就是感兴趣的事件是否发生），通过该标志来通知观察者对象</li><li>同样，该类里有针对观察者集合的增、删、通知的操作，还多了对changed标志修改的操作；除此之外所有方法都有synchronized关键字，进一步说明了这种方式的观察者模式是线程安全的</li><li>使用时，在要被观察的类中继承Observable类，再添加实现了Observer接口的观察者对象，调用setChanged()方法改变changed标志后通过调用notify()方法进行通知</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h3&gt;&lt;p&gt;包含观察者和被观察者两个部分，原理也很简单，被观察者类中维护观察者对象的集合，当感兴趣的事件发生，遍历观察者的集合回
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper扫盲</title>
    <link href="http://yoursite.com/2019/08/29/Zookeeper%E6%89%AB%E7%9B%B2/"/>
    <id>http://yoursite.com/2019/08/29/Zookeeper扫盲/</id>
    <published>2019-08-29T07:23:15.000Z</published>
    <updated>2020-03-20T08:22:02.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>是一个分布式协调服务框架，这句话对于刚接触ZK（Zookeeper下文简称ZK）的我来说太抽象了，很难理解，只知道它能提供一些服务能够实现配置管理、命名服务、分布式锁等等，也就是在这些场景下会使用到ZK，这样说好像还是很难理解；之后，我找到了一个比较好理解的点，就是从CAP理论的角度，这需要对CAP有些了解，提前做了功课(<a href="http://yywang.top/2019/08/26/CAP%E5%92%8CBASE/#more" target="_blank" rel="noopener">CAP和BASE</a>)，简单来说在分布式系统中出现网络故障时，最多满足其中的两项，而P是必须要满足的，那么就需要从CP和AP中做选择了；ZK就是可保证CP的框架，最后我的理解就是ZK通过特定的数据结构，封装一系列算法通过API的方式提供分布式环境数据一致性的服务，所有需要数据一致性的场景都可以使用ZK，也就是上面提到的配置管理、命名服务、分布式锁等等场景</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>ZK提供了一套类似于文件目录的数据结构，叫做多层级的节点命名空间，每个节点（ZK中称为znode）都可以存放数据且每个节点下都有若干个子节点，听起来和树的结构差不多，其实也一样，目录也是一种树结构的实现，znode可以理解为文件夹，文件夹中可以存放文件（znode可以存放数据），也可以存放文件夹（znode也可以存放znode）</p><h5 id="znode的类型"><a href="#znode的类型" class="headerlink" title="znode的类型"></a>znode的类型</h5><ul><li>PERSISTENT–持久化目录节点<ul><li>客户端和ZK断开连接后节点依然存在</li></ul></li><li>PERSISTENT_SEQUENTIAL–持久化顺序编号目录节点<ul><li>与持久化目录节点相同，只是多了ZK对节点的顺序编号</li></ul></li><li>EPHEMERAL–临时目录节点<ul><li>客户端和ZK断开连接后节点被删除</li></ul></li><li>EPHEMERAL_SEQUENTIAL–临时顺序编号目录节点<ul><li>与临时目录节点相同，只是多了ZK对节点的顺序编号 </li></ul></li></ul><h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p>ZK还提供了类似于观察这模式的通知机制，称为watcher事件，可以观察到znode的变化，来通知客户端，之后客户端再做相应的业务逻辑</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h4><p>这里命名服务指的是通过指定名字获取对应的资源，将资源存储在特定路径的znode中，根据路径就可以找到资源，类比目录结构来说，拿到文件的地址就能通过地址来找到文件，有点像是URL的意思，但是由于ZK数据结构设计的因素ZK不能存放较大的数据；微服务框架中的注册中心需要存放provider和consumer的信息，并且consumer要能够感知provider的实时状态，ZK可以根据provider和consumer的地址映射成临时znode结构，这样既保存了provider和consumer的信息还能感知彼此的状态</p><h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p>一句话解释—-动态下发配置文件变化；通过ZK客户端watch配置文件，一旦配置文件发生变化马上通知客户端做对应的处理</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>多个客户端再ZK的同一个目录下尝试创建临时znode，成功创建znode意味着获得锁成功，下个客户端发现目录下已经存在znode则对该znode添加watch机制，当znode消失即为释放锁后，通知客户端尝试创建znode来获取锁，这是公平锁；非公平锁的则创建临时有序的znode，相当于一个队列，后面的节点watch前一个节点的znode的状态，队头的znode为获得锁成功的几点</p><h3 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h3><h4 id="ZK节点的状态"><a href="#ZK节点的状态" class="headerlink" title="ZK节点的状态"></a>ZK节点的状态</h4><ul><li>LOOKING–当前节点不知道leader是谁，正在搜索</li><li>LEADING–当前节点为集群的leader</li><li>FOLLOWING–目前已有leader，当前节点负责与leader节点同步</li></ul><h4 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h4><p>在两种情况下会进行选举，1.服务器初始化启动 2.集群中leader节点故障</p><p>起初集群中的节点没有leader或者不知道leader是谁，此时节点的状态为LOOKING，如果当前集群存在leader（该节点新加入集群），此节点发送投票信息想要选举leader会被告知当前leader的信息，此节点只需和leader节点建立连接，并进行状态同步即可；</p><p>如果当前集群不存在leader节点，则需要投票进行选举</p><ul><li>此时所有节点皆为LOOKING状态，并编辑投票信息发送给集群的其他节点，投票信息的格式为（SID,ZXID）（服务器的唯一标识，事务ID），SID是自己配置的，ZXID理解为当前节点数据的版本；</li><li>集群中的节点会受到其他节点的投票信息，加上自己的那一票会根据一个规则会投出第二轮的选票<ul><li>节点会在自己收到的选票中，选择ZXID最大的作为第二轮的选票发送给集群中其他节点</li><li>如果ZXID相同则选择SID最大的作为第二轮的选票发送给集群中其他节点</li></ul></li><li>集群中的节点在接收到第二轮选票后进行统计（包含自己的一票），获得集群中一半以上（&gt;n/2）数量投票的节点当选leader进入LEADING状态，其余节点进入FOLLOWING状态</li></ul><p>总结一下，集群中要获得一半以上的投票才能当选leader，所以集群最少为3台，并且数量是奇数；集群中ZXID越大的节点（当前节点数据版本越新）优先当选leader</p><h3 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h3><p>整个过程没有难度也很好理解，跟着<a href="https://www.jianshu.com/p/5491d16e6abd" target="_blank" rel="noopener">这篇文章</a>做就完事了</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本文是对于Zookeeper的扫盲，大致了解ZK的基本原理，为了更好的理解工作中的项目，具有目的性，一些细节没有去研究，下回再补，😋</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://jm.taobao.org/2011/10/08/1232/" target="_blank" rel="noopener">ZooKeeper典型应用场景一览</a></p><p><a href="https://www.jianshu.com/p/5491d16e6abd" target="_blank" rel="noopener">笔记：Mac上zookeeper的安装与启动</a></p><p><a href="https://segmentfault.com/a/1190000014479433?utm_source=tag-newest" target="_blank" rel="noopener">zookeeper面试题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Zookeeper&quot;&gt;&lt;a href=&quot;#Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper&quot;&gt;&lt;/a&gt;Zookeeper&lt;/h3&gt;&lt;p&gt;是一个分布式协调服务框架，这句话对于刚接触ZK（Zookeeper下文简称ZK）的我
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CAP和BASE</title>
    <link href="http://yoursite.com/2019/08/26/CAP%E5%92%8CBASE/"/>
    <id>http://yoursite.com/2019/08/26/CAP和BASE/</id>
    <published>2019-08-26T08:52:51.000Z</published>
    <updated>2020-03-20T08:22:02.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>Consistency（一致性） Availability（可用性） Partition tolerance（分区容错性）</p><p>CAP理论的内容是在分布式系统中出现网络故障时最多只能满足CAP中的两项</p><ul><li>Consistency 一致性<ul><li>“all node see the same data at the same time” 就是指分布式系统的数据一致性，可用看出这里的一致性指的是强一致性，要求分布式系统数据发生改变后所有节点在后续的请求中都能感知到</li><li>强一致性，当数据发生改变，系统中的其他节点在下次请求都会感知到</li><li>弱一致性，保证某个时间级别（比如xx秒），数据能够达到数据一致的状态</li><li>最终一致性，弱一致性的一个特例，保证在一段时间内达到数据一致的状态</li></ul></li><li>Availability 可用性<ul><li>“Reads and Writes always succeed”，这里的succeed指的是请求和响应的过程成功，也每次请求都会在有限的时间内收到回复，换句话说就是服务器可用；并不是请求的返回值是成功的意思，返回值是失败也是有返回值的，同样说明请求响应的过程是成功的。</li><li>系统可用性5个9，意为分布式系统的可用水平为99.999%，全年停机时间不超过 <strong>(1-0.99999)<em>365</em>24*60 = 5.256 min</strong></li></ul></li><li>Partition tolerance 分区容错性<ul><li>“the system continues to operate despite arbitrary message loss or failure of part of the system” 分区指的是由于网络异常集群中只有部分节点能够正常通信，可能存在多个能够通信的子网络，这些子网络就是分区；又或者说集群中部分服务器宕机，其他服务器依然可用，这部分可用的服务器组成的子网络也可以称为分区。分区容错性是指当出现网络延迟或者故障的情况时系统依然能够提供服务</li></ul></li></ul><p>怎么理解呢？简单来说就是在分布式系统中发生故障时，CAP最多只能满足其中的两项，也就是CAP三选二呗，但是我们发现P（分区容错性）说白了就是指网络出问题后系统依然可用，这可是分布式系统的基础条件，应该必须满足；在满足分区容错性时有可能会存在两种问题</p><ul><li>1.用户访问部分服务器间的网络异常，这时只需将请求转发到可用的服务器即可，这时在理想情况下（服务器间的网络通畅）是可以满足CAP的，除非和所有服务器的网络都有问题（<strong>这只是理想情况</strong>）</li><li>2.除了用户访问服务器的网络异常之外，分布式系统中不同服务器直接的网络也可能存在异常，例如分布式系统中有A、B两台服务器，假设A、B之间存在网络故障，当服务器A改变数据之后无法同步到服务器B，此时就不能保证强一致性和可用性同时满足<ul><li>放弃强一致性（C），用户请求A可以得到最新的数据，用户请求B得到的是旧数据；可以保证用户每次请求都会返回结果，但不能保证数据的一致性</li><li>放弃可用性（A），为了保证数据的强一致性，数据每次修改后都需要等待所有的数据源都同步后才能进行读写，用户请求服务器A或者B，由于数据始终不能同步，最后会一直阻塞下去，不能保证用户的每次都能短时间内得到返回值甚至得不到返回值</li></ul></li></ul><p>综上，我认为的CAP理论是在分布式系统中服务器之间网络出现问题时，CAP最多只能满足其二，并不是分布式系统就只能满足CAP中的两项，理想情况下是都可满足的（虽然现在不大可能）；况且在分布式系统中P是必须满足的，也就是说CA只能满足其一，具体的取舍需要根据不同的业务场景权衡</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><ul><li>Basically Available（基本可用）<ul><li>系统设计中可以牺牲部分可用性，比如允许响应时间增加1-2秒，服务降级等</li></ul></li><li>Soft state（软状态）<ul><li>允许系统中的数据存在中间状态，允许数据同步过程存在延迟</li></ul></li><li>Eventually consistent（最终一致性）<ul><li>所有数据再一段时间的数据同步后都能达到一致的状态 </li></ul></li></ul><p>综上，不同的业务以BASE理论为基础对可用性和一致性进行一个权衡；zk和数据库的主从都是舍弃高可用性；涉及到用户体验的场景则需要舍弃数据强一致性如12306买火车票，618和双11等对于用户的每个请求都需要给与响应，允许存在短时间数据不一致的状态</p><p><a href="http://www.hollischuang.com/archives/666" target="_blank" rel="noopener">参考资料</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CAP理论&quot;&gt;&lt;a href=&quot;#CAP理论&quot; class=&quot;headerlink&quot; title=&quot;CAP理论&quot;&gt;&lt;/a&gt;CAP理论&lt;/h3&gt;&lt;p&gt;Consistency（一致性） Availability（可用性） Partition tolerance（分区容
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>缓存更新的套路 总结与感受</title>
    <link href="http://yoursite.com/2019/08/21/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%A5%97%E8%B7%AF-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%84%9F%E5%8F%97/"/>
    <id>http://yoursite.com/2019/08/21/缓存更新的套路-总结与感受/</id>
    <published>2019-08-21T06:51:35.000Z</published>
    <updated>2020-03-20T08:22:02.332Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注：</strong> 本文是阅读 [缓存更新的套路] (<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17416.html</a>) 一文的总结，本文是以经常用到的Redis+MySQL的角度解读</p><h3 id="经典方法-–-Cache-Aside-Pattern"><a href="#经典方法-–-Cache-Aside-Pattern" class="headerlink" title="经典方法 – Cache Aside Pattern"></a>经典方法 – Cache Aside Pattern</h3><ul><li>读操作：先从Redis中获取，没有命中则从MySQL中获取，最后更新到Redis中</li><li>写操作：先写MySQL，成功后删除Redis中的数据</li></ul><p>为什么这样的方案会是经典方法呢？因为简单，有效，错误少</p><ul><li>场景1–写操作如果先删除Redis中的数据再操作数据库<ul><li>如果一个写操作和读操作并发执行，写操作删除了Redis中的数据还没来得及将数据更新到MySQL中，读操作没有在Redis中读取到数据，而从MySQL中读到旧的数据并更新到了Redis中，这样虽然MySQL中的数据是正确的，因为Redis的存在使得每次读取的数据都是脏数据。（这种情况只会发生在删除Redis数据后，写MySQL前这段时间，因为写MySQL时可以通过加悲观锁来避免问题）</li></ul></li><li>场景2–写操作后增加更新Redis数据<ul><li>这样读和写的操作都会更新Redis数据看似更稳健了，其实不然，更新操作变多了脏数据也会变多，比如有两个写操作a和b，按照请求的时间来说最终的状态应该是b，极端情况下ab都完成了更新数据库的操作，在更新Redis的时候，b先完成了，随后a完成又将Redis数据改成了a的状态，这样还是会存在脏数据 ，虽然出现的概率不大相对于经典方法多了产生脏数据的可能性，所以不可取</li></ul></li><li>场景3–脏数据<ul><li>经典方法可以避免场景1和2的问题，但也不是万无一失的，当一个读操作在Redis中没有命中时，从MySQL中获取了数据，在更新Redis数据之前，有一个写操作完成，此时MySQL的数据已经变了，而读操作会把之前的数据写入Redis中，产生脏数据。而这样的场景发生的几率非常非常小，由于MySQL锁的限制，只能发生在读操作读取数据之后读操作更新Redis数据之前，并且这段时间有一个写操作完成，同样因为锁的存在写操作一般都比读操作会耗时，并且给Redis数据增加过期时间进一步减小脏数据的产生几率</li></ul></li></ul><p>综上所述，虽然经典方法在场景3略有瑕疵，但依然经典可用，因为其简单，有效，错误少</p><h3 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h3><ul><li>读操作：Redis命中直接返回；没有命中从MySQL中读取后更新到Redis中</li><li>写操作：Redis中命中更新Redis；没有命中更新MySQL</li></ul><p>这种模式写操作只针对于一个数据库（MySQL或者Redis），读数据时在Redis中没有命中会从MySQL中读取到Redis中，长时间运行后大部分数据都会在Redis中命中，写操作也会针对于Redis，相当于是强依赖于Redis，弱依赖甚至不依赖于MySQL，这么看来这种方式是最高效的，但是有一个致命的缺点，数据可能会丢失，由于强依赖于Redis中的数据，同样强依赖于Redis的高可用性，当Redis的数据丢失没有很好的灾备的话，数据就没了，这时如果想通过MySQL恢复几乎是不可能的了。总结一下，这种模式有利有弊，具体使用场景需要针对于具体的业务场景，我认为如果有比较好的Redis高可用和灾备的策略，这种模式还是非常好用的。</p><h3 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h3><ul><li>读操作：Redis命中直接返回；没有命中则从MySQL中获取数据返回</li><li>写操作：无论Redis命中与否都先更新Redis，接着异步更新MySQL中的数据</li></ul><p>原文中也提到，这么做会极大的提高I/O，相当于只操作了Redis，是内存级别的读写，同时这么做也有缺点，就是在同步数据到MySQL时如果服务器宕机断电等事故将会永久性的数据丢失</p><h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>摘取了一些大佬们的评论，很有启发</p><ul><li>一位名叫 ty 的大佬说：”Cache Aside Pattern模式，两个更新操作同时进来，也可能会有cache脏数据的问题啊<br>顺序如下：<br>第一个写数据库，第二个写数据库，第二个写cache，第一个写cache<br>这样cache里是第一个数据，而数据库里是第二个“</li><li>——–这和我想的是一样的，哈哈</li></ul><hr><ul><li>一位名叫 letsgowei 的大佬说：”在做更新操作时不可以更改数据库后直接更新缓存吗？这样最多也就一两次脏数据“</li><li>——–这位大佬的疑惑应该是为什么更新操作只是删除缓存或者把缓存设置为无效，而不是更新缓存呢？还有一位评论有同样的疑惑；这个问题我没有考虑到，觉得他们说的有道理直接更新也可以啊？</li><li>一位名叫 longsen 的大佬做出了解答：”1. 读线程查key未在cache中；2.读线程从db读数据；3.写线程更改数据库；4.写线程看key未在cache中，无法更新cache；5.读线程将旧数据写入cache中。这种场景旧数据可能在cache存在很长时间“</li><li>——–大佬给出的解释是cache中没有key无法更新，I don’t think so！至少在Redis的环境下是不存在的，key不存在直接set，key存在直接覆盖，Redis是有这样的命令的，所以这个回答我不同意，如果将写MySQL后将Redis中的key删除的操作，改成更新Redis的Key操作，这样一来就和我上面提到的场景2是一样的的了，读写都更新Redis增加了产生脏数据的概率，所以是不可取的</li></ul><hr><ul><li>一位名叫 泪滴 的大佬说：”大神！你的这个更新顺序是建立在更新数据库，更新缓存都不会发生失败的情况下的，单独考虑并发问题得到的顺序！<br>方案1：先更新数据库，再删除缓存，当出现并发问题概率很小(假设概率为R1)，会造成脏数据。当出现网络等问题导致删除缓存失败(假设概率为R2)，会导致之后的请求一直是脏数据。<br>方案2：先删除缓存，再更新数据库，当出现并发问题概率较大(假设概率为R3)，会导致之后的请求一直是脏数据，当出现网络问题，删除缓存成功，更新数据库失败，只会引发一次cache miss，在业务上基本没啥影响。当然为了弥补，我们一般都会设置缓存的过期时间，来缩短出现脏数据的时间。现在问题的关键就是R1+R2和R3的大小问题了，如果大厂，网络基础设施啥的比较牛，当然R1+R2&lt;R3选择方案1比较合适，对于广大小厂来说还真的可能R1+R2&gt;R3那怎么选择，就比较清楚了。“</li><li>——–说实话，他的评论让我眼前一亮，他的分析具体到了应用场景上，而且确实有这样的情况出现，所以说没有最完美的设计只有最合适的设计，给这位大佬点赞</li></ul><hr><ul><li>还有一些则是针对于原文中Write Behind Caching Pattern部分的流程图的疑问，例如缓存未命中为什么回写数据再更新数据，直接更新数据不就好了吗？写数据未命中为什么还有判断dirty的标志？等等，这些问题我也不懂，云里雾里的，不知道为什么这么设计，不就是异步更新MySQL吗，搞这么复杂是为什么，后来我冷静的分析一下，这篇文章是缓存更新的套路，当前部分是缓存异步更新MySQL的介绍，而流程图和异步半毛钱关系都没有，为什么？</li><li>——–因为我太垃圾了，文章中 xxPattern 指的是Linux内核中的缓存更新模式，作者是将这些模式应用到分布式环境下缓存更新中，所以说这部分的流程图是指Linux内核的缓存更新而不是分布式环境下的缓存更新，作者在文章中不止一次提到了基础很重要就体现出来了，而且作者也提到宏观的系统架构设计其实和计算机系统结构中微观的设计是相似的，所以想要设计好一个大型的分布式系统必须对计算机系统结构非常了解</li></ul><hr><p>综上所述–基础很重要</p><p>以上是我拜读耗子哥的<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">《缓存更新的套路》</a>一文后的一些总结和思考，推荐大家读原文哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 本文是阅读 [缓存更新的套路] (&lt;a href=&quot;https://coolshell.cn/articles/17416.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coolshell.
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>一次Spring事务不回滚的踩坑记录</title>
    <link href="http://yoursite.com/2019/08/16/%E4%B8%80%E6%AC%A1Spring%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%9B%9E%E6%BB%9A%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/08/16/一次Spring事务不回滚的踩坑记录/</id>
    <published>2019-08-16T13:01:13.000Z</published>
    <updated>2020-03-20T08:22:02.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一次Spring事务不回滚的踩坑记录"><a href="#一次Spring事务不回滚的踩坑记录" class="headerlink" title="一次Spring事务不回滚的踩坑记录"></a>一次Spring事务不回滚的踩坑记录</h3><p>Spring事务不回滚八成是不知道Spring默认在捕获到unchecked异常才会自动回滚，然而我早已踩过个坑，是一个有经验的人，当我自信满满的加上一行 1/0，并在catch中 throw new RuntimeException，debug之后我懵了，咋不回滚呢？重启Tomcat，浏览器缓存清理之后再试一次，还是不行！！！我就难受了，这和我预想的不一样，检查代码没有发现错误，那咋办呢？开始百度吧，百度的结果千篇一律，都是针对不了解Spring默认捕获unchecked异常的解决办法，这些早已在我的经验里了，有3种方法</p><ul><li>1.手动抛出unchecked异常，让Spring去捕获，然后自动回滚数据</li><li>2.手动回滚，在发生异常的地方添加代码 <strong>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</strong></li><li>3.在注解的地方添加配置<strong>rollbackFor = { Exception.class }</strong>，让Spring在捕获到特定的异常自动回滚数据 </li></ul><p>3种方法我都知道，但是我一般只用第一种，因为简单，这次我选择用第二种方法试下，竟然没问题了，我意识到是我的问题了，开始检查代码，我的代码逻辑如下（见笑）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean result = false;</span><br><span class="line">try &#123;</span><br><span class="line">    // ...业务逻辑</span><br><span class="line">    System.out.println(1/0);</span><br><span class="line">    // ...业务逻辑</span><br><span class="line">    result = true;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">    // rollback</span><br><span class="line">    throw new RuntimeException(e);</span><br><span class="line">    result = false;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是不知道错在哪里，没有办法开始Debug，惊奇的发现RuntimeException竟然被忽略了，这才发现我finally中有return，被我自己蠢哭了，基础真是太重要了，我还盲目自信的知道Spring的事务如何使用，到头来连try catch finally都没搞清楚，真是太蠢了。接着我修改了代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boolean result = false;</span><br><span class="line">try &#123;</span><br><span class="line">    // ...业务逻辑</span><br><span class="line">    System.out.println(1/0);</span><br><span class="line">    // ...业务逻辑</span><br><span class="line">    result = true;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">    // rollback</span><br><span class="line">    throw new RuntimeException(e);</span><br><span class="line">&#125; </span><br><span class="line">return result;</span><br></pre></td></tr></table></figure><p>这下确实是回滚了，但是返回值是true，想得到的时false，这又难受了，再次Debug，很多次F6后我明白了，RuntimeException是被Spring框架里的层层代理catch了————————————————————————————————————————————————————————————–<br>我把我自己给骗了，RuntimeException抛出程序已经终止了，即使再多的catch最后也不会回到result = true那一行，最终得出原因是其他ajax请求的结果返回到了前台给的提示让我误解了</p><hr><p>到这里我意识到自己是真的菜，补习一下try catch finally吧<br>找到<a href="https://blog.csdn.net/mxd446814583/article/details/80355572" target="_blank" rel="noopener">一篇好文</a></p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><ul><li>如果finally中有return，try和catch中的return会失效，并且<strong>catch中即使抛出unchecked异常也同样会失效</strong>（这是今天踩的坑）；如果finally中有异常相当于整个方法有了异常，那么就没有最终的返回值了,catch中有了异常同样的效果，所以catch和finally中不要出现异常</li><li>如果finally中没有return，try和catch中走最先到达return逻辑的地方，并且在return前将返回值暂存，即使finally中修改也不会有效果；（也就是说没有异常最先到达try块中的return，返回值是try块的返回值，catch和finally修改也不会生效；如果try块有异常最先到达catch块中的return，返回值是catch块的返回值，前提是catch块中没有异常，有异常整个方法都没有返回值）</li><li>综上所述，<strong>使用Spring事务避免不出错优先使用方法2和方法3，方法1比较绕并且对有返回值的逻辑不是很友好；finally块中尽量不要return，这样会忽略try和catch中的异常；最后，基础真的很重要</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一次Spring事务不回滚的踩坑记录&quot;&gt;&lt;a href=&quot;#一次Spring事务不回滚的踩坑记录&quot; class=&quot;headerlink&quot; title=&quot;一次Spring事务不回滚的踩坑记录&quot;&gt;&lt;/a&gt;一次Spring事务不回滚的踩坑记录&lt;/h3&gt;&lt;p&gt;Spring
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
</feed>
