<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YyWang&#39;s Blog</title>
  
  <subtitle>永远没时间的王先森</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-13T12:25:17.332Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YyWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iptables是个啥</title>
    <link href="http://yoursite.com/2021/07/13/iptables/"/>
    <id>http://yoursite.com/2021/07/13/iptables/</id>
    <published>2021-07-13T13:16:15.000Z</published>
    <updated>2021-07-13T12:25:17.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iptables 是 Linux 中经常使用的防火墙，还记得之前部署 Tomcat 服务到一个 web 服务器需要配置新的 iptables 规则，开放8080端口，否则无法访问自<br>己的服务，当时满脑子只想完成任务，网上 copy 命令改改改直接敲，甚至直接粗暴的关闭防火墙 🤐 现在 k8s 中的服务发现以及 service mesh 中的流量劫持<br>都使用到了 iptables。so 今天我来还债了</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>iptables其实不是防火墙，真正的防火墙是 netfilter 字面意思就是网络过滤器，可以过滤进出 Linux 网络协议栈的数据包，通过指定各种自定义的规则对进<br>出的数据包进行拦截修改等操作，netfilter 在内核空间处于内核态，而 iptables 是对 netfilter 的配置工具，通过 iptables 可以配置 netfilter 的<br>过滤规则，iptables 在用户空间处于用户态。这么看 iptables 可以理解成”控制面”，netfilter 可以理解成”数据面”</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>netfilter 在数据包进出 Linux 网络协议栈的不同节点上设有 hooks （可以理解为回调函数），当满足了匹配条件就会出发回调进行后面的操作，hooks 主要<br>在 PRE_ROUTING、LOCAL_IN、FORWARD、LOCAL_OUT 和 POST_ROUTING 5个位置上，覆盖了数据包进出 Linux 协议栈的整个生命周期，来整一张图看下这<br>5个位置（图中橙色的圆型就是）</p><p><img src="/images/iptables1.png" alt="iptables1"></p><ul><li>PRE_ROUTING 在数据包进入被路由前进入这个节点，这个节点之后会进行路由</li><li>LOCAL_IN 在数据包被路由之后，判定目的地址是本机，会进入这个节点，这个节点之后会将数据包传递给应用程序</li><li>FORWARD 在数据包被路由之后，判定目的地址不是本机，会进入这个节点，这个节点之后会重新路由，将数据包传递出去</li><li>LOCAL_OUT 应用程序发出数据包，还没有路由前，这个节点之后会进行路由</li><li>POST_ROUTING 在应用程序，或者 FORWARD 发出的数据包路由之后进入这个节点，这个节点后会将数据包发送出去</li></ul><h2 id="iptables-表和链"><a href="#iptables-表和链" class="headerlink" title="iptables 表和链"></a>iptables 表和链</h2><p>iptables 有”四表五链”来管理数据包的规则和动作</p><ul><li>五链，对应上图中五个橙色的 hooks，<ul><li>PREROUTING 对应 PRE_ROUTING hooks</li><li>INPUT 对应 LOCAL_IN hooks</li><li>FORWARD 对应 FORWARD hooks</li><li>OUTPUT 对应 LOCAL_OUT hooks</li><li>POSTROUTING 对应 POST_ROUTING hooks</li></ul></li><li>四表，将链上的动作按照不同的类别分成了4张表，优先级依次是 Raw-&gt;Mangle-&gt;NAT-&gt;Filter<ul><li>Raw，决定数据包是否被状态跟踪机制处理</li><li>Mangle，用来修改数据包的 TOS、TTL 配置</li><li>NAT，用来修改数据包的 Ip 地址和端口等信息，做网络地址转换（SNAT、DNAT）</li><li>Filter，用来过滤数据包，决定数据包的去留，接受或者拒绝</li></ul></li></ul><h3 id="表和链的关系"><a href="#表和链的关系" class="headerlink" title="表和链的关系"></a>表和链的关系</h3><p>表和链属于多对多的关系，”表中有链，链中有表”</p><table><thead><tr><th></th><th>PREROUTING</th><th>INPUT</th><th>FORWARD</th><th>OUTPUT</th><th>POSTROUTING</th></tr></thead><tbody><tr><td>Raw</td><td>✅</td><td></td><td></td><td>✅</td><td>✅</td></tr><tr><td>Mangle</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Nat</td><td>✅</td><td></td><td></td><td>✅</td><td>✅</td></tr><tr><td>Filter</td><td></td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><p>按链的维度来看，不同的链中包含的表不同，说明每个链的功能不一样，比如 PREROUTING 链只包含 Raw、Mangle、Nat 三个表也就是说只能配置这三个表的动作；<br>按表的维度来看，不同的表中的链不是相同的，也就是说表所配置的动作只能在特定的链上，比如说要做 ip 地址转（即 Nat 表）只可以在 PREROUTING、OUTPUT<br>、POSTROUTING 三 个链上进行；那么数据包在进入网络协议栈的过程就变成了这样（其中 hooks 换成了链）</p><p><img src="/images/iptables2.png" alt="iptables2"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t 表名] COMMAND [要操作的链名] [匹配规则] -j [目标动作]</span><br></pre></td></tr></table></figure><ul><li><p>COMMAND</p><ul><li>-A ：append 新增加一条规则，该规则增加在原本规则的最后面。不显式指定表默认为filter表</li><li>-D ：delete 删除一条规则</li><li>-I ：insert 插入一条规则，如果没有指定顺序默认插入成第一条规则</li><li>-R ：replace 替换一条规则</li><li>-L ：list 查看规则</li></ul></li><li><p>匹配规则</p><ul><li>-p ：指定匹配的协议 tcp、upd、icmp、all</li><li>-s ：指定匹配来源 IP 或者网段</li><li>-d ：指定匹配目的 IP 或者网段</li><li>–sport ：指定匹配源端口 </li><li>–dport ：指定匹配目的端口</li></ul></li><li><p>目标动作 ACCEPT、DROP、REJECT、LOG</p></li></ul><p><a href="https://www.huaweicloud.com/articles/3abf0cf9743f2f582f45e320452596f6.html" target="_blank" rel="noopener">这篇文章</a>最后有些例子可以参考一下</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://xie.infoq.cn/article/b0cfe588251d024d9114c84f3" target="_blank" rel="noopener">https://xie.infoq.cn/article/b0cfe588251d024d9114c84f3</a></li><li><a href="https://cloud.tencent.com/developer/article/1619659" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1619659</a></li><li><a href="https://www.huaweicloud.com/articles/3abf0cf9743f2f582f45e320452596f6.html" target="_blank" rel="noopener">https://www.huaweicloud.com/articles/3abf0cf9743f2f582f45e320452596f6.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;iptables 是 Linux 中经常使用的防火墙，还记得之前部署 Tomcat 服务到一个 web 服务器需要配置新的 iptables
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>hexo 迁移到 hugo 方案-续</title>
    <link href="http://yoursite.com/2021/05/13/hexo%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E6%96%B9%E6%A1%88-%E7%BB%AD/"/>
    <id>http://yoursite.com/2021/05/13/hexo迁移到hugo方案-续/</id>
    <published>2021-05-13T13:16:15.000Z</published>
    <updated>2021-07-13T12:27:08.589Z</updated>
    
    <content type="html"><![CDATA[<p>前面一篇将博客从 hexo 迁移到 hugo 在本地已经跑通了，这篇将跑通的环境打包到云上。</p><h4 id="1-将文件上传到-git-仓库"><a href="#1-将文件上传到-git-仓库" class="headerlink" title="1.将文件上传到 git 仓库"></a>1.将文件上传到 git 仓库</h4><p>这一步可以说是先做个备份，有几个坑点需要注意，我的地址是 <a href="https://github.com/panniyuyu/blog-hugo.git。还有一个原因就是如果没有" target="_blank" rel="noopener">https://github.com/panniyuyu/blog-hugo.git。还有一个原因就是如果没有</a> git<br>执行 hugo server 命令会报错 ERROR 2021/03/05 06:10:33 Failed to read Git log: fatal: not a git repository (or any of the parent directories): .git</p><ul><li>我使用了 LoveIt 的主题，在 /themes 目录下，需要在 git 仓库中关联子模块，不然的话 git push 不会将主题相关的文件 push 上去的</li><li>由于要关联子项目，为了不受后续主题仓库的影响，最好先 fork 到自己仓库中一份，子模块引用自己仓库的就可以了</li></ul><h4 id="2-创建-Dockerfile"><a href="#2-创建-Dockerfile" class="headerlink" title="2.创建 Dockerfile"></a>2.创建 Dockerfile</h4><p>Dockerfile 也很简单了，把大象装冰箱只需要3步，1.找一个 golang 的镜像 2.安装 hugo 3.git clone 第一步上传的文件运行起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.16</span><br><span class="line"></span><br><span class="line">WORKDIR /go/src/</span><br><span class="line"></span><br><span class="line"># install hugo</span><br><span class="line">RUN git clone https://github.com/gohugoio/hugo.git --progress --verbose &amp;&amp; \</span><br><span class="line">    cd hugo &amp;&amp; \</span><br><span class="line">    go install</span><br><span class="line"></span><br><span class="line"># init blog</span><br><span class="line">WORKDIR /usr/local/blog</span><br><span class="line"></span><br><span class="line"># --recursive 包含子模块一起clone</span><br><span class="line">RUN git clone --recursive https://github.com/panniyuyu/blog-hugo.git --progress --verbose</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/local/blog/blog-hugo</span><br><span class="line"></span><br><span class="line">CMD sh run.sh</span><br></pre></td></tr></table></figure><p>附上 run.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">hugo server -p 1313</span><br></pre></td></tr></table></figure><h4 id="3-上云"><a href="#3-上云" class="headerlink" title="3.上云"></a>3.上云</h4><p>这里我使用的阿里云镜像服务，打好的镜像上传上去再到云服务器上拉下来，然后再把第一步中上传到 git 的仓库拉下来做文件映射，最后运行容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di -p 1313:1313 -v /usr/local/blog/blog-hugo:/usr/local/blog/blog-hugo --name=&apos;blog-hugo&apos; blog-hugo:2021-05-10</span><br></pre></td></tr></table></figure><h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><h5 id="坑1-mac-上宿主机和容器见网络不通"><a href="#坑1-mac-上宿主机和容器见网络不通" class="headerlink" title="坑1 mac 上宿主机和容器见网络不通"></a>坑1 mac 上宿主机和容器见网络不通</h5><p>上述步骤完成后，首先再上云之前所有步骤都在本地搞，启动容器之后 curl ${dockerIp}:${port} 是没有反应的，随后进入容器 curl localhost:${port}<br>这是没问题的有HTML页面，所以问题就出在宿主机和容器网络不通，退出容器在 mac 上 ping 容器的 ip 果然是不通的。mac 端的 docker desktop 默认是<br>不使用网桥的，所以默认与容器间网络是不通的 <a href="https://docs.docker.com/docker-for-mac/networking/" target="_blank" rel="noopener">这里</a> 有详细的说明，解决方法自行搜索，<br>我比较懒没有解决，手动狗头</p><h5 id="坑2-hugo-server-参数"><a href="#坑2-hugo-server-参数" class="headerlink" title="坑2 hugo server 参数"></a>坑2 hugo server 参数</h5><p>踩到第一个坑以后，跳过本地部署的阶段，直接上云，在运行容器后 ping 容器 ip 网络是通的，即验证了坑1的问题所在，接着进行 curl ${dockerIp}:${port}<br> 后还是没有响应，进入容器 curl 是正常的，这个坑浪费了很多的时间，其实很简单，就是 hugo server 命令的一个参数指定 hugo 绑定的主机，即默认只有<br>本地才可以访问，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--bind string            interface to which the server will bind (default &quot;127.0.0.1&quot;)</span><br></pre></td></tr></table></figure><h5 id="坑3-nginx"><a href="#坑3-nginx" class="headerlink" title="坑3 nginx"></a>坑3 nginx</h5><p>上面两个坑填完后，之前 hexo 的博客有 Nginx 容器做转发，就计划原有的域名加一个 /hugo 的 path 就可以两个容器都可以用了，还能省下买域名的钱，理<br>想很丰满，也确实达到了 想要的效果，但是，但是，但是，当我看某一篇文章时，url 是会变的呀，且不说两个容器中文章的 url 格式不一样，就算文章的 url<br>配置成一样的，可 Nginx 不知道当前请求是来自 hugo 还是 hexo 怎么转发？或者可以配置公网 ip host 和域名区分，又或者按照有没有 www 前缀来进行转<br>发，这也太挫了，还是老实买个域名通过主机名路由吧。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>这三个坑都填上后 hugo 博客就可以用了，再发新的文章就可以直接上传到 git 上（文章在 content/posts/ 目录，图片在 static/images/ 目录），再在<br>服务器上 git pull 然后 hugo 就热更新了，比 hexo 还需要 docker restart 一下简直太爽了。再展望一下，后续打算 hugo 和 hexo 一起维护，再写文<br>章就先不写头信息，因为两者头的格式不一样，可以新建一个仓库只写 md 文件，push 到仓库后触发一个 pipeline 将 md 文件添加不同格式的头信息，分别更<br>新到各个仓库中（这就是 ci），再触发一个 webhook 访问服务器上一个 http 服务，将更新的 hugo 和 hexo 的 文章下载下来，hexo容器需要重启（这步是<br>cd），这样 cicd 都有了，就做到了全自动，哈哈，后面有时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面一篇将博客从 hexo 迁移到 hugo 在本地已经跑通了，这篇将跑通的环境打包到云上。&lt;/p&gt;
&lt;h4 id=&quot;1-将文件上传到-git-仓库&quot;&gt;&lt;a href=&quot;#1-将文件上传到-git-仓库&quot; class=&quot;headerlink&quot; title=&quot;1.将文件上传到
      
    
    </summary>
    
      <category term="hugo" scheme="http://yoursite.com/categories/hugo/"/>
    
    
      <category term="hugo" scheme="http://yoursite.com/tags/hugo/"/>
    
  </entry>
  
  <entry>
    <title>没有实践就不算入门 Istio</title>
    <link href="http://yoursite.com/2021/05/08/Istio%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2021/05/08/Istio流量管理简单实践/</id>
    <published>2021-05-08T07:28:20.000Z</published>
    <updated>2021-07-13T12:27:08.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>Istio 是如何使用网关进行流量控制的呢？经过两天的实验和研究，有了一个简单的认识，记录一下子</p><p>Istio 作为服务网格的控制面通过一些自定义的 CR，通过对这些 CR 的配置，并对这些 CR 和 k8s 中部分资源 listAndWatch 生成配置并下发（xds协议）<br>到数据面，数据面接收到这些配置实时调整对流量的处理逻辑，这是大致的流程。在原生的 k8s 中，Service 可以通过筛选 label 将应用的多个实例暴露出去提<br>供服务，Service 还可以服务发现和负载均衡，在此基础上 Istio 定义了一些 CR 来扩展 Service 的功能，本文就 Istio 针对 Http 协议的流量 控制进行<br>实践，对 Istio 有一个简单的认识。</p><h3 id="Demo-结构"><a href="#Demo-结构" class="headerlink" title="Demo 结构"></a>Demo 结构</h3><p><img src="/images/istio-1.png" alt="istio-1"></p><p>从右往左看</p><ul><li>通常使用 Deployment 来部署应用的多个实例即业务 Pod，对应图中 business Pod</li><li>创建 Service 将业务 Pod 暴露提供服务，同时可以服务发现和负载均衡</li></ul><p>到这只是使用了 k8s 中的 CR，用户可以通过访问 Service 的 ClusterIp 和端口来访问服务，但是没有更细致的流量控制的功能，下面就开始使用 Istio</p><ul><li>需要创建 VirtualService 和 DestinationRule 来配置流量控制规则</li><li>VirtualService 可以配置不同维度的路由规则将流量传递给指定的 Service</li><li>DestinationRule 可以配置路由规则的不同子集(理解为 k8s Service 中 Endpoint 分组)，以及子集的复制均衡策略，还能配置异常检测</li><li>还可以创建网关来进行流量控制，Istio 默认使用 Envoy 做网关，同样使用 Deployment 部署多个实例，（图中 gateway Pod）创建 Service（图中<br>gateway service）提供服务，Gateway 是 Istio 的 CR 通过筛选 label 关联到创建好的网关，Gateway 规定能够通过网关的流量，并绑定 VisualService<br>和 DestinationRule 的规则</li></ul><p>Istio 通过 ListAndWatch 这些 CR 感知到它们的变化通知给数据面（sidecar 或者 Gateway）</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul><li>首先用 Deployment 部署一个 HttpServer 的 Demo，有两个实例 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP            NODE                  NOMINATED NODE   READINESS GATES</span><br><span class="line">http-sample.default-24tqt   1/1     Running   2          8d    10.0.76.95    op-arsenaldevk8s-03   &lt;none&gt;           1/1</span><br><span class="line">http-sample.default-crkvp   1/1     Running   4          8d    10.0.76.102   op-arsenaldevk8s-07   &lt;none&gt;           1/1</span><br></pre></td></tr></table></figure><ul><li>给 Demo 创建 Service 暴露服务，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NAME                   TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)             AGE</span><br><span class="line">http-sample--default   ClusterIP   10.0.75.60    &lt;none&gt;        8386/TCP            7d19h</span><br></pre></td></tr></table></figure><ul><li>创建 Gateway CR 用来接收所有 host 的请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: Gateway</span><br><span class="line">metadata:</span><br><span class="line">  name: httpsample-gateway</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    istio: ingressgateway # use Istio default gateway implementation 使用 envoy </span><br><span class="line">  servers:</span><br><span class="line">  - port:</span><br><span class="line">      number: 80</span><br><span class="line">      name: http</span><br><span class="line">      protocol: HTTP</span><br><span class="line">    hosts:</span><br><span class="line">    - &quot;*&quot; // 被网关管理 host，这里配置了所有；</span><br></pre></td></tr></table></figure><ul><li>Istio 默认在 istio-system 下创建了网关的 Deployment 和 Service，同样 Service 通过筛选 label 关联 Deployment 的实例 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kubectl get deployment -n istio-system</span><br><span class="line">NAME                   READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">istio-ingressgateway   2/2     2            2           28d</span><br><span class="line"></span><br><span class="line">ubectl get svc -n istio-system</span><br><span class="line">NAME                   TYPE           CLUSTER-IP    EXTERNAL-IP   PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   10.0.75.173   &lt;pending&gt;     15021:31214/TCP,80:30611/TCP,443:32529/TCP,15012:32583/TCP,15443:31725/TCP   28d</span><br></pre></td></tr></table></figure><ul><li>创建 VirtualService 绑定网关</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - httpsample-gateway // 绑定网关，被绑定的网关使用该 VirtualService 配置的规则进行流量控制</span><br><span class="line">  hosts:</span><br><span class="line">  - &apos;*&apos; // 针对某个 host 的应用路由规则，必须包含在被绑定的网关 hosts 范围中，配置成一样的就可以</span><br></pre></td></tr></table></figure><ul><li>创建 DestinationRule 划分两个子集不同版本的子集，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: DestinationRule</span><br><span class="line">spec:</span><br><span class="line">  host: http-sample--default</span><br><span class="line">  subsets: // 通过筛选 label 划分不同的子集，label 是在业务 Pod 的 Service 中 Label Selector 基础上增加版本的标签</span><br><span class="line">  - labels:</span><br><span class="line">      app: http-sample // Service 中筛选标签的条件</span><br><span class="line">      version: v1 // 新增的筛选标签的条件</span><br><span class="line">    name: v1</span><br><span class="line">  - labels:</span><br><span class="line">      app: http-sample</span><br><span class="line">      version: v2</span><br><span class="line">    name: v2</span><br></pre></td></tr></table></figure><p>最后，给 Demo 的两个实例分别打上 version 标签，本文规定10.0.76.95的 IP 是v1，10.0.76.102的 IP 是v2，准备工作完成</p><h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - httpsample-gateway</span><br><span class="line">  hosts:</span><br><span class="line">  - &apos;*&apos;</span><br><span class="line">  http:</span><br><span class="line">  - route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default // 路由的目标 Service，流量会被路由到的 Service</span><br><span class="line">        port:</span><br><span class="line">          number: 8386 // 路由的目标 Service 端口</span><br><span class="line">        subset: v2 // 路由的目标子集，DestinationRule 中定义的子集</span><br><span class="line">        weight: 100 // 流量分配权重</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 访问网关的 Service</span><br><span class="line">curl http://10.0.75.173</span><br><span class="line">// Demo 程序返回时间，host，IP 信息可以看到流量被路由到了 v2 子集上</span><br><span class="line">hello!Sat, 08 May 2021 05:58:10 UTC,host:http-sample.default-crkvp,ip:10.0.76.102</span><br></pre></td></tr></table></figure><h4 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - httpsample-gateway</span><br><span class="line">  hosts:</span><br><span class="line">  - &apos;*&apos;</span><br><span class="line">  http:</span><br><span class="line">  - match:</span><br><span class="line">    - headers: // 匹配请求头 还支持前缀匹配(prefix)和正则匹配(regex)</span><br><span class="line">        userpin:</span><br><span class="line">          exact: jason</span><br><span class="line">    - uri: // 匹配 uri 还支持精确匹配(exact)和正则匹配(regex)</span><br><span class="line">        prefix: /tov1</span><br><span class="line">    route: // match 的请求路由规则</span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br><span class="line">        subset: v1</span><br><span class="line">  - match:</span><br><span class="line">    - headers: // 匹配请求头 还支持前缀匹配(prefix)和正则匹配(regex)</span><br><span class="line">        userpin:</span><br><span class="line">          exact: yywang // 这里如果是 jason 会优先匹配到上条规则</span><br><span class="line">      uri:</span><br><span class="line">        prefix: /tov2</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br><span class="line">        subset: v2</span><br><span class="line">  - route: // 默认路由规则，即上面没有 match 到会直接路由到 http-sample--default 的 Service (Demo 暴露的 Service)上</span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br></pre></td></tr></table></figure><p>match 中的匹配规则，在不同的数组下是或的关系如v1的配置，相同数组下是且的黄兴如v2的配置</p><p>验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 路径匹配</span><br><span class="line">curl http://10.0.75.173/tov1</span><br><span class="line">hello!Sat, 08 May 2021 06:15:25 UTC,host:http-sample.default-24tqt,ip:10.0.76.95</span><br><span class="line">// header 匹配</span><br><span class="line">curl -H &quot;userpin:jason&quot; http://10.0.75.173/</span><br><span class="line">hello!Sat, 08 May 2021 06:15:05 UTC,host:http-sample.default-24tqt,ip:10.0.76.95</span><br><span class="line">// 优先匹配v1</span><br><span class="line">curl -H &apos;userpin:jason&apos;  http://10.0.75.173/tov2</span><br><span class="line">hello!Sat, 08 May 2021 06:19:48 UTC,host:http-sample.default-24tqt,ip:10.0.76.95</span><br><span class="line">// v2是且的关系，最后走了默认路由两个实例随机访问</span><br><span class="line">curl  http://10.0.75.173/tov2</span><br><span class="line">hello!Sat, 08 May 2021 06:19:08 UTC,host:http-sample.default-24tqt,ip:10.0.76.95</span><br><span class="line">curl  http://10.0.75.173/tov2</span><br><span class="line">hello!Sat, 08 May 2021 06:19:09 UTC,host:http-sample.default-24tqt,ip:10.0.76.95</span><br><span class="line">curl  http://10.0.75.173/tov2</span><br><span class="line">hello!Sat, 08 May 2021 06:19:09 UTC,host:http-sample.default-crkvp,ip:10.0.76.102</span><br><span class="line">// 匹配v2</span><br><span class="line">curl -H &apos;userpin:yywang&apos;  http://10.0.75.173/tov2</span><br><span class="line">hello!Sat, 08 May 2021 06:26:17 UTC,host:http-sample.default-crkvp,ip:10.0.76.102</span><br></pre></td></tr></table></figure><h4 id="流量镜像"><a href="#流量镜像" class="headerlink" title="流量镜像"></a>流量镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - httpsample-gateway</span><br><span class="line">  hosts:</span><br><span class="line">  - &apos;*&apos;</span><br><span class="line">  http:</span><br><span class="line">  - match:</span><br><span class="line">    - uri:</span><br><span class="line">        prefix: /tov1</span><br><span class="line">    mirror:</span><br><span class="line">      host: http-sample--default // 流量镜像的目标 Service</span><br><span class="line">      subset: v2 // 流量镜像的目标 子集</span><br><span class="line">    mirror_percent: 100 // 流量镜像的比例</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br><span class="line">        subset: v1</span><br><span class="line">  - match:</span><br><span class="line">      uri:</span><br><span class="line">        prefix: /tov2</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br><span class="line">        subset: v2</span><br><span class="line">  - route: </span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br></pre></td></tr></table></figure><p>验证，curl <a href="http://10.0.75.173/tov1" target="_blank" rel="noopener">http://10.0.75.173/tov1</a> 在v2的 Pod 上查看日志</p><h4 id="CORS-策略"><a href="#CORS-策略" class="headerlink" title="CORS 策略"></a>CORS 策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - httpsample-gateway</span><br><span class="line">  hosts:</span><br><span class="line">  - &apos;*&apos;</span><br><span class="line">  http:</span><br><span class="line">  - route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br><span class="line">        subset: v2</span><br><span class="line">        weight: 100</span><br><span class="line">    corsPolicy:</span><br><span class="line">      allowOrigin:</span><br><span class="line">      - new.com // 允许浏览器跨域访问的地址</span><br><span class="line">      allowMethods:</span><br><span class="line">      - GET // 允许浏览器跨域访问的请求方法</span><br><span class="line">      maxAge: &quot;2m&quot; // 跨域请求缓存的时间</span><br></pre></td></tr></table></figure><p>目前没有遇到这个策略的场景，就没有做验证，据了解 CORS 会给原请求添加头信息，可以查看请求头验证，<a href="https://zhuanlan.zhihu.com/p/264800677" target="_blank" rel="noopener">参考</a></p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - httpsample-gateway</span><br><span class="line">  hosts:</span><br><span class="line">  - &apos;*&apos;</span><br><span class="line">  http:</span><br><span class="line">  - match:</span><br><span class="line">    - uri:</span><br><span class="line">        prefix: /tov1</span><br><span class="line">    redirect:</span><br><span class="line">      uri: /tov2 // 重定向的路径</span><br><span class="line">      authority: 172.16.26.126:8386 // 重定向的主机，不配置就是当前主机，这个是我本地的地址和端口</span><br><span class="line">  - match:</span><br><span class="line">      uri:</span><br><span class="line">        prefix: /tov2</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br><span class="line">        subset: v2</span><br></pre></td></tr></table></figure><p>验证：curl <a href="http://10.0.75.173/tov1" target="_blank" rel="noopener">http://10.0.75.173/tov1</a> 查看本地日志发现被路由到了本地</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>类似于请求转发，浏览器 URL 不会变，由服务器转发新地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - httpsample-gateway</span><br><span class="line">  hosts:</span><br><span class="line">  - &apos;*&apos;</span><br><span class="line">  http:</span><br><span class="line">  - match:</span><br><span class="line">    - uri:</span><br><span class="line">        prefix: /tov1</span><br><span class="line">    rewrite:</span><br><span class="line">      uri: /print // 重写的路径</span><br><span class="line">      authority: 172.16.26.126:8386 // 重写的主机</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br><span class="line">        subset: v1</span><br><span class="line">  - match:</span><br><span class="line">      uri:</span><br><span class="line">        prefix: /tov2</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br><span class="line">        subset: v2</span><br></pre></td></tr></table></figure><p>验证方式同重定向一样，有一点区别的是重写下面还可以配置路由，如果没有配置重写的主机名默认会路由到下面的子集，上面的例子如果没有配置重写的主机会路由<br>到v1的 /print 的 path 上</p><h4 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - httpsample-gateway</span><br><span class="line">  hosts:</span><br><span class="line">  - &apos;*&apos;</span><br><span class="line">  http:</span><br><span class="line">  - route: </span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br><span class="line">    retries:</span><br><span class="line">      attempts: 3 // 重试次数</span><br><span class="line">      perTryTimeout: 2s // 重试超时等待时间</span><br><span class="line">      retryOn: 5xx,connect-failure // 重试条件 5xx 状态码或者连接失败</span><br></pre></td></tr></table></figure><p>验证，Demo 中有一个返回500错误的方法，curl <a href="http://10.0.75.173/error500" target="_blank" rel="noopener">http://10.0.75.173/error500</a> 打开两个 Pod 的实例观察请求的日志，加上重试一共请求4次</p><h4 id="故障注入"><a href="#故障注入" class="headerlink" title="故障注入"></a>故障注入</h4><h5 id="延迟故障"><a href="#延迟故障" class="headerlink" title="延迟故障"></a>延迟故障</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - httpsample-gateway</span><br><span class="line">  hosts:</span><br><span class="line">  - &apos;*&apos;</span><br><span class="line">  http:</span><br><span class="line">  - fault:</span><br><span class="line">      delay: // 注入延迟故障</span><br><span class="line">        percentage:</span><br><span class="line">          value: 10 // 注入百分比</span><br><span class="line">        fixedDelay: 5s // 延迟时间</span><br><span class="line">  - route: </span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br></pre></td></tr></table></figure><h5 id="错误故障"><a href="#错误故障" class="headerlink" title="错误故障"></a>错误故障</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: VirtualService</span><br><span class="line">spec:</span><br><span class="line">  gateways:</span><br><span class="line">  - httpsample-gateway</span><br><span class="line">  hosts:</span><br><span class="line">  - &apos;*&apos;</span><br><span class="line">  http:</span><br><span class="line">  - fault:</span><br><span class="line">      abort: // 错误故障</span><br><span class="line">        percentage:</span><br><span class="line">          value: 10 // 注入百分比 </span><br><span class="line">        httpStatus: 500 // 响应状态码</span><br><span class="line">  - route: </span><br><span class="line">    - destination:</span><br><span class="line">        host: http-sample--default</span><br><span class="line">        port:</span><br><span class="line">          number: 8386</span><br></pre></td></tr></table></figure><p>curl <a href="http://10.0.75.173" target="_blank" rel="noopener">http://10.0.75.173</a> 即可验证</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>Istio 除了 Service 本身带有的负载均衡，在 DestinationRule 中可以配置子集的负载均衡，支持更多算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: DestinationRule</span><br><span class="line">spec:</span><br><span class="line">  host: http-sample--default</span><br><span class="line">  subsets:</span><br><span class="line">  - labels:</span><br><span class="line">      version: v1</span><br><span class="line">      app: http-sample</span><br><span class="line">    name: v1</span><br><span class="line">    trafficPolicy:</span><br><span class="line">      lodaBalancer: // 负载均衡配置</span><br><span class="line">        simple: ROUND_ROBIN // 轮询负载均衡算法，还支持随机算法(RANDOM)，最少连接(LEAST_CONN)，直接转发(PASSTHROUTE)</span><br></pre></td></tr></table></figure><h4 id="异常检测-熔断限流"><a href="#异常检测-熔断限流" class="headerlink" title="异常检测 - 熔断限流"></a>异常检测 - 熔断限流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: networking.istio.io/v1beta1</span><br><span class="line">kind: DestinationRule</span><br><span class="line">spec:</span><br><span class="line">  host: http-sample--default</span><br><span class="line">  subsets:</span><br><span class="line">  - labels:</span><br><span class="line">      version: v1</span><br><span class="line">      app: http-sample</span><br><span class="line">    name: v1</span><br><span class="line">  - labels:</span><br><span class="line">      version: v2</span><br><span class="line">      app: http-sample</span><br><span class="line">    name: v2</span><br><span class="line">  trafficPolicy:</span><br><span class="line">    connectionPool:</span><br><span class="line">      http:</span><br><span class="line">        http1MaxPendingRequests: 1 // 最大请求等待数</span><br><span class="line">        maxRequestsPerConnection: 1 // 每个连接最大请求数</span><br><span class="line">      tcp:</span><br><span class="line">        macConnections: 1 // 最大连接数</span><br><span class="line">    outlierDetection:</span><br><span class="line">      baseEjectionTime: 100s // 基础熔断时间，实际时间是 = 基础熔断时间 x 熔断次数</span><br><span class="line">      consecutiveErrors: 1 // 触发熔断的连续错误次数</span><br><span class="line">      maxEjectionPercent: 100 // 熔断实例的比例，100%即为所有实例都可以同时熔断</span><br></pre></td></tr></table></figure><p>验证，这里通过 fortio 验证了限流，再高于5个连接并发的情况下会有部分请求失败被限流，熔断还还不知道怎么验证，感觉应该没问题后面验证了再补充上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fortio load -c 5 -qps 0 -n 100 -loglevel Warning http://10.0.75.173</span><br><span class="line">17:45:28 I logger.go:127&gt; Log level is now 3 Warning (was 2 Info)</span><br><span class="line">Fortio 1.14.1 running at 0 queries per second, 8-&gt;8 procs, for 100 calls: http://10.0.75.173</span><br><span class="line">Starting at max qps with 5 thread(s) [gomax 8] for exactly 100 calls (20 per thread + 0)</span><br><span class="line">17:45:28 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:28 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:28 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:28 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:28 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:28 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:28 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:28 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:28 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:28 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:28 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:29 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:29 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:29 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:29 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:29 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:29 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">17:45:29 W http_client.go:781&gt; Parsed non ok code 503 (HTTP/1.1 503)</span><br><span class="line">Ended after 181.75592ms : 100 calls. qps=550.19</span><br><span class="line">Aggregated Function Time : count 100 avg 0.0084987707 +/- 0.003829 min 0.003318402 max 0.01871654 sum 0.849877069</span><br><span class="line"># range, mid point, percentile, count</span><br><span class="line">&gt;= 0.0033184 &lt;= 0.004 , 0.0036592 , 8.00, 8</span><br><span class="line">&gt; 0.004 &lt;= 0.005 , 0.0045 , 15.00, 7</span><br><span class="line">&gt; 0.005 &lt;= 0.006 , 0.0055 , 26.00, 11</span><br><span class="line">&gt; 0.006 &lt;= 0.007 , 0.0065 , 44.00, 18</span><br><span class="line">&gt; 0.007 &lt;= 0.008 , 0.0075 , 58.00, 14</span><br><span class="line">&gt; 0.008 &lt;= 0.009 , 0.0085 , 64.00, 6</span><br><span class="line">&gt; 0.009 &lt;= 0.01 , 0.0095 , 73.00, 9</span><br><span class="line">&gt; 0.01 &lt;= 0.011 , 0.0105 , 75.00, 2</span><br><span class="line">&gt; 0.011 &lt;= 0.012 , 0.0115 , 80.00, 5</span><br><span class="line">&gt; 0.012 &lt;= 0.014 , 0.013 , 88.00, 8</span><br><span class="line">&gt; 0.014 &lt;= 0.016 , 0.015 , 94.00, 6</span><br><span class="line">&gt; 0.016 &lt;= 0.018 , 0.017 , 98.00, 4</span><br><span class="line">&gt; 0.018 &lt;= 0.0187165 , 0.0183583 , 100.00, 2</span><br><span class="line"># target 50% 0.00742857</span><br><span class="line"># target 75% 0.011</span><br><span class="line"># target 90% 0.0146667</span><br><span class="line"># target 99% 0.0183583</span><br><span class="line"># target 99.9% 0.0186807</span><br><span class="line">Sockets used: 23 (for perfect keepalive, would be 5)</span><br><span class="line">Jitter: false</span><br><span class="line">Code 200 : 82 (82.0 %)</span><br><span class="line">Code 503 : 18 (18.0 %)</span><br><span class="line">Response Header Sizes : count 100 avg 141.04 +/- 66.08 min 0 max 172 sum 14104</span><br><span class="line">Response Body/Total Sizes : count 100 avg 252.32 +/- 2.533 min 247 max 254 sum 25232</span><br><span class="line">All done 100 calls (plus 0 warmup) 8.499 ms avg, 550.2 qps</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;Istio 是如何使用网关进行流量控制的呢？经过两天的实验和研究，有了一个简单的认识，记录一下子&lt;/p&gt;
&lt;p&gt;Istio 作为服务网格的控
      
    
    </summary>
    
    
      <category term="Istio" scheme="http://yoursite.com/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>hexo 迁移到 hugo 方案</title>
    <link href="http://yoursite.com/2021/03/04/hexo%E8%BF%81%E7%A7%BB%E5%88%B0hugo%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2021/03/04/hexo迁移到hugo方案/</id>
    <published>2021-03-04T07:02:29.000Z</published>
    <updated>2021-07-13T12:27:08.589Z</updated>
    
    <content type="html"><![CDATA[<p>云原生第一步首先要拥抱 go 语言，go 语言第一步首先从迁移博客开始，hugo 是用 golang 实现的静态博客生成工具，给我最大的吸引力是生成静态资源的速度很快，并且是热更新，就是说我修改了文章后不需要重启 hugo 就可以更新博客的状态，这简直太爽了</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">brew install hugo</span><br><span class="line">#</span><br><span class="line">Error: hugo: no bottle available!</span><br><span class="line">You can try to install from source with:</span><br><span class="line">  brew install --build-from-source hugo</span><br><span class="line">Please note building from source is unsupported. You will encounter build</span><br><span class="line">failures with some formulae. If you experience any issues please create pull</span><br><span class="line">requests instead of asking for help on Homebrew&apos;s GitHub, Twitter or any other</span><br><span class="line">official channels.</span><br><span class="line"># 按照提示重新安装</span><br><span class="line">brew install --build-from-source hugo</span><br><span class="line"># 验证</span><br><span class="line">hugo version </span><br><span class="line"># 成功</span><br><span class="line">Hugo Static Site Generator v0.80.0/extended darwin/amd64 BuildDate: unknown</span><br></pre></td></tr></table></figure><h4 id="创建一个网站"><a href="#创建一个网站" class="headerlink" title="创建一个网站"></a>创建一个网站</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo new site blog-hugo</span><br></pre></td></tr></table></figure><p>会在hugo目录下创建一个 blog-hugo 的文件夹，目录结构为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── archetypes</span><br><span class="line">│   └── default.md</span><br><span class="line">├── config.toml</span><br><span class="line">├── content</span><br><span class="line">├── data</span><br><span class="line">├── layouts</span><br><span class="line">├── static</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><h4 id="添加主题"><a href="#添加主题" class="headerlink" title="添加主题"></a>添加主题</h4><p>我选用LoveIt的主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd blog-hugo/themes/</span><br><span class="line">git clone https://github.com/dillonzq/LoveIt.git</span><br><span class="line"># 复制 exampleSite 中的文件到 blog-hugo 目录下</span><br><span class="line">cp -rf LoveIt/exampleSite/ ../../</span><br><span class="line"># 修改主题位置</span><br><span class="line">vim config.toml</span><br><span class="line"># 修改 themesDir = &quot;themes/&quot;</span><br><span class="line"># 启动 必须要在创建的 Site 目录下，否有要 -s=xxx 指定目录</span><br><span class="line">hugo server</span><br></pre></td></tr></table></figure><p><strong>踩坑! 如果提示保持 too many request from balabala … 需要在config.toml中添加配置 ignoreErrors = [“error-remote-getjson”]</strong></p><h4 id="迁移博客"><a href="#迁移博客" class="headerlink" title="迁移博客"></a>迁移博客</h4><ol><li>头信息修改，hexo中的头信息我是这样写的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: 2020 又是起起落落落落的一年 </span><br><span class="line">author: YyWang </span><br><span class="line">tags: 生活杂谈 </span><br><span class="line">categories: 生活杂谈</span><br><span class="line">date: 2021-02-08 17:57:12</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>hugo 中头信息为这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 2020 又是起起落落落落的一年</span><br><span class="line">author: YyWang</span><br><span class="line">authorLink: http://www.yywang.top #新增</span><br><span class="line">date: 2021-02-08T17:57:12+08:00 #修改格式</span><br><span class="line">lastmod: 2021-02-08T17:57:12+08:00 #新增</span><br><span class="line">draft: false #新增</span><br><span class="line">tags: [&quot;生活杂谈&quot;] #修改格式</span><br><span class="line">categories: [&quot;生活杂谈&quot;] #修改格式</span><br><span class="line">featuredImagePreview: #新增</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>当然是写代码修改啦，因为hexo中的文章都没以 — 开头，所以我就统一这个格式处理了，(刚学golang写的很糙😬)，处理代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bufio&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;path/filepath&quot;</span><br><span class="line">&quot;strings&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">// 获取文件夹中所有文件</span><br><span class="line">pathPrefix := &quot;$&#123;pathPrefix&#125;&quot;</span><br><span class="line">files := getAllFiles(pathPrefix)</span><br><span class="line">for _,f := range files &#123;</span><br><span class="line">// 先读文件，在写文件</span><br><span class="line">err := writeFile(f, readFile(f))</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;write error %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func readFile(filepath string) []byte&#123;</span><br><span class="line">file, _ := os.OpenFile(filepath, os.O_RDONLY, 0644)</span><br><span class="line">defer file.Close()</span><br><span class="line"></span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line">buffer := make([]byte, 0)</span><br><span class="line"></span><br><span class="line">var title, author, tags, categories, date string</span><br><span class="line"></span><br><span class="line">appendFlag := false</span><br><span class="line">for &#123;</span><br><span class="line">line, _, err := reader.ReadLine()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">if err == io.EOF &#123;</span><br><span class="line">appendPre := make([]byte, 0)</span><br><span class="line">appendPre = append(appendPre, &quot;---\n&quot;...)</span><br><span class="line">appendPre = append(appendPre, &quot;title: &quot; + title +&quot;\n&quot;...)</span><br><span class="line">appendPre = append(appendPre, &quot;author: &quot; + author +&quot;\n&quot;...)</span><br><span class="line">appendPre = append(appendPre, &quot;authorLink: http://www.yywang.top\n&quot;...)</span><br><span class="line">appendPre = append(appendPre, &quot;date: &quot; + date +&quot;\n&quot;...)</span><br><span class="line">appendPre = append(appendPre, &quot;lastmod: &quot; + date +&quot;\n&quot;...)</span><br><span class="line">appendPre = append(appendPre, &quot;draft: false\n&quot;...)</span><br><span class="line">appendPre = append(appendPre, &quot;tags: [\&quot;&quot;+tags+&quot;\&quot;]\n&quot;...)</span><br><span class="line">appendPre = append(appendPre, &quot;categories: [\&quot;&quot;+categories+&quot;\&quot;]\n&quot;...)</span><br><span class="line">appendPre = append(appendPre, &quot;featuredImagePreview: \n&quot;...)</span><br><span class="line">appendPre = append(appendPre, &quot;---\n&quot;...)</span><br><span class="line">return  append(appendPre, buffer...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">lineStr := string(line[:])</span><br><span class="line">if strings.EqualFold(lineStr, &quot;---&quot;) &#123;</span><br><span class="line">appendFlag = true</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if appendFlag &#123;</span><br><span class="line">// copy</span><br><span class="line">buffer = append(buffer, line...)</span><br><span class="line">buffer = append(buffer, &quot;\n&quot;...)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">i := strings.Index(lineStr, &quot;:&quot;)</span><br><span class="line">if i &gt; 0 &#123;</span><br><span class="line">k := lineStr[0:i]</span><br><span class="line">v := strings.TrimSpace(lineStr[i+1:])</span><br><span class="line">switch k &#123;</span><br><span class="line">case &quot;title&quot;:</span><br><span class="line">title = v</span><br><span class="line">case &quot;author&quot;:</span><br><span class="line">author = v</span><br><span class="line">case &quot;tags&quot;:</span><br><span class="line">tags = v</span><br><span class="line">case &quot;categories&quot;:</span><br><span class="line">categories = v</span><br><span class="line">case &quot;date&quot;:</span><br><span class="line">date = transDataFormat(v, &quot;2006-01-02 15:04:05&quot;, &quot;2006-01-02T15:04:05+08:00&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;error switch &quot; + k)</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;split error &quot; + lineStr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getAllFiles(path string) []string &#123;</span><br><span class="line">files := make([]string, 0)</span><br><span class="line">err := filepath.Walk(path, func(path string, f os.FileInfo, err error) error&#123;</span><br><span class="line">if f.IsDir() &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">files = append(files, path)</span><br><span class="line">return  nil</span><br><span class="line">&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;walk file path err info is %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">return files</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func transDataFormat(timeStr string, oldFormat string, newFormat string) string &#123;</span><br><span class="line">date, _ := time.Parse(oldFormat, timeStr)</span><br><span class="line">return date.Format(newFormat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func writeFile(filePath string, content []byte) error &#123;</span><br><span class="line">f, err := os.OpenFile(filePath, os.O_WRONLY|os.O_TRUNC, 0600)</span><br><span class="line">defer f.Close()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">writer := bufio.NewWriter(f)</span><br><span class="line">_, err = writer.Write(content)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">err = writer.Flush()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;flush error %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将新修改的文件移动到 blog-hugo/content/posts/ 目录下</p><ol start="2"><li>将文章中引用的图片移动到 blog-hugo/assets/images/ 目录下</li><li>如果在文章中还引用过其他文章，url会失效，手动修改下或者参考<a href="https://liujiacai.net/blog/2020/12/05/hexo-to-hugo/" target="_blank" rel="noopener">这里，查看文件链接</a>处理</li></ol><p><strong>到这里博客基本上迁移完毕了，附一个初步的效果图，后面还需进一步美化和优化，等上线了再切负载替换hexo</strong></p><p><img src="/images/hugodemo.png" alt="hugodemodemo"></p><h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><ul><li>打包docker镜像，以docker的方式部署，nginx切换负载</li><li>备份hugo博客的方案</li><li>参考<a href="https://lewky.cn/tags/hugo/" target="_blank" rel="noopener">这里</a>做增强</li><li>换一套头像，大图小图啥的，参考主题中exampleSite里的post介绍，<a href="https://realfavicongenerator.net/" target="_blank" rel="noopener">这个网站生成套图</a></li><li>更换评论系统插件<a href="https://waline.js.org/" target="_blank" rel="noopener">waline</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;云原生第一步首先要拥抱 go 语言，go 语言第一步首先从迁移博客开始，hugo 是用 golang 实现的静态博客生成工具，给我最大的吸引力是生成静态资源的速度很快，并且是热更新，就是说我修改了文章后不需要重启 hugo 就可以更新博客的状态，这简直太爽了&lt;/p&gt;
&lt;h4
      
    
    </summary>
    
      <category term="hugo" scheme="http://yoursite.com/categories/hugo/"/>
    
    
      <category term="hugo" scheme="http://yoursite.com/tags/hugo/"/>
    
  </entry>
  
  <entry>
    <title>2020 又是起起落落落落的一年</title>
    <link href="http://yoursite.com/2021/02/08/2020%20%E5%8F%88%E6%98%AF%E8%B5%B7%E8%B5%B7%E8%90%BD%E8%90%BD%E8%90%BD%E8%90%BD%E7%9A%84%E4%B8%80%E5%B9%B4/"/>
    <id>http://yoursite.com/2021/02/08/2020 又是起起落落落落的一年/</id>
    <published>2021-02-08T09:57:12.000Z</published>
    <updated>2021-07-13T12:27:08.580Z</updated>
    
    <content type="html"><![CDATA[<p>2021年已经过去了39天，上一年的总结赶紧补上，先盘点下之前立过的Flag，然后写一下自己的心路历程吧</p><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><p>还记得19年写总结的时候立下了的Flag，一一盘点一下子</p><h5 id="每月平均两篇博客的更新"><a href="#每月平均两篇博客的更新" class="headerlink" title="每月平均两篇博客的更新"></a>每月平均两篇博客的更新</h5><p>  截止到最后一篇文章11月17日一共有20篇，离24篇还差点意思，完成率83%吧，怎么硕呢~ 看数据的话可就是没完成，但是，其中有4个月的时间因为一些事情没有写文章更新，可以算是及格吧</p><h5 id="博客填坑"><a href="#博客填坑" class="headerlink" title="博客填坑"></a>博客填坑</h5><p>  当时计划要学习：spring/spring boot、WAL、设计模式、netty这些，并写文章出来，学习是学了文章没写，没啥好说的妥妥没完成</p><h5 id="部门业务深入"><a href="#部门业务深入" class="headerlink" title="部门业务深入"></a>部门业务深入</h5><p>  Flag是部门业务吃透，这里话太满了我撤回，吃透算不上应该说得上是深入了解，本来计划是每天看一点点不紧不慢的节奏，后来有人离职我代替他值班，驱动我不得不加快学习速度，感觉已经完全适应工作状态了，另外下一代微服务也学习了，本来计划了解一些能吹牛逼就行，后来发现这个还挺有意思的也就多看了看，意外收获，哈哈，这个是超额完成</p><h5 id="一次5天以上的旅行"><a href="#一次5天以上的旅行" class="headerlink" title="一次5天以上的旅行"></a>一次5天以上的旅行</h5><p>  因为疫情上半年的假期基本都是在北京度过，国庆的时候去上海玩了4天，心疼机票钱选择国庆后出门🤣，这项也算完成了吧</p><p>  综合来看，Flag完成情况可以说是及格吧，毕竟计划往往是赶不上变化的，心里记着目标努力去完成就好，Flag也设定的稍微大一些，反正最后肯定完不成，结果肯定会比低预期的Flag要好很多~</p><h3 id="小算盘"><a href="#小算盘" class="headerlink" title="小算盘"></a>小算盘</h3><p>  从参加工作以来，工作内容一直都是后台系统的优化和维护，申请不到前端资源甚至连前端页面也写，更像一个全栈。这个工作内容和读研时期一模一样，而且工作氛围有些封闭感觉我更像外包一样，道理我都懂，这些活总要有人来做，我是新人当然是我来做，等再有新人来我不就解放了嘛，就这样我打起了自己的小算盘😬，可后面要做些什么我不知道，我就看身边的大佬搞什么就想办法往那边去靠，厚着脸皮跟着大佬去做一个operator的项目，也就从这开始我接触到了k8s和云原生发现这真是一个神奇的东西</p><h3 id="打杂的？"><a href="#打杂的？" class="headerlink" title="打杂的？"></a>打杂的？</h3><p>  就在快有新人来之前，我的计划也按部就班的来，找老板提出我的想法去做云原生的项目或者SDK，不料被驳回了，理由是这两个项目都不缺人，然后安排我做另外一个项目，希望破灭，在新的项目里倒是不用写前端了，可还是一个 API Boy 在我看来工作内容都是一样的，没有好的机会就做吧还能咋的。后来，晋升答辩T2-&gt;T3，以往都不需要答辩今年不知怎么了，我汇报了一年的工作，台下一个评委说感觉你像打杂的，结果没过，心想我一个T2不打杂干什么，让我做T10的活吗？</p><h3 id="打杂的！"><a href="#打杂的！" class="headerlink" title="打杂的！"></a>打杂的！</h3><p>  我为自己感到不公，便开始找新的机会，期间边看机会边准备也就空出3个月没有更新文章，原因在这🤣，起初还是按照基础架构这个方向去找，毕竟做了有1年的时间想在这个方向多深入一些，刚开始还是一直碰壁，简历不过的，理解深度不够的，自己暴露的问题有很多，因为我说想做一些更有挑战性的工作，被灵魂拷问你想做什么的时候，我脑子一片空白，只是有想法但做什么却不知道，这算什么，投递简历很多都是不过的，简历过了面试的问题也答不好，我这一年到底干了什么？结论：我这一年光打杂了，就是一个打杂的！</p><h3 id="自省"><a href="#自省" class="headerlink" title="自省"></a>自省</h3><p>  自我反省一下，自己确实是个打杂的，工作内容没有亮点，首先我要明确自己想做什么，业务还是基础架构？业务接触的技术广，机会多，好的业务往往绩效也好，相应的压力会大一些；基础架构方向有技术的深度，绩效往往一般；相比之下我更喜欢基础架构多一些，更喜欢偏研究类型的工作，经过面试看下来基础架构往往需求工作经验丰富的人，我打杂一年希望渺茫；我选择先找业务方向工作一段时间再入坑基础架构，这样希望大些，随后我投递了业务方向的岗位，最终拿到了美团的offer，当时已经进入第4季度加上我年限少涨幅也没有到预期，决定年底再看，这个阶段我明确了我想要什么，有了短期的规划</p><h3 id="前行"><a href="#前行" class="headerlink" title="前行"></a>前行</h3><p>  有了规划开始按部就班的走，工作之余每天抽出时间刷题、学习给自己充电，计划是过完年再开始找机会，到了12月几乎每天都有5个猎头或者hr要简历，感觉需求量很大，随之调整计划，填鸭式的学习，打算在年前把这事搞定，这一个月我也没更新文章😬，从元旦后开始投递简历，有了充分的准备，这次结果还不错，收到了3家offer，其他的5家也都通过3面，还有一家是我主动放弃的，这结果我还是很欣慰的，其中拒了百度（感觉没有诚意），拒了阿里（纠结了很久），最终选择一个规模不大的独角兽，做云原生基础架构（不忘初心吧）</p><h3 id="云原生-GO-GO-GO"><a href="#云原生-GO-GO-GO" class="headerlink" title="云原生 GO GO GO"></a>云原生 GO GO GO</h3><p>   自己也没想到会有选offer的一天，本来幻想着去快手挣快钱，二面一个半小时3道算法题也都做了，莫名其妙的就挂了，墨菲定律，越是想去的地方越没有机会，越是不在意的地方往往会有惊喜，比如阿里和蚂蚁，业务都还不错本来想试试可没想到都过了还🤣，玄学，最后打算选做云原生，转Go语言，选择初心，希望这次不要选错，我可是拒了阿里</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>  这一年最大的收获就是知道自己想要什么了，未来的路也逐渐清晰，面试过程中听到最多的话就是你还年轻，路还很长，毕竟工作不久，也算是一点点优势吧。最后，该开始新一年的Flag了</p><ul><li>博客不能断，一年不能少于20篇吧</li><li>Go语言、k8s、Istio、Mosn都整明白了，最起码能独立解决问题吧</li><li>买了相机不能吃灰吧，整两篇文章看下成功</li><li>旅行不能少哦，读万卷书行万里路</li><li>参与开源项目或者社区（终极目标😬）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2021年已经过去了39天，上一年的总结赶紧补上，先盘点下之前立过的Flag，然后写一下自己的心路历程吧&lt;/p&gt;
&lt;h3 id=&quot;Flag&quot;&gt;&lt;a href=&quot;#Flag&quot; class=&quot;headerlink&quot; title=&quot;Flag&quot;&gt;&lt;/a&gt;Flag&lt;/h3&gt;&lt;p&gt;还记
      
    
    </summary>
    
      <category term="生活杂谈" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="生活杂谈" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>一次MySQL死锁的踩坑记录</title>
    <link href="http://yoursite.com/2020/11/17/%E4%B8%80%E6%AC%A1MySQL%E6%AD%BB%E9%94%81%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/11/17/一次MySQL死锁的踩坑记录/</id>
    <published>2020-11-17T06:23:43.000Z</published>
    <updated>2021-07-13T12:27:08.591Z</updated>
    
    <content type="html"><![CDATA[<p>我又写bug了，O(∩_∩)O哈哈~，这次是MySQL数据库的死锁，真实太菜了🤷‍♀️(日常一菜)</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>我在实现一个接口，使用动态配置中心的API，创建配置并发布，因为要保证接口的幂等性，我为了方便每次将配置删除并重新创建再发布，相较于先查询所有的配置，判断当前配置不存在后再创建的方法，我觉着会多了判断的逻辑消耗，所以采用了第一种方式： 调用删除配置的api接口清空历史数据 -&gt; 创建新的配置 -&gt; 发布新的配置</li><li>接下来介绍一下动态配置中心的背景，创建的配置保存在config_item表中，发布的配置将config_item表中的数据插入到config_item_release表中，两个表的结构是一样的，主要信息粘一下，发布配置是以profile维度(就理解为配置的路径)，所以会有profile_id+key的唯一索引；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config_item和config_item_release</span><br><span class="line">(</span><br><span class="line">  id bigint not null comment &apos;主键id&apos; primary key,</span><br><span class="line">  profile_id bigint not null comment &apos;profile id&apos;,</span><br><span class="line">  `key` varchar(200) not null comment &apos;配置项key&apos;,</span><br><span class="line">  value varchar(6144) not null comment &apos;配置项value&apos;,</span><br><span class="line">  constraint uniq_profile_key</span><br><span class="line">    unique (profile_id, `key`)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>这样经过测试是没有问题的，后面我的操作就写了bug，我在测试的过程中发现接口比较慢，想优化一下速度，发现接口的操作都是串行的，我创建并发布的配置比较多，所以马上就会想到改为多线程，再联想到插入config_item_release表是以profileId维度，不同profile是相互隔离的，脑补了一下没问题就开干了</li><li>多线程版本后，运行几次后只有很小的概率会成功，这就踩到坑了</li></ul><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>首先要看日志，具体日志找不到了，主要是有下面这么一行，deadlock关键字可以定位到问题了，简单思考一下，数据库的并发操作都是不同的数据行，没有并发对统一数据的写操作，下面就开始科学排查了（Google）</p><p><strong><em>### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction</em></strong></p><p>首先要找到MySQL死锁的日志，都说用这个SQL <em>SHOW ENGINE INNODB STATUS</em> 可以看；我怎么搞都不行，最后是用 <em>select @@log_error</em> 找到MySQL错误日志的位置，再通过命令行去看的，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">-- 这行可以定位到头发越来越少的原因了😹</span><br><span class="line">2020-11-12 03:04:06 0x70000fccb000</span><br><span class="line">-- 第一个事务</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">-- 事务id=69581 正在执行插入语句</span><br><span class="line">TRANSACTION 69581, ACTIVE 0 sec inserting</span><br><span class="line">-- 使用到了两张表，加锁了两张表</span><br><span class="line">mysql tables in use 2, locked 2</span><br><span class="line">-- 事务处于LOCK WAIT状态，有6种锁结构 其中4个行锁</span><br><span class="line">LOCK WAIT 6 lock struct(s), heap size 1136, 4 row lock(s), undo log entries 1</span><br><span class="line">-- 线程信息</span><br><span class="line">MySQL thread id 627, OS thread handle 123145568219136, query id 21548 localhost 127.0.0.1 root Sending data</span><br><span class="line">-- 事务发生阻塞的SQL语句</span><br><span class="line">INSERT INTO config_item_release</span><br><span class="line">        SELECT * FROM config_item c WHERE c.profile_id=8720</span><br><span class="line">-- 等待获取的锁</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">-- 等待获取唯一索引insert intention锁 细节1</span><br><span class="line">RECORD LOCKS space id 1112 page no 1955 n bits 376 index uniq_profile_key of table `my_table`.`config_item_release` trx id 69581 lock_mode X insert intention waiting</span><br><span class="line">-- 该记录的信息</span><br><span class="line">Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</span><br><span class="line">-- supremum 细节2</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">-- 第二个事务</span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 69580, ACTIVE 0 sec inserting</span><br><span class="line">mysql tables in use 2, locked 2</span><br><span class="line">6 lock struct(s), heap size 1136, 4 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 626, OS thread handle 123145567383552, query id 21549 localhost 127.0.0.1 root Sending data</span><br><span class="line">INSERT INTO config_item_release</span><br><span class="line">        SELECT * FROM config_item c WHERE c.profile_id=8721</span><br><span class="line">-- 当前获取到锁的信息</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">-- 当前获取到的时唯一索引的X锁 细节3</span><br><span class="line">RECORD LOCKS space id 1112 page no 1955 n bits 376 index uniq_profile_key of table `my_table`.`config_item_release` trx id 69580 lock_mode X</span><br><span class="line">Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">-- 事务等待获取的锁</span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">-- 等待获取唯一索引insert intention锁 细节4</span><br><span class="line">RECORD LOCKS space id 1112 page no 1955 n bits 376 index uniq_profile_key of table `laf_config`.`config_item_release` trx id 69580 lock_mode X insert intention waiting</span><br><span class="line">Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">-- 回滚了事务2</span><br><span class="line">*** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure><p>在这段日志中，忽略了几个细节导致在排查问题的时候走了很多的弯路</p><ul><li>事务在等待的锁是Insert Intention锁，这个锁是间隙锁的一种，容易被忽略掉，刚开始的我还以为是insert操作在等待X锁导致排查的方向就做了</li><li>supremum 代表无穷大，这里也能够猜想到等待锁的时一个区间是(8720,+∞)的间隙锁，这个细节也被我忽略掉了，注意力完全被 lock model X 吸引走了</li><li>事务2当前获取到的锁是唯一索引的X锁，与事务1等待的锁是不一样的，还是对Insert Intention锁不了解导致这个细节忽略掉了</li><li>事务2等待的锁和事务1等待的锁是相同的，应该是互相等待对方释放形成了闭环所以才会发生死锁，死锁的基本概念都忘了，感觉自己像做梦一样🤷‍♀️</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>从死锁的定义来看，多个事物要获取的资源形成了闭环，结合日志来看两个事务都在insert操作时阻塞，等待相同位置资源锁，并且被对方限制</li><li>在从日志来看事务1并没有获取到任何的锁，事务2获得的是唯一索引的记录锁，看不出来有什么资源被互相限制；大胆猜想一下，这里一定存在事务已经获取到的锁但是没有在日志中体现出来</li><li>从日志中被阻塞到的insert操作和Insert Intention关键字入手查找资料发现了惊人的东西，我的知识体系中存在这巨大漏洞，下面就是被忽略的细节<ul><li>在insert操作之前会有Insert Intention锁(插入意向锁)是间隙锁的一种，从日志来看加锁的间隙为(max,+∞)</li><li>Insert Intention锁之间只要插入的数据不是同一个数据是不会冲突的</li><li>间隙锁和Insert Intention锁之间也会有互斥的关系，已经存在了G锁(间隙锁)是不能在加I锁(插入意向锁)，相反已经存在I锁是可以再加G锁的</li><li>两个G锁直接是相互兼容的</li></ul></li><li>在补充了这些知识盲区后，真相浮出水面，两个事务都先加了范围是的G锁，下一步都要执行insert操作，insert之前都要加I锁，I锁都被对方事务事先加号的G锁阻塞，形成了闭环，发生死锁</li><li>结合业务逻辑来看<ul><li>第一步删除历史数据清空了config_item_release表的数据</li><li>第二步更新配置，在config_item表中update操作</li><li>第三步发布配置，这个api的逻辑是先删除config_item_release中的记录，在将config_item表中的数据插入进来</li><li>问题就出现在第一步清空了config_item_release表的数据后该表中是没有数据的，第三步先delete操作这时候两个事务会加区间为(max,+∞)的G锁，然后insert操作前会在这个区间加I锁，都被对方的G锁排斥形成死锁，</li></ul></li><li>那么如果是这个问题，在config_item_release表中存在数据时，不同事务delete加G锁的区间不同在加I锁就不会被阻塞就可以避免死锁了(delete操作的加锁过程见参考文章)</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>这里通过两个实验来验证上面的分析结果</p><h4 id="实验一：config-item-release不存在数据，两个事务先delete后insert会发生死锁"><a href="#实验一：config-item-release不存在数据，两个事务先delete后insert会发生死锁" class="headerlink" title="实验一：config_item_release不存在数据，两个事务先delete后insert会发生死锁"></a>实验一：config_item_release不存在数据，两个事务先delete后insert会发生死锁</h4><table><thead><tr><th>事务1</th><th>事务2</th><th>结果</th><th>分析</th></tr></thead><tbody><tr><td>begain</td><td></td><td></td><td></td></tr><tr><td></td><td>begain</td><td></td><td></td><td></td></tr><tr><td>DELETE FROM config_item_release WHERE profile_id=9118</td><td></td><td>Affected rows: 0, Time: 0.002000s</td><td>事务1对(max,+∞)区间加G锁</td></tr><tr><td></td><td>DELETE FROM config_item_release WHERE profile_id=9112</td><td>Affected rows: 0, Time: 0.002000s</td><td>事务2对(max,+∞)区间加G锁</td></tr><tr><td>INSERT INTO config_item_release SELECT * FROM config_item c WHERE c.profile_id=9108</td><td></td><td></td><td>事务1对(max,+∞)加插入意向锁，被事务2阻塞</td></tr><tr><td></td><td>INSERT INTO config_item_release SELECT * FROM config_item c WHERE c.profile_id=9112</td><td>1213 - Deadlock found when trying to get lock; try restarting transaction, Time: 0.008000s</td><td>事务2对(max,+∞)加插入意向锁，被事务1阻塞，出现死锁</td></tr></tbody></table><h4 id="实验二：config-item-release存在数据，两个事务先delete后insert不会发生死锁"><a href="#实验二：config-item-release存在数据，两个事务先delete后insert不会发生死锁" class="headerlink" title="实验二：config_item_release存在数据，两个事务先delete后insert不会发生死锁"></a>实验二：config_item_release存在数据，两个事务先delete后insert不会发生死锁</h4><p>首先执行下面两条语句初始化表中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO config_item_release SELECT * FROM config_item c WHERE c.profile_id=9111;</span><br><span class="line">INSERT INTO config_item_release SELECT * FROM config_item c WHERE c.profile_id=9112;</span><br></pre></td></tr></table></figure><table><thead><tr><th>事务1</th><th>事务2</th><th>结果</th><th>分析</th></tr></thead><tbody><tr><td>begain</td><td></td><td></td><td></td></tr><tr><td></td><td>begain</td><td></td><td></td><td></td></tr><tr><td>DELETE FROM config_item_release WHERE profile_id=9111</td><td></td><td>Affected rows: 1, Time: 0.000000s</td><td>事务1对profile_id=9111记录前的间隙加G锁</td></tr><tr><td></td><td>DELETE FROM config_item_release WHERE profile_id=9112</td><td>Affected rows: 3, Time: 0.000000s</td><td>事务2对profile_id=9112记录前的间隙加G锁</td></tr><tr><td>INSERT INTO config_item_release SELECT * FROM config_item c WHERE c.profile_id=9111</td><td></td><td></td><td>事务1阻塞，因为事务2对profile_id=9112之前的间隙加了G锁，9111这条记录刚好在这个区间，事务1要加I锁时被事务2的G锁阻塞</td></tr><tr><td></td><td>INSERT INTO config_item_release SELECT * FROM config_item c WHERE c.profile_id=9112</td><td>Affected rows: 3, Time: 0.000000s</td><td>事务2先对9112之前的间隙加I锁这个间隙是当前事务的G锁不冲突没有阻塞</td></tr><tr><td></td><td>commit</td><td>OK, Time: 0.001000s</td><td>事务2成功提交，事务1结束阻塞状态</td></tr><tr><td>commit</td><td></td><td>OK, Time: 0.001000s</td><td>事务1成功提交</td></tr></tbody></table><p>综上所述，正式由于我先清除了历史数据，在删除表里不存在的记录时多个事务将相同的区间加了G锁，再加I锁时产生死锁，解决：删除业务逻辑中的清除历史数据的操作，保证表中数据存在。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>补充一下自己的知识盲区，重新梳理数据库的锁，详细见<a href="http://yywang.top/2020/11/16/%E6%8D%8B%E4%B8%80%E6%8D%8BMySQL%E7%9A%84%E9%94%81/#more" target="_blank" rel="noopener">上一篇文章</a></li><li>避免删除不存在的记录的操作，这个操作会加G锁，可能多个事务的G锁重叠了导致死锁</li><li>删除操作最好是先找到记录的id再根据id删除；因为只有在唯一索引的删除操作才会加R锁其他情况都会有G锁</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.fordba.com/lock-analyse-of-delete.html" target="_blank" rel="noopener">MySQL DELETE 删除语句加锁分析</a></p><p><a href="https://www.iteye.com/blog/narcissusoyf-1637309" target="_blank" rel="noopener">从一个死锁看mysql innodb的锁机制</a></p><p><a href="http://xiaobaoqiu.github.io/blog/2016/07/22/%5B%3F%5D-ge-si-suo-wen-ti/" target="_blank" rel="noopener">一个死锁问题</a></p><p><a href="http://www.fanyilun.me/2017/04/20/MySQL%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">MySQL加锁分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我又写bug了，O(∩_∩)O哈哈~，这次是MySQL数据库的死锁，真实太菜了🤷‍♀️(日常一菜)&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;我在实现一个
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>捋一捋MySQL的锁</title>
    <link href="http://yoursite.com/2020/11/16/%E6%8D%8B%E4%B8%80%E6%8D%8BMySQL%E7%9A%84%E9%94%81/"/>
    <id>http://yoursite.com/2020/11/16/捋一捋MySQL的锁/</id>
    <published>2020-11-16T07:04:15.000Z</published>
    <updated>2021-07-13T12:27:08.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文主要梳理MySQL的锁机制，主要是针对于Innodb引擎，目前网络上查的文章基本上都差不多，实际上是忽略了一些细节的，这些细节可能会成为今后搬砖过程中的恶魔，比如说插入意向锁，行锁之间的兼容关系这些，本文通过查阅资料加锁MySQL官网的说明再结合自己的理解梳理了一下MySQL的锁机制~</p><h2 id="锁的划分"><a href="#锁的划分" class="headerlink" title="锁的划分"></a>锁的划分</h2><p>这里要有一个前提，就是MySQL对锁的划分是两种不同的维度，按照加锁的粒度和锁的类型，并不是固定的什么锁什么锁，就比如表锁和行锁里都有共享锁或者排他锁，同样，共享锁或排他锁中也都有行锁和表锁，是你中有我我中有你的关系，按照不同维度划分的结果，下面就来一一列举这些锁</p><h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><p>以加锁的粒度为准可以分为，全局锁，表锁和行锁；</p><ul><li>全局锁；对整个数据库加锁，让整个数据库在只读状态，在数据库备份时使用（主库上备份，所有写操作将不能进行影响业务；从库上备份，备份期间不能有写操作，不能执行binlog，主从延迟增大）</li><li>表锁，加锁的粒度为数据表<ul><li>自增锁 AUTO-INC Locks 是一种特殊的表锁，可以保证一个事务插入数据的id连续</li></ul></li><li>行锁，加锁的粒度为数据行<ul><li>记录锁 Record Locks；锁定当前数据行</li><li>间隙锁 Gap Locks；锁定数据行的前后间隙<ul><li>插入意向锁 Insert Intention Locks；在插入操作之前会把插入的区域加入插入意向锁，不同区域的的锁互相兼容</li></ul></li><li>临键锁 Next-Key Locks；锁定数据行+前后的间隙</li></ul></li></ul><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><ul><li>共享锁（S）和 排他锁（X）；相当于，读锁和写锁，读可以共享锁，写只能独占资源；粒度可以有行锁和表锁，比如行级或者表级的S锁（或X锁）</li><li>意向锁(意向共享锁IS，意向排他锁IX)，一个事务在给数据行加锁时会在数据所在的表加相同类型的意向锁(比如对数据行加X锁就会在该表加表级别的X意向锁)，表示该表有事务对数据行加了锁，意向锁直接是相互兼容的，但是与具体的表锁或者行锁有着互斥关系的，具体关系见下面分析</li></ul><h2 id="锁之间的兼容关系"><a href="#锁之间的兼容关系" class="headerlink" title="锁之间的兼容关系"></a>锁之间的兼容关系</h2><table><thead><tr><th></th><th>S</th><th>X</th><th>IS</th><th>IX</th></tr></thead><tbody><tr><td>S</td><td>✅</td><td>❎</td><td>✅</td><td>❎</td></tr><tr><td>X</td><td>❎</td><td>❎</td><td>❎</td><td>❎</td></tr><tr><td>IS</td><td>✅</td><td>❎</td><td>✅</td><td>✅</td></tr><tr><td>IX</td><td>❎</td><td>❎</td><td>✅</td><td>✅</td></tr></tbody></table><p><strong>注:</strong> 意向锁是表级别的锁，上面表格中与意向锁兼容和互斥关系指的是与表级别的S锁或者X锁，意向锁和行级别的锁是不冲突的；主要是为了防止一个事务在插入或者修改数据的时候另一个事务修改了表结构之间会冲突；插入或者修改数据是一般会加行锁或者间隙锁，同时在表上加IX锁(意向排他锁)，另一个事务要修改表结构是要给表加X锁，这时会和IX锁冲突等待IX锁释放</p><p>这个只是我们熟知的锁之间的兼容关系，除此之外呢，MySQL中还有更加精确的锁之间的兼容关系，也就是在所有类型的行锁之间的兼容关系，(<a href="https://www.iteye.com/blog/narcissusoyf-1637309" target="_blank" rel="noopener">见参考文章3</a>)；这个关系是在X锁与X锁或者S锁与X锁不兼容的情况下再进行比对</p><table><thead><tr><th></th><th>G</th><th>I</th><th>R</th><th>N</th></tr></thead><tbody><tr><td>G</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>I</td><td>❎</td><td>✅</td><td>✅</td><td>❎</td></tr><tr><td>R</td><td>✅</td><td>✅</td><td>❎</td><td>❎</td></tr><tr><td>N</td><td>✅</td><td>✅</td><td>❎</td><td>❎</td></tr></tbody></table><p><strong>注:</strong>  G=Gap锁，I=Insert Intention锁，R=Record锁，N=Next-Key锁；</p><p>上表中的行代表当前已经存在的锁，理解一下这张表就假设两个X锁排斥的前提下：</p><ul><li>第一列<ul><li>已经存在G锁，不允许再加I锁（加了间隙锁就不允许在间隙中插入操作了）</li><li>已经存在G锁，还可以再加G锁、R锁和N锁（也就是说G锁之间是相互兼容的，R锁和G锁本身就不冲突当然兼容，N锁实质上就是G锁+R锁，G锁和R锁都兼容那么N锁一定兼容）</li></ul></li><li>第二列，已经存在I锁，剩下的所有类型锁都可以再加<ul><li>这里看到再加G锁也是兼容的即使加锁的间隙是一样的</li><li>根据官方文档两个I锁如果插入不是同一个位置是相互兼容的，这样可以提高并发</li><li>兼容R锁也很好理解，I锁是间隙，R锁是记录本身就不冲突</li><li>G锁和R锁都兼容了那么N锁一定兼容</li></ul></li><li>第三列，已经存在R锁，是可以加间隙锁的(G锁和I锁)，但如果包含记录的锁就不兼容(R锁和N锁)</li><li>第四列，已经存在N锁，首先包含记录的锁(R锁和N锁)是不兼容的，I锁表明要插入数据也是不兼容的，G锁是兼容的</li></ul><p>总结：G锁与其他锁之间是相互兼容的，无论间隙是否相同，也无论当前是什么类型的锁，再加G锁也是兼容的；I锁是G锁的一种，是在插入之前表明插入操作的意向，如果当前存在G锁或者N锁，也就是加锁的区域相同就不能再加I锁，需要等待，其他情况与G锁相同都是兼容的；R锁和N锁就看加锁的数据是否冲突来判断锁是否兼容</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://i6448038.github.io/2019/02/23/mysql-lock/" target="_blank" rel="noopener">秒懂InnoDB的锁</a></p><p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html" target="_blank" rel="noopener">InnoDB Locking</a></p><p><a href="https://www.iteye.com/blog/narcissusoyf-1637309" target="_blank" rel="noopener">从一个死锁看mysql innodb的锁机制</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;本文主要梳理MySQL的锁机制，主要是针对于Innodb引擎，目前网络上查的文章基本上都差不多，实际上是忽略了一些细节的，这些细节可能会成为
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO</title>
    <link href="http://yoursite.com/2020/10/23/JavaNIO/"/>
    <id>http://yoursite.com/2020/10/23/JavaNIO/</id>
    <published>2020-10-23T09:19:32.000Z</published>
    <updated>2021-07-13T12:27:08.584Z</updated>
    
    <content type="html"><![CDATA[<p>开门见山，最近打算看一下netty，做这么长时间微服务netty还没看过是不是太飘了，这篇是netty的背景知识</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>Non-blocking I/O 非阻塞I/O；与传统阻塞I/O相比最大的时阻塞和非阻塞的区别；除此之外NIO操作的是缓冲区，以块的形式处理数据，传统I/O以数据流的形式处理数据；而且NIO支持了Selector；我的简单理解，传统I/O相当于拿一根水管（单向的）插入到水桶里，让水从水桶中流出，从水管中得到水（数据）；NIO则是用水管（双向的水管？栗子可能比较糙但就是这么个意思）将桶中的水流入一个小水池中（缓冲区），从小水池中得到水（数据）；所以基于流的读写只能按顺序来，不能改变读写的位置，且只能是单向的，而对于缓冲区的数据来说就可以随意修改读写的指针了</p><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><ul><li>用来进行IO操作（文件IO或网络IO），与BIO的Stream类似，不同的时Channel是双向的Stream只能是单向的；Channel读写的对象是Buffer</li></ul><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><ul><li>用来存放Channel读写的数据，其实就是内存中的一块区域，保存不同类型的数据(ByteBuffer，CharBuffer等，可以理解为数组，字节数组，字符数组等)；首先通过Channel将数据写入到Buffer中，再对Buffer进行读写，flip()切换到读模式，clear()或compact()切换到写模式<ul><li>对Buffer每次读写之后Buffer都会记录当前的状态，通过capacity（Buffer的最大值），position（下次读或写的位置，每次读写后更新），limit（Buffer中数据的大小）三个属性；0 &lt;= position &lt;= limit &lt;= capacity</li><li>向缓冲区写入数据时，limit = capacity， position = 下一次写入的位置（初始为0）；如果想读出缓冲区的数据，调用filp()方法切换为读，limit = 下一次写入的位置（即读的边界），position = 0（从头开始读）；读完数据想要继续写，调用clear()方法，并不是缓冲区里的数据清空，而是将position重新指向0，limit = capacity 与写的状态一样，新写入的数据会覆盖到缓冲区中；compact()方法，将读模式下position-limit的数据复制到buffer的开头，相当与将已经读过的数据覆盖掉，limit = capacity，position = limit - position</li></ul></li></ul><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><ul><li>NIO非阻塞的特性，可以通过Selector使用一个线程监听多个Channel的IO事件，方法是将所有Channel注册到Selector中(这里Channel必须是非阻塞的)，并注册感兴趣的事件，Selector#select方法找到事件发生的Channel进行下一步工作，select这一步是阻塞的如果事件没有发生将一直阻塞，select的操作系统的实现为IO多路复用技术（select，poll，epoll），Linux下使用epoll</li></ul><p>简单罗列一下IO模型，和相关实现</p><h5 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h5><p>线程发起I/O请求会一直阻塞等待I/O条件就绪</p><h5 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h5><p>线程发起I/O请求后，如果I/O条件不是就绪状态立即返回一个状态不会一直等待，可以先做其他的任务，间隔一段时间查看I/O条件是否就绪，如果就绪进行下一步操作</p><h5 id="多路复用I-O"><a href="#多路复用I-O" class="headerlink" title="多路复用I/O"></a>多路复用I/O</h5><p>非阻塞I/O线程需要一直去询问I/O事件是否就绪，如果线程很多每个线程都不听的去轮询I/O事件必将造成资源的浪费；多路复用I/O将所有线程的I/O请求注册到一个新的线程中（select），由这一个线程进行轮询去查看I/O条件是否就绪，有就绪状态就通知对应的线程进行处理；相当于是把非阻塞I/O中多线程查看I/O条件的事情委托给了单独的一个线程，提高了系统的吞吐量；</p><p>在Linux中该模型的实现有select，poll和epoll的系统调用，服务端接受连接，select和poll都会将连接感兴趣的I/O事件保存到一个集合中（fd集合，在Linux中I/O是文件），每次Selector#select传递给内核，内核去寻找集合中满足条件的I/O，返回满足条件的数量，用户线程得到满足I/O条件的数量，需要再次遍历集合找到满足I/O条件的连接进行下一步操作，时间复杂度为O(2n)；epoll使用事件驱动模式，首先将连接感兴趣的I/O注册到内核，并且注册了一个回调函数，当满足I/O条件会发生回调将该I/O对应的fd移动到内核中的就绪队列，每次select只需从就绪队列中读取具备I/O条件的数量即可，再进行下一步的操作，当有m（m&lt;=n）个连接具备条件，时间复杂度为O(m)</p><h5 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h5><p>这个感觉和多路复用I/O差不多，这里将多线程的I/O操作注册为一个信号，信号中有回调函数，当信号发生call回调函数通知用户线程，先简单这么理解</p><h5 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h5><p>线程发出I/O请求后不需要做任何操作，I/O操作完全由操作系统内核完成，之后会通知线程I/O已经完成</p><p>具体例子可以参考<a href="https://segmentfault.com/a/1190000006824091" target="_blank" rel="noopener">这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开门见山，最近打算看一下netty，做这么长时间微服务netty还没看过是不是太飘了，这篇是netty的背景知识&lt;/p&gt;
&lt;h3 id=&quot;NIO&quot;&gt;&lt;a href=&quot;#NIO&quot; class=&quot;headerlink&quot; title=&quot;NIO&quot;&gt;&lt;/a&gt;NIO&lt;/h3&gt;&lt;p&gt;No
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁的套路-watchdog实现</title>
    <link href="http://yoursite.com/2020/10/19/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%A5%97%E8%B7%AF-watchdog%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/10/19/分布式锁的套路-watchdog实现/</id>
    <published>2020-10-19T13:38:46.000Z</published>
    <updated>2021-07-13T12:27:08.592Z</updated>
    
    <content type="html"><![CDATA[<p>开门见山，分布式锁用来保证分布式环境下业务逻辑的原子性以及互斥，原理就是锁的原理，多个系统一同去竞争同一个资源（类比单机环境下多个线程竞争同一块内存），获得资源的系统可以认为是加锁成功，否则加锁失败；下面总结一个简单可用的分布式锁的实现</p><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><p>日常开发中，一定会有定时任务操作一些数据的需求，而且这个定时任务还必须要高可用，所以就必须要在分布式环境下运行，但是又不能多个系统一起运行，所以就需要用到分布式锁，能够保证一个系统去运行定时任务，在这个系统出现异常了，其他的系统能够顶上来完成剩下的任务，类似于watchdog的功能</p><p>总结了一个流程图如下</p><p><img src="/images/分布式锁.png" alt="分布式锁"></p><p>如图所示这个套路，简单无脑，定时任务的时候lock一下，成功了就继续执行，失败了就return，下一个周期再lock；把过期时间设置的比定时任务周期稍微长一些，也就是说当一个系统获取锁成功后，如果没有意外情况后面的周期还是这个系统运行（类比于jvm中的偏向锁，不同的时这个会一直偏不会锁升级），当系统发送异常情况，其他的系统就会lock成功，继续后面的任务，可以完成一个简单高可用的定时任务</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>上面讲过，分布式锁的原理就是能够保证互斥，在一个所有系统都能访问到的地方去做文章，基于这点就有很多种实现，比如数据库这样提供存储的工具(mysql、redis、zk、etcd等等)，理论上所有数据库都可以用来实现分布式锁甚至文件都可以，就看自己的需求了；通常的话使用数据库、redis和zk的比较多</p><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><p>mysql的话是通过数据库的唯一索引保证原子性，首先要创建一个表用于存锁的相关信息，需要一些必填字段</p><ul><li>lockName - 唯一索引，锁的名称</li><li>modifyTime - 修改时间</li><li>owerIp - 获取锁的Ip</li><li>lockTime - 锁的有效时间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public boolean lock(lockName, lockTime)&#123;</span><br><span class="line">    // 获取当前的锁</span><br><span class="line">Lock currentLock = lockDao.findLockByLockName(lockName);</span><br><span class="line">// 当前没有加锁</span><br><span class="line">if (currentLock == null) &#123;</span><br><span class="line">    return tryLock(lockName, maxLockTime);//加锁</span><br><span class="line">&#125;</span><br><span class="line">//  锁过期了并且成功释放锁 -&gt; 重新加锁，释放锁异常返回false</span><br><span class="line">    if (currentTimeMillis-currentLock.getModifyTime().TimeMills &gt; currentLock.getMaxLockTime()) &#123;</span><br><span class="line">        return unlock(lockName) ? tryLock(lockName, maxLockTime) : false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 锁没过期且自己占有锁且锁没过期 续租</span><br><span class="line">    if (currentLock.getOwnerIP().equals(NetUtils.getLocalHost())) &#123;</span><br><span class="line">        renewLock(currentLock);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void renewLock(Lock currentLock) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        currentLock.setModifyTime(new Date());</span><br><span class="line">        lockDao.update(currentLock);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        // 续租失败，但锁没过期，仍然有效</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean tryLock(String lockName, long maxLockTime) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        lockDao.save(new Lock(lockName, NetUtils.getLocalHost(), maxLockTime));</span><br><span class="line">        return true;</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean unlock(String lockName) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        lockDao.deleteLockByLockName(lockName);</span><br><span class="line">        // 可能存在其他线程把当前线程的锁释放掉，这里可以根据线程的持有者进行释放锁的操作</span><br><span class="line">        // 在我的场景下可以保证定时任务一定会在锁的有效时间内执行完成，故不考虑这种情况</span><br><span class="line">        return true;</span><br><span class="line">    &#125;catch (Exception e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><p>redis相较于mysql而言吞吐量有了显著的提高，并且也提供了一系列原子操作的api，而且还有过期时间的api不需要，可以很简单的实现分布式锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public boolean lock(lockName, lockTime)&#123;</span><br><span class="line">    // 获取当前的锁</span><br><span class="line">String value = redis.get(lockName);</span><br><span class="line">// 当前没有加锁</span><br><span class="line">if (value == null) &#123;</span><br><span class="line">    return tryLock(lockName, maxLockTime);//加锁</span><br><span class="line">&#125;</span><br><span class="line">    // redis自己会清理过期的key, 锁没过期且自己占有锁且锁没过期 续租</span><br><span class="line">    if (value.equals(NetUtils.getLocalHost())) &#123;</span><br><span class="line">        renewLock(lockName, period);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void renewLock(Strng lockName, long period) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        // period为定时任务的周期时间，因为lockTime要比period大，每次续期lockTime后锁的过期时间会越来越大</span><br><span class="line">        redis.expire(lockName, redis.ttl(lockName)+period);</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        // 续租失败，但锁没过期，仍然有效</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean tryLock(String lockName, long maxLockTime) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        return redis.setNx(lockName, NetUtils.getLocalHost(), maxLockTime));</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean unlock(String lockName) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        lockDao.deleteLockByLockName(lockName);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;catch (Exception e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面给了两种方式的简单实现，实际过程中还需要考虑异常情况的细节，除此以外还有很多种实现的方式只是列举了两种，套用流程图上的套路，实现一个简单的watchdog的功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开门见山，分布式锁用来保证分布式环境下业务逻辑的原子性以及互斥，原理就是锁的原理，多个系统一同去竞争同一个资源（类比单机环境下多个线程竞争同一块内存），获得资源的系统可以认为是加锁成功，否则加锁失败；下面总结一个简单可用的分布式锁的实现&lt;/p&gt;
&lt;h3 id=&quot;业务场景&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring中bean的生命周期总结</title>
    <link href="http://yoursite.com/2020/10/09/Spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/10/09/Spring生命周期总结/</id>
    <published>2020-10-09T12:00:44.000Z</published>
    <updated>2021-07-13T12:27:08.587Z</updated>
    
    <content type="html"><![CDATA[<p>最近非常的忙碌，博客也一直没有更新，可惜自己一直没有时间去看新的东西还想更新博客，心有余而力不足，那就把旧的知识温习一下，来“敷衍”一下；废话不多说，要看spring中bean完整的生命周期要从BeanFactory接口中看，如图，主要分为以下几个部分</p><ul><li>xxxxAware接口的方法</li><li>BeanPostProcessor接口的postProcessBeforeInitialization方法</li><li>InitializingBean接口的afterPropertiesSet方法</li><li>自定义的init方法</li><li>BeanPostProcessor接口的postProcessAfterInitialization方法</li></ul><p>销毁</p><ul><li>DestructionAwareBeanPostProcessor的postProcessBeforeDestruction方法</li><li>DisposableBean接口的destroy方法</li><li>自定义的销毁方法</li></ul><p><img src="/images/spring-bean生命周期1.png" alt="spring-bean生命周期1"></p><p>下面结合源码画一个生命周期图</p><p><img src="/images/spring-bean生命周期2.png" alt="spring-bean生命周期2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近非常的忙碌，博客也一直没有更新，可惜自己一直没有时间去看新的东西还想更新博客，心有余而力不足，那就把旧的知识温习一下，来“敷衍”一下；废话不多说，要看spring中bean完整的生命周期要从BeanFactory接口中看，如图，主要分为以下几个部分&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>我又来入门k8s了</title>
    <link href="http://yoursite.com/2020/06/30/%E6%88%91%E5%8F%88%E6%9D%A5%E5%85%A5%E9%97%A8k8s%E4%BA%86/"/>
    <id>http://yoursite.com/2020/06/30/我又来入门k8s了/</id>
    <published>2020-06-30T14:49:30.000Z</published>
    <updated>2021-07-13T12:27:08.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>之前分析过Docker容器技术，在容器技术很快的被广大使用之后，对于业务复杂的公司来说往往需要非常多的容器，而每次都需要docker run或者restart的话也是非常麻烦的而且人操作的话还容易出错，这就需要一个容器管理的一个组件，比如docker swarm、mesos和k8s，最终k8s脱颖而出称为大多数人的选择，而且k8s还被称为PaaS平台的操作系统，那么k8s能做什么呢？</p><p>Pod，是k8s提出的概念，是k8s的最小调度单位，Pod中可以有一个容器或者多个容器</p><ul><li>Pod调度；k8s采用声明式API的方式，用户只需编写yaml文件描述所期望的Pod状态(比如2个容器，4c8g)，k8s根据所期望的Pod状态进行部署和维护</li><li>健康检查自动恢复；监控集群中Pod的状态发现异常Pod进行迁移或重启</li><li>动态扩缩容；检查Pod负载高时动态扩容进行负载均衡；反之减少容器节省资源</li><li>负载均衡</li></ul><p>类似于Pod的运维系统，有了这些功能完全可以将自己的系统托管给k8s，可以减轻运维人员的工作</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>master+slave的架构，master节点负责系统逻辑的处理，调度，slave节点来干活，与spark集群的模式是一样的</p><ul><li>master节点组件<ul><li>etcd：分布式kv数据库，用于保存数据(yaml文件)和集群的状态，其他组件都通过api server向etcd读写数据，理解为用来保存状态的数据层；etcd还是高可用的分布式数据库可以保证master的高可用</li><li>api server：提供api服务，负责各个模块之间的通信，不同组件之间交互都需要经过api server，理解为数据总线</li><li>controller manager：负责维护集群的状态，确保集群的状态与etcd中的状态保持一致，理解为MVC中的Controller层；例如健康检查，slave节点中的kubectl会向master节点(通过api server)定期报告节点中Pod的状态，相当于slave向master发心跳，心跳状态会保存在etcd中，master节点中的controller manager会定期从etcd中获取slave的状态，针对这些状态与etcd中保存的期望状态比对进行下一步操作，通过api server通知scheduler组件创建一个调度任务发送给slave节点</li><li>scheduler：负责调度，将pod调度到合适的node中；创建pod资源的时候，通过etcd中的状态调度到合适的slave节点中，更新或者删除也是这样</li></ul></li><li>slave组件<ul><li>kubelet：可以理解为通过实现了一些接口来对slave节点进行管控操作；负责与master通信，通过CRI(Container Runtime Interface)操作容器运行时(container runtime)，相当于是slave节点中的控制器，理解为通过CRI”发送指令”到容器运行时，对当前节点中pod做CRUD操作；还负责配置当前slave节点的网络和存储，通过调用网络插件和存储插件为容器配置网络（CNI Container Networking Interface）和持久化存储（CSI Container Storage Interface）；</li><li>kube-proxy：用于service的服务发现和负载均衡，通过iptable机制；service是相同服务的的多个pod集合，相当于一个VIP职责，不需要关心具体服务的ip只需访问服务的域名，由kube-proxy来转发到具体的pod</li><li>container runtime：真正对pod做CRUD操作的组件，相当于kubelet的slave</li></ul></li></ul><p><img src="/images/k8s.png" alt="k8s"></p><p>如上图在slave节点中kubelet扮演控制器的角色来操作通过进行时对Pod进行操作，而kube-proxy是将访问pod的流量转发到相应的pod中，一个pod在启动之前k8s会在pod中先启动一个初始容器为这个容器添加Namespace，network，Volume这些设置，再将后启动的容器添加到初始容器的Namespace中去，这个初始容器用来进行进程隔离，与Pod具有相同的生命周期，通常Pod中容器的访问，日志收集等操作都会由这个容器来完成，也就是sidecar容器；访问某个pod的时候首先会经过iptables的规则转发到Pod的sidecar容器里，再由sidecar容器转发到目标应用容器中，sidecar可以天然用来做微服务中的流量控制，服务治理，灰度发布等功能</p><p>工作原理</p><ul><li>用户提交了yaml文件给apiserver</li><li>apiserver会将数据保存到etcd中，再通知scheduler有容器需要被调度</li><li>scheduler根据配置选择合适的node，返回给apiserver</li><li>apiserver将结果同步到etcd中，再通知对应node中的kubectl</li><li>kubectl收到通知后调用container runtime来真正去启动这个配置的容器，调用storage plugin配置存储，调用network plugin配置网络</li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul><li>Pod；Pod是k8s的最小调度单位，Pod中可以有一个容器或者多个容器；前面分析过docker是通过Namespace和Cgroup技术来进行进程的隔离，是基于单进程模型并不具备管理多进程的能力，（参考<a href="https://zhuanlan.zhihu.com/p/83482791" target="_blank" rel="noopener">这里</a>大概是是无法回收僵尸进程和孤儿进程的资源的意思因为回收进程资源需要向父进程发送一个信号）；k8s通过将多个容器加入到同一个Namespace中并给头号进程赋予了管理多进程的能力，所以说相较于docker容器来说k8s的Pod概念更像是虚拟机一样，提供了传统虚拟机到容器环境的完美迁移方案</li><li>Deployment；对Pod的一个抽象，可以定义Pod的副本数量，版本，可以用Deployment来描述一个应用集群的状态</li><li>ReplicaSet；用来控制Pod的版本，Deployment不会之间控制Pod，而是通过ReplicaSet来间接控制Pod，一个Pod的版本对应一个RS（可以实现金丝雀发布，蓝绿发布）</li><li>StatefulSet；有状态的Pod进行编排；Pod之间有拓扑关系的拓扑状态或者存储状态；</li><li>DaemonSet；集群中运行一个DaemonPod，每个Node中有且只有一个，如果有新节点加入集群会自动创建；比如node中的各种插件（网络，存储，监控，日志）</li><li>Service；提供了一个或者多个Pod的访问地址，由于Pod的地址可能会变，通过域名可以做到不依赖于固定的ip地址访问Pod，相当于VIP，由kube-proxy+iptables来共同实现</li><li>Job；一次性任务，运行完成后退出</li><li>CronJob；定时任务，用于离线计算</li><li>等等等等，只是了解到了这些，还有很多去查看官方文档吧</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;之前分析过Docker容器技术，在容器技术很快的被广大使用之后，对于业务复杂的公司来说往往需要非常多的容器，而每次都需要docker run
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>一年菜鸡带你看微服务</title>
    <link href="http://yoursite.com/2020/06/25/%E4%B8%80%E5%B9%B4%E8%8F%9C%E9%B8%A1%E5%B8%A6%E4%BD%A0%E7%9C%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/06/25/一年菜鸡带你看微服务/</id>
    <published>2020-06-25T08:36:16.000Z</published>
    <updated>2021-07-13T12:27:08.590Z</updated>
    
    <content type="html"><![CDATA[<p>工作快一年了，我从一个刚入职时候的小白变成了现在有一年经验的小白,在我这一年的工作中修炼自己，现在可以说是把自己的一条腿抬过了微服务的门槛，在这个位置看到了一下东西，把我的理解记录分享一下。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着历史进程的发展，我们的业务量也愈发膨胀，系统的也从原来的单体架构，逐渐演化成微服务架构，将重复的业务逻辑抽象成基础的服务，这样做不仅仅可以将业务解耦，还通过将一个大的系统拆分成服务粒度的子系统，各个子系统单独开发编译测试上线，大大提高了开发的效率，加快了系统迭代的速度。根据我的理解，微服务框架包括RPC框架和注册中心两个部分，下面就来分别介绍一下</p><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>微服务框架是用来进行远程调用，涉及到远程调用就会有服务的提供方（provider）和调用方（consumer），注册中心的工作就是让他们彼此认识，即服务注册和服务发现，除此之外注册中心还负责将对方状态的变化通知到另一方，配置下发等功能，主要有CP和AP两种选型的注册中心</p><ul><li>CP 强一致性 Zookeeper、etcd …<ul><li>用Zookeeper举例来说，发布服务就会创建一个目录，在该目录下维护服务提供方和调用方的信息，通过zk本身的watch机制来观察服务状态变化</li><li>缺点是当服务规模很大时，zk需要数据同步的时间变长，期间服务不可用，也就是选择CP会出现的问题；数据同步的请求量大很可能将leader打挂（比如说我了解到曾经有服务大规模扩容，为了保证顺序所有follower将写请求发送给leader，大量写请求导致leader宕机，重新选择leader期间服务不可用，新的leader瞬间又被打挂）</li></ul></li><li>AP 弱一致性 消息总线型<ul><li>服务注册和订阅的数据全量保存在一个存储介质中，注册中心从存储介质中获取的数据缓存在内存中，通过消息总线做数据同步（推拉结合，用版本号保证消息的顺序性）</li><li>服务调用方从注册中心获取数据保存在调用方的内存中，同样采用推拉结合，保证最终一致性；<ul><li>推 callback机制，服务调用方在生成代理的目标对象之前会向注册中心订阅配置，订阅的时候会将callback序列化发送给注册中心，注册中心收到带有callback参数的请求为callback创建代理对象，相当于是一个反向的RPC调用（服务提供方向服务调用方发送请求复用已有的tcp连接）</li><li>拉 心跳，服务调用方通常会向注册中心发送心跳来告知自己的状态，发心跳的同时拉取需要更新的数据到内存中</li></ul></li></ul></li></ul><h3 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h3><p>RPC框架用于服务之间的通信，例如Dubbo、SpringCloud、gRPC，通过不同的协议完成服务之间的调用；除了最基本的通信以外还包括服务治理策和流量控制的策略，服务监控和追踪，等其他特性</p><h4 id="服务治理-amp-流量控制"><a href="#服务治理-amp-流量控制" class="headerlink" title="服务治理&amp;流量控制"></a>服务治理&amp;流量控制</h4><ul><li>服务管理<ul><li>服务节点的新增删除；分组，动态分组的设置与取消；不同维度的上下线</li></ul></li><li>路由策略<ul><li>调用者将请求路由至固定的一个或者多个服务提供方的节点；用于测试，或者灰度发布</li></ul></li><li>负载均衡<ul><li>将服务调用方的请求均匀的发送给选择到的服务提供方节点；随机、加权随机、轮询、加权轮询、最少活跃、一致性哈希，之前分析过不同的策略实现，移步<a href="http://yywang.top/2020/03/27/%E6%8F%AD%E7%A7%98%E4%BA%AC%E4%B8%9C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">这里</a>查看</li></ul></li><li>容错策略(集群策略)<ul><li>failover 失败自动切换不同的服务提供方进行重试 （业务错误重试和安全重试？）</li><li>failfast 快速失败，失败</li><li>failsafe 失败安全，出现异常直接忽略，用于记录审计日志</li><li>broadcast 广播调用，失败的跳过</li><li>pinpoint 点对点调用</li></ul></li><li>限流 用于保护服务提供方（按APP，接口，分组，IP，方法不同的维度）在服务提供方和调用方都可以实现限流的逻辑<ul><li>在服务提供方的限流逻辑只是针对于单个容器或者物理机，服务提供方只需处理小于最大限流值的请求即可，不需要关心其他的服务节点，几乎没有性能的损耗，具体的限流算法之前写过一篇限流算法的<a href="http://yywang.top/2020/05/14/get%E9%99%90%E6%B5%81%E5%A7%BF%E5%8A%BF/#more" target="_blank" rel="noopener">介绍</a></li><li>在服务调用方做限流逻辑可针对整个集群的维度，一般是先请求集中式的服务来判断本次请求是否超过限流值，多了一次rpc请求，会影响性能，在京东微服务框架中，限流逻辑在服务调用方有monitor和counter两种实现方式；monitor服务，对es中的监控日志进行统计异步判断是否超过限流值，因为是异步请求不影响性能，但限流的实时性无法保证不完全精准，目前这种方式已经废弃；counter服务，通过访问缓存数据库实时统计请求，判断是否超过限流值，精度准确，会影响性能；</li></ul></li><li>熔断，用于保护服务调用方<ul><li>防止服务调用方依赖下游服务异常，挂起大量请求压垮容器，比如服务调用方依赖下游的服务，由于下游的服务异常导致短时间内无法收到响应而一直挂起，如果挂起的请求过大可能会使服务不可用，熔断策略可以快速返回失败从而保护服务不被打挂掉</li><li>熔断器（打开，半打开，关闭三种状态；服务调用的失败率高于某一阈值，新的请求直接返回失败不进行处理，进入半打开状态；半打开状态一段时间后，开始处理新的请求，如果失败率仍然高于阈值，则进入关闭状态否则进入打开状态）</li></ul></li><li>分组<ul><li>业务流量隔离，将核心业务与其他业务隔离开来</li><li>控制同机房调用，不同的机房设置不同的分组，通过分组来实现相同机房的服务以及互相调用</li><li>动态分组；可以用来流量切换；可以应对突发的流量激增，分组中预留的容器依然不能顶住流量，可以借用其他分组中容器来分担一部分流量</li></ul></li><li>流量回放；服务调用方异步存储请求和响应，用来测试</li></ul><h4 id="服务监控和追踪"><a href="#服务监控和追踪" class="headerlink" title="服务监控和追踪"></a>服务监控和追踪</h4><p>用来查看请求量（TPS，实时和历史数据）、响应时间</p><ul><li>服务监控 数据采集方式 a)通过服务主动上报，将日志数据发送到日志节点 b)通过代理收集，将日志数据保存到本地，代理解析本地日志（sidecar）</li><li>服务追踪 整条链路用TraceId标记，其中经过的每个服务节点都有不同的SpanId，最终通过对数据结构的解析绘制链路图</li></ul><h4 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h4><ul><li>健康检查，通过发送心跳报告节点的状态<ul><li>比如在京东微服务框架中调用方隔30s向内存中的服务提供方列表发送心跳（探活），探活不同结果将列表分成不同的状态（健康、亚健康、死亡），调用方每次从健康节点的集合中选择一个发起调用；亚健康状态只发心跳不发请求，当心跳恢复移至健康节点，健康-&gt;亚健康（连续6次心跳失败，异常心跳可重试两次，三次都失败则当前心跳失败），连续60次心跳失败加入重连的集合中，10s重连一次</li><li>服务提供方和服务调用方都会想注册中心发送心跳报告状态，30s，服务提供方连续8小时没有向注册中心发送心跳会删除</li></ul></li><li>优雅启停<ul><li>停止；拒绝新的请求，返回一个正在关闭的异常，调用方安全重试-&gt;在超时时间范围内处理完已经接受的请求，时间范围以外的返回异常-&gt;开始关闭动作释放资源</li><li>启动；启动预热，随着启动时间的增加逐步增加流量，定时动态修改负载均衡策略的权重；提前加载缓存数据；注册之前模拟调用逻辑保证服务可用-&gt;延迟暴露，待所有的服务完全启动完再想注册中心注册服务</li></ul></li><li>泛化调用；在没有接口和API的情况下发起调用，将服务提供方的接口名，分组，方法名，参数发送给服务提供方，随后根据信息通过反射调用本地方法（1.测试平台，无需修改配置重启再发起调用；2.统一网关，无需引入jar包）</li><li>安全问题；服务调用方通过引入jar包的方式来发起调用，可能会发生在服务提供方不知情的情况下发起调用，成为压垮服务的最后一根稻草<ul><li>服务的提供方和调用方商量一个token，服务提供方收到请求在filter中校验隐式传参的的token判断是否通行</li><li>在京东微服务框架中还可以再服务治理平台中开启APP调用，只有申请了APP调用被服务提供方审核之后才能从注册中心中获取服务列表</li></ul></li></ul><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>将远程调用的过程通过动态代理封装起来，与业务逻辑解耦，使用者可以专心于业务逻辑而不必关心RPC调用的过程；</p><ul><li>服务提供方启动<ul><li>与注册中心建立连接，订阅全局配置（远程callback机制，发送请求将callback序列化发送出去，接收方对callback进行动态代理回调发送方）</li><li>开启并暴露服务的端口，向注册中心注册</li></ul></li><li>服务调用方启动<ul><li>与注册中心建立连接，订阅全局配置</li><li>创建动态代理对象，构造执行链 filter chain（内置的filter-&gt;自定义的filter-&gt;最后的filter根据配置生成路由，负载均衡策略的逻辑）注入到代理对象中</li><li>向注册中心订阅服务列表</li></ul></li><li>调用方发起调用<ul><li>调用前首先运行执行链，最后的filter过滤出服务提供方节点（本地调用-&gt;路由策略-&gt;黑白名单-&gt;负载均衡）</li><li>序列化请求的参数，封装协议报文，根据配置的集群容错策略通过netty框架向服务提供方发送请求，</li></ul></li><li>服务方处理请求<ul><li>接收到请求首先适配协议，根据协议和序列化、压缩的方式解析请求</li><li>运行执行链，最后的filter会根据接口名、方法和参数信息通过反射调用本地方法，最后将接口返回给调用方，调用方进行反序列化得到响应结果</li></ul></li></ul><h2 id="Service-Mesh-服务网格"><a href="#Service-Mesh-服务网格" class="headerlink" title="Service Mesh 服务网格"></a>Service Mesh 服务网格</h2><p>微服务发展到今天一些弊端也逐渐显露出来，最大的痛点就是业务入侵严重，使用者通过引入jar包使用微服务框架，如果要增加新的功能点或者修复一个紧急的bug就需要告诉所有使用方升级一下jar包，这会非常困难，可能你会说maven修改一下版本不就好了，但是在京东如果非常重要的业务比如交易服务，是不希望去做改变的，而且服务上下有着非常复杂的依赖关系牵一发而动全身；另外微服务框架不支持跨语言，对应微服务框架的不同语言直接想要互相调用得需要多个语言开发的框架版本才行，这对于开发和维护的成本都非常大。</p><p>Service Mesh完美的解决了这两个痛点，可以简单将其理解为将RPC框架的内容抽象成sidecar，微服务框架的jar包中只保留与sidecar通信的总要逻辑即可，这些逻辑基本上是不会变的，当发布你的应用容器的时候注入sidecar，原来是容器中的应用直接互相调用的方式现在变成了容器中的应用与容器中的sidecar通信，sidecar通过iptables规则做请求转发，并且服务治理，流量控制的这些逻辑抽象到了sidecar中这对于业务方来讲只需重新注入sidecar即可完成升级，对于应用来讲升级过程是透明的。</p><p><img src="/images/微服务.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作快一年了，我从一个刚入职时候的小白变成了现在有一年经验的小白,在我这一年的工作中修炼自己，现在可以说是把自己的一条腿抬过了微服务的门槛，在这个位置看到了一下东西，把我的理解记录分享一下。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>蓦然回首servlet</title>
    <link href="http://yoursite.com/2020/06/11/%E8%93%A6%E7%84%B6%E5%9B%9E%E9%A6%96servlet/"/>
    <id>http://yoursite.com/2020/06/11/蓦然回首servlet/</id>
    <published>2020-06-11T09:16:07.000Z</published>
    <updated>2021-07-13T12:27:08.596Z</updated>
    
    <content type="html"><![CDATA[<p>听到Servlet我既熟悉又陌生，我第一次接触还是在2013年，当时对于课程设计水平的我来说仅仅有个感性的认识，后来接触了ssh之后好像已经疏远了servlet，我只在写业务逻辑一直到现在，我对于servlet的印象还停留在声明，在web.xml中配置，写mapping这些，说明spring的解耦是真的强👍，让我对servlet的认识止步榆次，今天就回首看看这位“老朋友”，就大概梳理一下吧</p><ul><li><p>Servlet是一个接口，服务器用来处理Http的请求的，接口中主要service方法用来处理http请求，init和destroy方法表示servlet初始化和销毁是调用，总结一句话来说，servlet是一种规范，是服务器处理Http请求的规范。</p></li><li><p>Tomcat就是实现servlet规范(接口)的一个🌰，Tomcat中实现了servlet容器用来管理servlet，当收到Http请求后将请求封装成request对象，并根据请求的信息找到对应servlet(web.xml)，将请求交给对应的servlet处理，并将处理结果的response对象转化成Http的协议返回给浏览器</p></li></ul><p><img src="/images/servlet.png" alt="upload successful"></p><ol start="0"><li>叫容器的就可以理解为字面意思，用来存放一类东西；web容器里存储web应用，Servlet容器里存储Servlet，Spring容器存放bean等等等等</li><li>Tomcat就是一个web容器，其中包含多个web应用，每个应用在Tomcat启动时都会初始化一个servlet容器，用来保存应用下的servlet；Tomcat启动后会监听在8080端口，等待接收请求的到来，在收到请求后根据请求信息首先到想要访问的目标web应用中的web.xml文件里找到目标Servlet，并将Http请求封装成request对象交给Servlet处理（容器中如果没有相应的servlet就会先初始化–懒加载）</li><li>servlet处理请求是调用的service方法，在SSM中我们通常会在web.xml中配置springMVC的DispatcherServlet用来处理所有请求(servletMapping为*)，这个servlet根据请求对象，将这个request封装成Spring框架中的request对象，从SpringMVC中找到对应Controller处理<ul><li>a. 当初始化这个servlet会触发初始化SpringMVC容器，SpringMVC容器会初始化Spring容器，并将Spring容器设置为自己的父容器，这时候就是熟悉的Spring容器的加载</li><li>b. 这里SpringMVC容器里管理的时ControllerBean，Spring容器中管理端的是ServiceBean和DAOBean这些，（这些bean是创建顺序我还没研究，挖坑→_→）由于是父子关系SpringMVC可以访问Spring容器中的bean，反过来就不可以</li></ul></li><li>这步就是熟悉的Controller层调用Spring容器中的Service逻辑，在调用DAO层逻辑持久化，将结果response返回给SpringMVC</li><li>SpringMVC将response对象转为servlet规范里的response对象返回给servlet</li><li>Servlet将response转化为Http的响应交给Web容器Tomcat，最终由Tomcat返回给浏览器</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;听到Servlet我既熟悉又陌生，我第一次接触还是在2013年，当时对于课程设计水平的我来说仅仅有个感性的认识，后来接触了ssh之后好像已经疏远了servlet，我只在写业务逻辑一直到现在，我对于servlet的印象还停留在声明，在web.xml中配置，写mapping这些
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>震惊!系统崩了竟然因为这个</title>
    <link href="http://yoursite.com/2020/05/28/%E9%9C%87%E6%83%8A!%E7%B3%BB%E7%BB%9F%E5%B4%A9%E4%BA%86%E7%AB%9F%E7%84%B6%E5%9B%A0%E4%B8%BA%E8%BF%99%E4%B8%AA/"/>
    <id>http://yoursite.com/2020/05/28/震惊!系统崩了竟然因为这个/</id>
    <published>2020-05-28T09:16:07.000Z</published>
    <updated>2021-07-13T12:27:08.596Z</updated>
    
    <content type="html"><![CDATA[<p>菜鸟遇到线上问题，从第一次发现问题到问题解决用时2个月，也算是个记录吧，哈哈，本文记录下我解决问题的心路历程，也不是什么高级的问题，大神请绕路</p><h3 id="第一次问题"><a href="#第一次问题" class="headerlink" title="第一次问题"></a>第一次问题</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>4月27日10:40-11:40一个尾数164的容器CPU突然飙升疯狂收到报警的邮件和消息</p><h4 id="应对措施"><a href="#应对措施" class="headerlink" title="应对措施"></a>应对措施</h4><ul><li>查看后台日志有一个url在刷屏，条件反射的找到这个刷屏的人给他限流（因为之前有过类似的情况，用户通过程序发送url请求来获取数据，30秒之内精准限流，我也是老手了）</li><li>继续观察监控，调用量下来了，CPU迟迟不降，没有办法重启了容器</li></ul><p><img src="/images/dump问题1.png" alt="upload successful"></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li>CPU不降一定是还在做计算工作</li><li>排查被刷的url，是一个监控报表的url（由于系统只提供最大1小时的数据，临近618很多用户需要几天甚至几周的数据做分析，不得已通过程序来跑出自己所需的数据）</li><li>代码走查，是通过调用es的服务，获取数据，再封装成前端需要的数据返回，逻辑上是没问题的<ul><li>获取数据：查的是es响应很快，2s之内就有数据</li><li>前端页面一共3个图，不论查询多少时间间隔的数据都只有90个点，3个图共270个点，也就是后台封装270个对象</li></ul></li><li>整个过程也就封装对象是计算的过程需要CPU，难不成这个人用多个线程来跑这个url，这也太变态了吧</li><li>验证：7个任务，每个任务循环访问500次，查看监控CPU还不到5%，平常2%左右</li></ul><h4 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h4><ul><li>可以排除是获取监控数据这个URL的问题，当天回看日志没有发现其他异常，问了前辈之前也没出现过类似问题，而且手上还有需求就先搁置了；过了一周再排查的时候发现找不到历史日志了，因为刚刚迁移了环境历史日志没有打开，死无对证了。。。</li><li>也算排查了一个系统的风险点吧，最终，开启系统的历史日志，重新配置报警的阈值，等下次再出问题时摘除负载均衡，保留现场再做排查</li></ul><h3 id="第二次出现问题"><a href="#第二次出现问题" class="headerlink" title="第二次出现问题"></a>第二次出现问题</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>5月26日19:15前后，同样还是收到尾数164的容器CPU飙升的告警邮件，本以为上次的问题是个灵异事件，没想到又出现了，有了上次的经验，这次就很从容，将负载均衡摘除安心排查问题，可是一会又收到了同机房尾数是182的容器的报警邮件，群里的用户也开始反馈系统无法访问了，我愣住了，脑子里都是在想最近有做什么上线吗，是哪里出了问题；在我发愣的时候，前辈已经开始扩容，紧急扩容了4个容器这才稳住局势，这我才回过神来，我还是年轻😂</p><p><img src="/images/dump问题2.png" alt="upload successful"></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ul><li>经过上面的处理，下面就开始分析问题了，首先还是看日志没有发现异常，于是和运维同学要了dump文件，运维同学说dump不用看了，容器的jvm内存只有1G？？？想到当时迁移系统时没改配置，使用的是默认的配置，修改了内存配置后解决问题，完事儿！那我写这篇文章也太水了吧，哈哈</li><li>我要了dump文件，还是要看一下问题的，而且每次都是尾数164的容器出错，太诡异了</li><li>使用JProFiler分析dump，可以看到百万数量级的引用4类，结合最大的对象来看，是一个超大的list，占用了80%的内存</li></ul><p><img src="/images/dump问题3.png" alt="upload successful"><br><img src="/images/dump问题4.png" alt="upload successful"></p><ul><li>代码走查，list中的对象是事件的对象，用来同步数据用，类似消息队列，再结合日志来看，马上定位到了一个用户再操作实例的上线（更改实例中所有接口的状态，产生的事件是为了同步数据），并产生了300w+的事件，系统封装事件后终于把内存撑爆，进行FullGC，Stop The Word</li><li>查看日志和用户操作的记录，我寻思对一个实例操作怎么会有这么多事件，不会是有死循环了吧；先排查了不是多线程的问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (Server server : servers) &#123;</span><br><span class="line">    // 外层循环生产事件</span><br><span class="line">    eventList.add(buildEvent(server));</span><br><span class="line">    for (IfaceAlias ifaceAlias : ifaceAliasList) &#123;// 内层循环与外层循环的数据一样</span><br><span class="line">        if (condition) &#123;</span><br><span class="line">            eventList.add(buildEvent(ifaceAlias));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 伪代码，只是为了展示代码结构</span><br></pre></td></tr></table></figure><ul><li>上线的逻辑是这样<ul><li>a.数据库中修改实例的状态（两个sql用时3s内）</li><li>b.封装要操作的事件</li><li>c.发送事件 （调用远程服务，远程服务没有接受到事件的日志，定位在b中出现问题）</li></ul></li><li>步骤b中，嵌套了两层循环来生产事件，逻辑如下（以前代码的逻辑，为什么这么做就不知道了，前辈的东西先不动），我查了线上的数据，这个实例中有282个接口，两层循环也就8w不到的事件啊<ul><li>验证：将线上数据拷贝下来，本地测试，产生6000+的事件也不到8w啊？debug后才知道，两层嵌套循环符合条件的只有77个（业务问题不需要关心），77*77+外层循环生产的事件刚好6000+数量级，这和线上的百万数量级差好多哦，这多出来的是从哪来的呢</li><li>想了两天没有结果，忍不住了，我找到用户的联系方式直接问，原来操作了20多个实例，发现用户操作的日志超长了，后面的内容截断了，让我以为就操作了一个实例</li><li>验证：按照25个实例来算，每个实例两层循环需要重新计算外层循环x内存循环（25x77）x（25x77）结果证实300w+的数量级，破案</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要问题还是迁移系统之后jvm设置的内存有问题，连带找出其他bug（以外收获）</p><ol><li>封装事件代码有问题，两层嵌套循环产生很多重复事件（不是说之前写代码的人太水，而是业务复杂，刚好用户的数据结构特殊导致产生大量重复事件）</li><li>用户操作的日志记录不完整，误导了排查错误的方向，这是个风险</li><li>jvm内存设置的有问题，即使上面两个问题不修改，源码8g内存都用上的话运行5年的话也不会出问题</li><li>直接查看jvm的配置或者找用户了解情况就不会走这么多弯路，这条里就是经验了，本文的精华都在这一句了</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;菜鸟遇到线上问题，从第一次发现问题到问题解决用时2个月，也算是个记录吧，哈哈，本文记录下我解决问题的心路历程，也不是什么高级的问题，大神请绕路&lt;/p&gt;
&lt;h3 id=&quot;第一次问题&quot;&gt;&lt;a href=&quot;#第一次问题&quot; class=&quot;headerlink&quot; title=&quot;第一次
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>AQS分析</title>
    <link href="http://yoursite.com/2020/05/20/AQS%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/05/20/AQS分析/</id>
    <published>2020-05-20T09:16:07.000Z</published>
    <updated>2021-07-13T12:27:08.581Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AQS-AbstraceQueuedSynchronizer"><a href="#AQS-AbstraceQueuedSynchronizer" class="headerlink" title="AQS AbstraceQueuedSynchronizer"></a>AQS AbstraceQueuedSynchronizer</h3><ul><li>维护了一个共享变量state（int类型被volatile修饰保证线程的可见性）</li><li>通过不同线程修改state的状态来决定线程获取锁的状态，并将这些线程维护在一个队列里，每个线程都封装成一个Node对象</li><li>Node中定义了线程的状态 复制表示Node处于有效的等待状态，正值表示Node被取消<ul><li>CANCELLED（1） 当前Node已经取消调度，超时或中断会变更为次状态，进入该状态后的Node不再变化</li><li>SIGNAL（-1）表示后继Node等待当前Node唤醒，后继Node入队，会修改前驱Node状态为SIGNAL</li><li>CONDITION（-2）表示Node等待在Condition上，其他线程调用signal()方法后，CONDITION的Node会从等待队列中转移到同步队列，等待获取同步锁</li><li>PROPAGATE（-3）共享模式下，前驱节点不仅会唤醒后继Node，还可能唤醒后继的后继Node</li><li>0 新节点入队时的默认状态</li></ul></li><li>定义了独占（Exclusive）和共享（share）两种对state的使用方式</li></ul><ol><li>独占 exclusive 只能一个线程操作state；使用 acquire-relase 方法获取和释放资源<ul><li>acquire<ul><li>tryAcquire 根据需要具体实现 尝试获取资源，成功返回true，失败返回false</li><li>获取资源失败，将当前线程入队，找到安全点进入等待状态</li><li>当被唤醒后判断自己是否是队列中的老二，不是老二找到安全点进入等待状态；是老二尝试获取资源，获取失败继续进入等待状态，等待别唤醒</li></ul></li><li>relase<ul><li>tryRelase 根据需要具体实现 尝试释放资源，成功返回true，失败返回false</li><li>当资源全部被释放后（state=0，可能被重入state的值大于0）会唤醒队列中的老二来获取资源</li></ul></li></ul></li></ol><p><img src="/images/acquire-relase.png" alt="upload successful"></p><ol start="2"><li>共享 share 多个线程可以同时操作state；使用 acquireShared-relaseShared 方法获取和释放资源<ul><li>acquireShared<ul><li>tryAcquireShared 根据需要具体实现 尝试获取资源，负数表示失败；正数表示成功，数值表示剩余的资源数量</li><li>获取资源失败，将当前线程入队，入队后如果是老二节点尝试获取资源，老二节点获取资源成功，根据剩余资源量唤醒后面的线程</li><li>不是老二节点或者老二节点获取资源失败，找到安全点进入等待状态，等待被唤醒</li></ul></li><li>relaseShared<ul><li>tryRelaseShared 根据需要具体实现 尝试释放资源，成功返回true，失败返回false</li><li>释放资源成功就去唤醒队列中的老二，老二被唤醒尝试获取资源进入到acquireShared中的第二步</li></ul></li></ul></li></ol><p><img src="/images/acquireShared-relaseShared.png" alt="upload successful"></p><p><strong>总结</strong></p><p>AQS其实是一个抽象的基于队列同步器（正如其名称所示，但是并没有使用抽象方法，而是将可扩展的方法默认抛出异常，留给子类去重写覆盖，可能是考虑到单独扩展共享模式或者独占模式，只需实现两个方法即可，不需要全都重写，根据需要选择重写，这样更灵活一些），其中封装了独占模式和共享模式下获取和释放资源的方法，其中没有给出tryAcquire-tryRelase和tryAcquireShared-tryRelaseShared的具体实现，可以根据需要重写这些方法即可，不需要去关心队列中线程的状态变化；比如ReentrantLock就是重写了独占模式中的方法实现；CountDownLatch是重写了共享模式中的方法实现</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock中重写了tryAcquire和tryRelase，所有是独占模式，所以ReentrantLock是独占锁并且是可重入的，其中分别有公平和非公平两种实现，默认是非公平的</p><h4 id="公平"><a href="#公平" class="headerlink" title="公平"></a>公平</h4><ol><li>lock() -&gt; acquire(1) 获取锁（修改资源的状态为1）其中使用的时AQS的实现</li><li>重写了tryAcquire方法，<em>如果资源状态是空闲（state=0）并且队列中没有等待资源的线程，才会去获取资源</em>；如果是当前线程获取资源，直接修改状态并获得锁成功（state += n；可重入；）；其他情况返回false获取资源失败</li><li>之后就是AQS中的逻辑 入队、等待被唤醒 balabala…</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 公平锁的实现 Sync继承了AQS</span><br><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line"></span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);// 获取资源，调用AQS中的 acquire(1) 方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // AQS中的 acquire 方法调用了 tryAcquire 方法，在这里重写执行</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            // 当前资源空闲并且队列中没有等待资源的线程才会去CAS获取资源</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;// 如果是当前线程直接修改资源，返回成功；可重入</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        eturn false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非公平"><a href="#非公平" class="headerlink" title="非公平"></a>非公平</h4><ol><li>lock -&gt; 抢占锁（CAS修改资源状态） -&gt; 抢锁失败调用acquire(1)获取锁，同样适用AQS的实现</li><li>重写了tryAcquire方法，<em>如果资源状态是空闲（state=0）就CAS修改状态的值获取资源</em>；如果是当前线程获取资源，修改状态获取资源成功（与公平锁相同，CAS修改state，可重入）；其他情况返回false获取资源失败</li><li>（相同逻辑）入队、等待被唤醒 balabala…</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// Sync继承了AQS</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    </span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        // lock的时候抢占一次资源</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);// 没抢占到调用 acquire 方法（AQS中）</span><br><span class="line">    &#125;</span><br><span class="line">    // AQS中的 acquire 方法调用了 tryAcquire 方法，在这里重写执行</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquire(acquires);// 父类中实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;// 与公平锁的实现不同，这资源空闲会再抢占一次资源</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;// 与公平锁一样 可重入</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>公平锁和非公平锁释放资源都使用的父类中的 tryRelase 方法，简单的逻辑，确认当前线程在占用资源后cas修改资源的状态，返回资源是否空闲（state==0?）其他逻辑和AQS中的 relase 相同</li><li>可以看到斜体的地方就是公平锁和非公平锁的区别，在资源状态空闲的时候，非公平锁会去抢占资源而公平锁判断队列中没有等待资源的线程才会去获取资源；还有在Acquire之前非公平锁会去抢占一次资源；非公平锁会在lock的时候抢占资源，没有抢到会执行tryAcquire方法，如果此时刚好资源被释放还会去抢占一次资源，都失败了就会入队进入等待状态</li></ol><h3 id="共享模式的实现"><a href="#共享模式的实现" class="headerlink" title="共享模式的实现"></a>共享模式的实现</h3><p>本来想找一个共享模式的实现来分析一下，在AQS中查到实现有这么几个，Semaphore、CountDownLatch和ReentrantReadWriteLock，前两个比较简单来分析一下，后一个比较复杂段时间还搞不定（柿子要挑软的捏是不是？这里再挖个坑吧）</p><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>Semaphore用来控制线程的并发量，指定并发量就是Semaphore中的许可，拿到许可可以运行，没有拿到许可进入等待状态，有释放的许可唤醒等待的线程，保证线程运行的数量，类似于令牌桶的亚子；其中重写了 tryAcquireShared 和 tryRelaseShared 方法，所以Semaphore是共享模式的实现，同样有公平和非公平两种方式，默认非公平的；</p><ol><li>acquire 获取许可 -&gt; 调用 acquireSharedInterruptibly 方法，与acquireShared不同的是先判断线程的中断状态，如果中断抛异常，</li><li>调用 tryAcquireShared 方法获取资源（公平模式下线判断队列中是否有等待资源的线程，有则返回-1表示失败；没有返回剩余资源数量，获取资源成功；非公平模式下不用判断队列是否有线程直接去获取资源，返回剩余的资源），后面同AQS中的逻辑 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 构造方法初始化AQS的state为permit的数量</span><br><span class="line">public Semaphore(int permits) &#123;</span><br><span class="line">    sync = new NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line">// 转调AQS中 acquireSharedInterruptibly 方法</span><br><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);// AQS中的实现</span><br><span class="line">&#125;</span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)// 这里调用 tryAcquireShared 方法</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125; </span><br><span class="line">// 非公平模式下转调 nonfairTryAcquireShared 方法</span><br><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;// 获取资源后的余量</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))// 余量大于0 CAS修改状态获取资源成功 否则执行AQS中剩下的逻辑 入队、等待...</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 公平模式下直接重写 tryAcquireShared 方法</span><br><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (hasQueuedPredecessors())// 比非公平模式多了判断队列中是否有等待的线程</span><br><span class="line">            return -1;</span><br><span class="line">        int available = getState();</span><br><span class="line">        int remaining = available - acquires;</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// relase 方法转调AQS中的 relaseShared 方法</span><br><span class="line">public void release(int permits) &#123;</span><br><span class="line">    if (permits &lt; 0) throw new IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);// 其中调用 tryRelaseShared 方法</span><br><span class="line">&#125;</span><br><span class="line">// 重写 tryRelaseShared 方法(公平非公平相同) 循环CAS改变状态，判断边界范围</span><br><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current = getState();</span><br><span class="line">        int next = current + releases;</span><br><span class="line">        if (next &lt; current) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(current, next))</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch通常用来判断多个线程是否都执行完毕，初始化的时候将AQS中的state设置为等待的线程数量（n），表示资源被n个线程获取；</p><ol><li>await方法转调acquireSharedInterruptibly其中又转调 tryAcquireShared ，返回state是否为0，因为初始化为n所以不为0返回-1，表示获取资源失败将线程入队等待</li><li>线程执行完毕后调用countDown方法，转调relaseShared方法将资源的数量减一，当所有线程都调用了countDown此时资源被完全释放（state=0）线程被唤醒，再次 tryAcquireShared 获取state为0返回0，表示获取资源成功，执行后面的逻辑</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 构造方法初始化AQS的state为count；Sync继承AQS</span><br><span class="line">public CountDownLatch(int count) &#123;</span><br><span class="line">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">    this.sync = new Sync(count);</span><br><span class="line">&#125;</span><br><span class="line">// 转调AQS中 acquireSharedInterruptibly 方法</span><br><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);// AQS中的实现</span><br><span class="line">&#125;</span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)// 这里调用 tryAcquireShared 方法</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line">// 重写了 tryAcquireShared 方法</span><br><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    // state为0返回1表示获取资源成功，不为0返回-1表示获取资源失败</span><br><span class="line">    // 由于刚刚初始化了state=count，假设当前还没有释放资源，state不为0返回-1表示失败，后面就是AQS中的逻辑，入队、等待...</span><br><span class="line">    return (getState() == 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br><span class="line">// countDown 方法转调 relaseShared 方法</span><br><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);// AQS中的实现 其中调用了 tryRelaseShared 方法</span><br><span class="line">&#125;</span><br><span class="line">// 重写了 tryRelaseShared 方法，如果state-1之后还不为0返回false表示释放失败，其实是成功的，返回失败是因为还要等待其他线程</span><br><span class="line">// 先不去唤醒等待的线程，当释放资源后state为0返回成功，这时候再去唤醒等待的线程</span><br><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    // 循环CAS操作将state-1</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0)</span><br><span class="line">            return false;</span><br><span class="line">        int nextc = c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">Java并发之AQS详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;AQS-AbstraceQueuedSynchronizer&quot;&gt;&lt;a href=&quot;#AQS-AbstraceQueuedSynchronizer&quot; class=&quot;headerlink&quot; title=&quot;AQS AbstraceQueuedSynchronizer&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal分析</title>
    <link href="http://yoursite.com/2020/05/19/ThreadLocal%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/05/19/ThreadLocal分析/</id>
    <published>2020-05-19T13:08:37.000Z</published>
    <updated>2021-07-13T12:27:08.588Z</updated>
    
    <content type="html"><![CDATA[<p>废话不说，直接开整，上源码</p><p>Java中每个Thread类中都有属于自己的私有map（ThreadLocalMap key是ThreadLocal的弱引用），不同线程之间的map是私有的相互隔离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    ...</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><ol><li>计算hash值，找到table中对应的位置，key是null直接放入，key相同替换，key冲突后向后查找直到找到可以插入的地方<ul><li>从这个插入的方式可以看出，table中的桶对应一个entry，与HashMap中的链表或者红黑树不同，而且到达3/4的容量就会扩容，所以不会存在，桶中有链表或者红黑树的数据结构</li></ul></li><li>插entry后 cleanSomeSlot  从当前插入entry的位置，往后扫描找key为null的entry，找logn次（who tell me 这是 why？）找到key为null的entry（可能1个可能多个） expungeStaleEntry(i) 方法清理<ul><li>expungeStaleEntry(i) 清理从i开始往后到下一个entry是null之间的位置</li></ul></li><li>如果找到key为null的entry，并且经过清理之后tab的数量还大于扩容的阈值，调用 rehash 方法扩容<ul><li>expungeStaleEntries() 清理整个table中key是null的entry，清理之后tab的size大于扩容的阈值 进行 resize （扩容的逻辑）</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value); // 进入这里</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line"></span><br><span class="line">    for (Entry e = tab[i];</span><br><span class="line">         e != null;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">  // key相同替换 返回</span><br><span class="line">        if (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // key为null替换 返回</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到entry为null的位置插入</span><br><span class="line">    tab[i] = new Entry(key, value);</span><br><span class="line">    int sz = ++size;</span><br><span class="line">    // cleanSomeSlots清理一部分entry后size还大于阈值进行扩容</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 如函数名所说，清理一部分Solts（key为null的entry），具体的说清理从i到下一个entry是null之间的部分</span><br><span class="line">private boolean cleanSomeSlots(int i, int n) &#123;</span><br><span class="line">    boolean removed = false;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    do &#123;</span><br><span class="line">        i = nextIndex(i, len);// 从i开始往下遍历，遍历logn次</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        if (e != null &amp;&amp; e.get() == null) &#123;// 找到key是null的entry</span><br><span class="line">            n = len;</span><br><span class="line">            removed = true;</span><br><span class="line">            i = expungeStaleEntry(i);// 清理从i开始到entry为null的位置 并且对key不为null的entry做rehash 代码就不贴了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ( (n &gt;&gt;&gt;= 1) != 0);// 每次n/2 遍历logn次</span><br><span class="line">    return removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><ol><li>调用threadLocalMap中的getEntry方法，通过hash值找到tab中的位置，当前位置没找到调用 getEntryAfterMiss 方法</li><li>getEntryAfterMiss 从当前位置往后找到key的entry返回</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">Thread t = Thread.currentThread();</span><br><span class="line">ThreadLocalMap map = getMap(t);</span><br><span class="line">if (map != null) &#123;</span><br><span class="line">    ThreadLocalMap.Entry e = map.getEntry(this);// 进入这里看看</span><br><span class="line">    if (e != null) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        T result = (T)e.value;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return setInitialValue();// map为空set初始值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">        return getEntryAfterMiss(key, i, e); // hash后的位置没找到key</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">// 从当前位置向后找 过程中遇到key为null的 entry 调用expungeStaleEntry(i)进行清理</span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line"></span><br><span class="line">    while (e != null) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        if (k == key)</span><br><span class="line">            return e;</span><br><span class="line">        if (k == null) // 遇到key是null的entry进行清理</span><br><span class="line">            expungeStaleEntry(i);// 与set过程中调用同一方法，清理从i到下一个key为null节点之间的位置</span><br><span class="line">        else</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存溢出问题"><a href="#内存溢出问题" class="headerlink" title="内存溢出问题"></a>内存溢出问题</h3><ul><li>ThreadLocal的结构如图所示，因为new ThreadLocal对象，所有栈中有ThreadLocal的强引用，而ThreadLocalMap中key是ThreadLocal的弱引用，如果将ThreadLocal对象置为null，则ThreadLocal只有弱引用指向它，当下次gc的时候key会被回收掉</li></ul><p><img src="/images/ThreadLocal.png" alt="upload successful"></p><ul><li>如果当前线程没有退出，value依然有强引用指向它，所以value并不会被回收，虽然经过分析源码使用get和set方法会清理map中的key为null的一部分节点清理掉，但是在调用get和set之前仍然存在oom的风险</li><li>最稳妥的就是使用remove方法，将不需要的ThreadLocal清理掉</li><li>不要和线程池一起使用，线程池中的线程是复用的，永远不会被销毁，所以线程中的ThreadLocalMap也不会被清理，如果这个线程一直不被使用或者不在调用get和set方法，这块内存永远不会被回收</li></ul><h3 id="挖坑"><a href="#挖坑" class="headerlink" title="挖坑"></a>挖坑</h3><ul><li>根据nextIndex方法里的实现来看，这个结构是一个环形结构</li></ul><pre><code>private static int nextIndex(int i, int len) {    return ((i + 1 &lt; len) ? i + 1 : 0);}</code></pre><ul><li><a href="https://mp.weixin.qq.com/s/vURwBPgVuv4yGT1PeEHxZQ" target="_blank" rel="noopener">参考文献</a>中所说，hash算法使用黄金分割数，大大降低了hash冲突的几率，具体怎么降低的先挖个坑后面再填</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://mp.weixin.qq.com/s/vURwBPgVuv4yGT1PeEHxZQ" target="_blank" rel="noopener">一篇文章彻底了解ThreadLocal的原理 </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;废话不说，直接开整，上源码&lt;/p&gt;
&lt;p&gt;Java中每个Thread类中都有属于自己的私有map（ThreadLocalMap key是ThreadLocal的弱引用），不同线程之间的map是私有的相互隔离&lt;/p&gt;
&lt;figure class=&quot;highlight plai
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>get限流姿势</title>
    <link href="http://yoursite.com/2020/05/14/get%E9%99%90%E6%B5%81%E5%A7%BF%E5%8A%BF/"/>
    <id>http://yoursite.com/2020/05/14/get限流姿势/</id>
    <published>2020-05-14T13:06:35.000Z</published>
    <updated>2021-07-13T12:27:08.589Z</updated>
    
    <content type="html"><![CDATA[<p>限流通常用作服务的降级策略，以牺牲一部分请求的方式换来系统的部分可用；在高并发的场景下保护系统不会挂掉，比如大促、秒杀这类的场景保护像交易这样的核心服务可用，通过学习限流的代码之后，掌握了通常的限流姿势，分享一下</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>类似于滑动窗口，给定一个时间段的最大请求数（窗口，比如1秒最多100个请求），再将窗口设置多个小段（一个时间的偏移量，比如100ms，一个窗口就被分成了10小段）每一小段记录当前正在处理的请求数量，每次移动一小段，滑出的一段中的请求数量被释放，新进入窗口的一段最多可以处理被释放的请求数量</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>简单粗暴好实现，偏移量取值越小限流越精细，每次滑动需要获取当前一段中的请求数，计算窗口中的总的请求数是否超过限定值</li><li>如果在中间一小段涌入大量请求到达限定值，那就需要等待这段滑出窗口后才能处理新的请求，从宏观的角度来说，可以保证窗口期内的平均处理请求的量，但是从微观来看处理请求的方式不均衡，存在风险</li></ul><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>一个破桶一边以一个速度漏水（处理请求）一边以一个速度往里加水（新的请求到来）；假设向桶里加水的速度很快（大量新的请求到来）一会就把桶占满了，此后再向桶里加水就会漏出去（新的请求会被丢弃）</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 生产者和消费者</span><br><span class="line">// 用阻塞队列来实现桶</span><br><span class="line">BlockingQueue bucket = new BlockingQueue(MAX_SIZE);</span><br><span class="line">// 请求来 -&gt; 入队</span><br><span class="line">if (!bucket.offer();&#123;</span><br><span class="line">    // 大于桶的最大值入队失败，做进一步操作（拒绝、保存到mq或者db中）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">    bucker.take();</span><br><span class="line">    // 出队成功 异步处理请求 等待下一个周期后再次从队列中获取请求，队列为空阻塞在原地</span><br><span class="line">    sleep(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>通过计算每次请求的最小时间间隔，当大量的请求到来时让系统以一个恒定的速度去处理请求，保护系统不会被超过本身处理能力的请求打挂</li><li>不足之处是不够优雅；当某个时间点有大量的请求到来很快将桶塞满，多于的请求直接丢弃，而突然有大量请求的场景有很多（例如秒杀，大促等）这些都是正常的请求，不应该被丢弃；</li></ul><h3 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h3><p>以一个速度向桶里生产令牌，当桶内令牌满了时将暂停生产，处理请求需要从桶里拿到令牌才可以，如果桶里没有令牌拒绝该请求（通常的做法是返回一个限流信息，类似于非阻塞的方式）</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 一个请求周期的类</span><br><span class="line">class Cycle&#123;</span><br><span class="line">    lastTime;// 上一次请求的时间戳</span><br><span class="line">    curTokenCount;// 当前桶内有效token数量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean getLicense() &#123;</span><br><span class="line">// 是否可以执行请求</span><br><span class="line">boolean license = false;</span><br><span class="line">do &#123;</span><br><span class="line">    // 请求到来，计算从限流开始到现在的时间间隔，通过当前时间戳-开始时间戳</span><br><span class="line">curTime = currentTime - startTime;</span><br><span class="line">// 计算从上一次请求开始到现在的时间间隔，lastTime是从限流开始到上一次请求的时间间隔</span><br><span class="line">curDuration = curTime - lastTime;</span><br><span class="line">// 计算这段时间产生的令牌数量</span><br><span class="line">incrementTokenCount = curDuration * createTokenSpeed;</span><br><span class="line">// 计算当前时间内有效的token数量 curTokenCount是当前桶里的token数量</span><br><span class="line">curTokenCount = Min(maxTokenCount, currentTokenCount + incrementTokenCount);</span><br><span class="line">// 如果有效的token数量大于0，数量减一处理请求，</span><br><span class="line">if (curToken &gt; 0) &#123;</span><br><span class="line">    incrementTokenCount--;</span><br><span class="line">    license = true;</span><br><span class="line">&#125; </span><br><span class="line">lastTime = curTime;</span><br><span class="line">&#125; while (!CAS(curCycle, new Cycle(lastTime, curTokenCount)));// CAS操作设置当前请求周期为下一个周期，操作成功进入下一周期，返回是否可以执行请求</span><br><span class="line">// 要进入下一周期需要CAS操作lastTime和curTokenCount两个变量，分别CAS不能保证一致性，所以封装成一个对象做CAS操作</span><br><span class="line">return license;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li>相较与漏桶算法，令牌桶可以应对一些突发流量的变大，最大同时处理令牌桶中最大令牌数量的请求，所有设置令牌桶中最大令牌数量要非常小心，否则会把服务器压垮</li><li>Guava中实现了漏桶算法的限流器，还具有一定的超额消费的能力，更灵活了一下，具体实现原理也差不多，可以直接用</li></ul><p>以上是单机模式下的限流实现，只需要拦截每次请求，执行上面的逻辑根据是否满足条件决定处不处理请求，分布式环境下的限流可以使用lua+redis来实现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;限流通常用作服务的降级策略，以牺牲一部分请求的方式换来系统的部分可用；在高并发的场景下保护系统不会挂掉，比如大促、秒杀这类的场景保护像交易这样的核心服务可用，通过学习限流的代码之后，掌握了通常的限流姿势，分享一下&lt;/p&gt;
&lt;h3 id=&quot;计数器&quot;&gt;&lt;a href=&quot;#计数器
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>初识Guava Cache</title>
    <link href="http://yoursite.com/2020/05/11/%E5%88%9D%E8%AF%86Guava%20Cache/"/>
    <id>http://yoursite.com/2020/05/11/初识Guava Cache/</id>
    <published>2020-05-11T11:37:37.000Z</published>
    <updated>2021-07-13T12:27:08.592Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>随着系统的膨胀，数量越来越大，统计报表的相关SQL会非常慢，代表的SQL是这样，需要统计两张表中不重复的ip，大概是2000w两级，只能两张表分别distinct，最后union的时候再distinct一下，没想到更好的办法，只能加缓存了</p><ul><li>考虑过使用Redis，这是常规的做法，可是要缓存的数据很少，结构简单，访问量不大通常是管理员来查看统计一下产品的使用情况，使用Redis逻辑复杂，还要考虑缓存击穿，缓存雪崩的情况，还依赖于Redis的可用性，所以决定舍弃该方案，使用Guava Cache来做缓存，并在时间间隔内进行缓存数据的更新<ul><li>Guava Cache虽然提供缓存的过期时间，但是只有在过期之后的一次get才会进行缓存的更新，而且如果获取缓存的时间很长会造成阻塞，这样缓存的意义就没了；</li><li>如果设置成异步刷新缓存，可以解决阻塞的问题，但是得到的时上一个时间周期的数据，缓存的实时性不能保证；</li><li>最终采用开启定时的线程，在每个时间周期内异步刷新缓存数据，最坏的情况是得到上一个时间周期的数据，但是可以解决上一条中多次点击才会刷新的点，这里还有一个风险点，如果多个服务器在同一时间启动，就会在相同的时间间隔去请求数据库计算数据并更新，可能造成数据库CPU忙碌状态，我的环境是4台服务器，并发的去请求数据库是没问题的，而且通常都是滚动更新，所以不会出现这个问题，综合评估后采用该方案</li></ul></li><li>实现<ul><li>在Spring容器启动完毕的时候（这里有个坑，因为spring容器没有启动完成是不能与数据库建立连接的，所以在spring容器启动过程中就加载缓存是不行的），开启线程统计数据（要查从库避免锁表）</li><li>再通过定时任务异步去刷新数据</li></ul></li></ul><h4 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h4><ul><li>编码过程中那个通常缓存的实现是定义一个全局变量，多个线程都可以访问到，并可以对该变量进行修改；当然需要用到线程安全的数据结构，比如ConcurrentHashMap，但是缓存的更新删除，这些逻辑的自己实现，而我理解的Guava Cache就是封装了这些逻辑并提供出API的一个工具</li><li>缓存过期的设置方式</li><li>设置缓存的大小，超过阈值的删除（这里指的是缓存的数量，key的数量）</li><li>设置缓存的时间，超过时间的删除<ul><li>不是定时去判断的，而是get的时候会判断是否超时，超时就重新加载，这样如果刷新key的用时很长的话会阻塞；Guava Cache也提供了异步刷新key的方式，这样如果对缓存更新实时性要求高的话，在缓存刷新后重新get才能获得最新的缓存值；或者用一个定时任务异步刷新key</li></ul></li><li>设置弱引用，让垃圾收集器来回收</li><li>显式的删除key</li><li>可以添加key被删除的监听器</li></ul><p>使用了类似jdk1.7中ConcurrentHashMap的Segment的结构，降低锁的粒度提高并发的吞吐量；再通过两次hash找到value的位置</p><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><ul><li>强引用<ul><li>通过 new 关键字产生，不会被JVM回收；如果是局部变量，引用保存在线程栈中，方法结束引用被依赖的数量为0，将会被JVM回收掉；如果是全局变量，引用将一直会存在，可以将引用设置为null被JVM回收</li></ul></li><li>软引用<ul><li>内存充足时不会被回收，当内存空间不足会被回收</li></ul></li><li>弱引用<ul><li>JVM进行垃圾回收的时候就会被回收掉，如果长时间不进行垃圾回收就会一直存在</li></ul></li><li>虚引用<ul><li>必须与引用队列一起使用，在JVM进行垃圾回收之前，虚引用会被加入到引用队列中</li></ul></li><li>引用队列<ul><li>可以和软引用，弱引用，虚引用联合使用，在JVM进行垃圾回收之前，要被回收的引用会被加入到队列中，用来查看JVM垃圾回收情况 </li></ul></li></ul><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ul><li>HashMap</li><li>jdk1.7 数组+链表的结构 当有hash冲突的时候链表会很长，查询一个节点效率很低，时间复杂度为O(N)</li><li>jdk1.8 数组+红黑树的结构 链表中节点大于8时会转成红黑树，查询时间复杂度为O(logN)<ul><li>put <ul><li>判断是否需要扩容（resize）或者初始化（懒加载）</li><li>通过hash找到桶，没有冲突直接放入；</li><li>有hash冲突，a.判断是否和第一个Node的key相同，相同则覆盖value；b.判断是否是红黑树，插入value相同key覆盖 c.判断是否需要转红黑树，需要则红黑树插入，否则插入链表末尾，相同key覆盖value，</li><li>插入value后判断是否需要扩容</li></ul></li><li>get 根据hash值找到桶，从桶中找key对应的value，没有返回null</li><li>resize 1.8不会进行重新hash，而是看hash值新增的那个bit位是1还是0，0位置不变，1的话位置是原位置+扩容前容量 索引中的位置，由于hash值新增的那个bit为可以认为是随机的，所以可以将原来桶中的链表或者红黑树均匀的拆分成两个链表或者红黑树</li></ul></li><li>线程不安全问题<ul><li>1.7 可能丢失key，还会出现循环链表，当get一个不存在的key出现死循环</li><li>1.8 由于table中size变量没有加volatile关键字，多线程++size时可能覆盖以前的记录</li><li>线程不安全主要是由于resize方法导致，1.7先rehash转移数据在改数组的引用，而且转移数据后链表会反转多线程并发修改引用会造成循环链表的现象；1.8先改数组的引用再转移数据，并且转移数据不会修改链表的结构，理论上不会造成循环引用，但当多线程并发操作会出现数据丢失的现象</li></ul></li><li>concurrentHashMap</li><li>1.7 引入segment的概念，将整个table划分成若干个segment，对segment加锁减小锁的粒度提高吞吐量，get的时候先通过hash找到segment，再找到对应的table中的位置</li><li>1.8 对Node加锁进一步减小了锁的粒度提高吞吐量，加入多线程扩容的逻辑加速扩容的过程，put操作时发现正在扩容可以帮助扩容，而不是阻塞起来傻等<ul><li>扩容的逻辑很复杂，整理一下大概的逻辑吧，首先将CAS操作将table扩容，根据原来table的大小将扩容工作拆成多个任务，每个任务最少迁移16个桶，当线程完成扩容任务会继续领取下一个任务进行扩容</li><li>多线程领取任务开始扩容，安装索引从大到小的顺序开始，扩容过程中get操作，会get到ForwardNode，转发到新的table中查找value；扩容过程中put操作，如果当前扩容的线程数量小于最大限制的数量就加入扩容的队列中，否则阻塞</li><li>put 使用synchronized关键字对Node加锁；当Node中的链表大于8，如果当前容量没有超过64先进行扩容，否则才转红黑树；扩容过程中红黑树节点小于6个转链表</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;随着系统的膨胀，数量越来越大，统计报表的相关SQL会非常慢，代表的SQL是这样，需要统计两张表中不重复的ip，大概是2000w两级，只能两张
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>将Hexo博客迁移到docker中（究极解决方案）</title>
    <link href="http://yoursite.com/2020/04/19/%E5%B0%86Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0docker%EF%BC%88%E7%A9%B6%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89/"/>
    <id>http://yoursite.com/2020/04/19/将Hexo博客迁移到docker（究极解决方案）/</id>
    <published>2020-04-19T00:47:36.000Z</published>
    <updated>2021-07-13T12:27:08.593Z</updated>
    
    <content type="html"><![CDATA[<p>前两个阶段是两个月前的试验版本，只是在本机上用docker模拟并没有真正做迁移，然而在真正迁移的过程中，虽然可以完整迁移，但是体验不友好，我改进了迁移方案，首先总结一下缺点吧</p><ul><li>启动容器后需要进入容器中，启动nginx做转发</li><li>如果不使用也需要进入容器中启动hexo，且不能退出否则hexo也会跟着退出<ul><li>后台启动需要依赖pm2这个工具</li><li>后台启动hexo和nginx会不会有资源争抢的问题，这个应该没有纯属给自己加戏</li></ul></li><li>修改文章后即使做了文件挂载也需要进入容器中重新生成静态文件</li></ul><p>图解一下，原来的方案和现在的方案</p><p><img src="/images/pasted-33.png" alt="upload successful"></p><p>可以看到原来是塞到一个docker容器中的，中间的图是现在的架构，将nginx和hexo拆分，分别放入docker中，nginx的docker转发请求到hexo的docker，hexo的docker需要运行hexo s；未来如果我有新的网站可以重新部署一个容器通过nginx做转发，比如，不同域名转发到不同的容器，或者我再搞一个WordPress版本的docker，还可以做金丝雀发布，ab测试。哈哈</p><p>下面开始动手</p><h4 id="先从nginx开始"><a href="#先从nginx开始" class="headerlink" title="先从nginx开始"></a>先从nginx开始</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 直接拉取nginx镜像</span><br><span class="line">docker pull nginx</span><br><span class="line"># 修改配置文件运行 把配置文件做目录挂载 绑定80端口</span><br><span class="line">docker run -di nginx --name nginx -v /usr/local/temp/nginx.conf:/etc/conf/nginx/nginx.conf -p 80:80 nginx</span><br><span class="line"># 之后配置有变化修改 nginx.conf 后 docker restart 即可</span><br></pre></td></tr></table></figure><h4 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h4><p>与之前的版本不同的是，我要在容器启动的时候就把hexo运行起来，每次修改文件后docker restart就能重新生成静态文件并启动hexo</p><p>坑点</p><ul><li>刚开始我再dockerfile中添加命令 CMD[‘hexo’,’s’]</li><li>编译好的镜像run了之后并没有启动，查看状态run了之后就退出了</li><li>我的第一反应是不是要后台启动才可以，随即有尝试使用 pm2 后台启动，修改命令CMD[‘pm2’,’start’,’run.js’]</li><li>还是不行呢，冷静下来发现不管是hexo还是pm2都是nodejs中的命令，而dockerfile中运行的应该是sh脚本</li><li>于是转换思路 dockerfile中启动shell脚本，脚本中运行hexo 修改命令 CMD [“/usr/local/myblog/buildbak/run.sh”]</li><li>还有一个小坑，运行起来会报没有权限的错误 再添加命令赋权 重新build就完成了 chmod 777 /usr/local/myblog/buildbak/run.sh</li></ul><p>run.sh 很简单，每次clean后重新生成静态文件再启动hexo，这样每次新增或者修改博客的时候restart就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">cd /usr/local/myblog;</span><br><span class="line">hexo clean;</span><br><span class="line">hexo g;</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>完整dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER yywang sbsbjs@qq.com</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">RUN yum update -y &amp;&amp; yum install -y wget git-core vim* gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel \</span><br><span class="line"></span><br><span class="line"># 安装nodejs</span><br><span class="line"></span><br><span class="line"># 新建目录 </span><br><span class="line">WORKDIR /usr/local</span><br><span class="line"># 下载tar</span><br><span class="line">RUN wget https://nodejs.org/dist/v12.15.0/node-v12.15.0-linux-x64.tar.xz \</span><br><span class="line"># 解压</span><br><span class="line">&amp;&amp; tar -xvf node-v12.15.0-linux-x64.tar.xz \</span><br><span class="line">&amp;&amp; mv node-v12.15.0-linux-x64 node_12.15.0 \</span><br><span class="line">&amp;&amp; mkdir /usr/local/nodejs \</span><br><span class="line">&amp;&amp; mv node_12.15.0 /usr/local/nodejs/ \</span><br><span class="line">&amp;&amp; rm -rf node-v12.15.0-linux-x64.tar.xz \</span><br><span class="line"># 部署bin文件</span><br><span class="line">&amp;&amp; ln -s /usr/local/nodejs/node_12.15.0/bin/node /usr/local/bin/node \</span><br><span class="line">&amp;&amp; ln -s /usr/local/nodejs/node_12.15.0/bin/npm /usr/local/bin/npm \</span><br><span class="line"># 修改npm源</span><br><span class="line">&amp;&amp; npm config set registry https://registry.npm.taobao.org \</span><br><span class="line"># 安装hexo</span><br><span class="line">&amp;&amp; npm install -g hexo-cli \</span><br><span class="line"></span><br><span class="line"># 配置环境变量</span><br><span class="line">&amp;&amp; ln -s /usr/local/nodejs/node_12.15.0/bin/hexo /usr/local/bin/hexo \</span><br><span class="line"># 创建网站文件夹</span><br><span class="line">&amp;&amp; mkdir /usr/local/myblog \</span><br><span class="line">&amp;&amp; cd /usr/local/myblog \</span><br><span class="line"># 初始化hexo</span><br><span class="line">&amp;&amp; hexo init \</span><br><span class="line">&amp;&amp; hexo generat \</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">RUN yum update -y &amp;&amp; yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make \</span><br><span class="line"># 备份原始的python</span><br><span class="line">&amp;&amp; mv /usr/bin/python /usr/bin/python.bak \</span><br><span class="line"># 下载解压</span><br><span class="line">&amp;&amp; cd /usr/local \</span><br><span class="line">&amp;&amp; wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz \</span><br><span class="line">&amp;&amp; tar -xvJf  Python-3.6.2.tar.xz \</span><br><span class="line"># 编译安装</span><br><span class="line">&amp;&amp; cd Python-3.6.2 \</span><br><span class="line">&amp;&amp; ./configure prefix=/usr/local/python3 \</span><br><span class="line">&amp;&amp; make &amp;&amp; make install \</span><br><span class="line">&amp;&amp; rm -rf /usr/local/Python-3.6.2.tar.xz \</span><br><span class="line"># 添加软链</span><br><span class="line">&amp;&amp; ln -s /usr/local/python3/bin/python3 /usr/bin/python3 \</span><br><span class="line">&amp;&amp; ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 \</span><br><span class="line"># 安装依赖</span><br><span class="line">&amp;&amp; pip3 install Pillow \</span><br><span class="line"># 迁移博客 由于clone速度极其慢，而且还需要添加git秘钥，改用本地先clone好复制过去</span><br><span class="line">&amp;&amp; rm -rf /usr/local/myblog</span><br><span class="line">COPY myblog /usr/local/myblog/</span><br><span class="line"></span><br><span class="line"># 安装package.json中的依赖</span><br><span class="line"># 修改下载源，安装更快</span><br><span class="line">RUN npm install hexo --save \</span><br><span class="line">&amp;&amp; npm install hexo-admin --save \</span><br><span class="line">&amp;&amp; npm install hexo-deployer-git --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-archive --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-baidu-sitemap --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-category --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-feed --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-index --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-search --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-searchdb --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-sitemap --save \</span><br><span class="line">&amp;&amp; npm install hexo-generator-tag --save \</span><br><span class="line">&amp;&amp; npm install hexo-helper-live2d --save \</span><br><span class="line">&amp;&amp; npm install hexo-renderer-ejs --save \</span><br><span class="line">&amp;&amp; npm install hexo-renderer-marked --save \</span><br><span class="line">&amp;&amp; npm install hexo-renderer-stylus --save \</span><br><span class="line">&amp;&amp; npm install hexo-server --save \</span><br><span class="line">&amp;&amp; npm install hexo-tag-cloud --save \</span><br><span class="line">&amp;&amp; npm install hexo-wordcount --save \</span><br><span class="line"></span><br><span class="line"># 重新生成静态文件</span><br><span class="line">&amp;&amp; cd /usr/local/myblog \</span><br><span class="line">&amp;&amp; hexo clean \</span><br><span class="line">&amp;&amp; hexo g \</span><br><span class="line">&amp;&amp; chmod 777 /usr/local/myblog/buildbak/run.sh</span><br><span class="line"># 环境搭建完成，启动脚本</span><br><span class="line">CMD [&quot;/usr/local/myblog/buildbak/run.sh&quot;]</span><br></pre></td></tr></table></figure><p>build好镜像后，运行容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di -v /usr/local/temp/myblog/source/_posts/:/usr/local/myblog/source/_posts/ -v /usr/local/temp/myblog/source/images/:/usr/local/myblog/source/images/ --name myblog -p 22000:4000 myblog:final</span><br></pre></td></tr></table></figure><p>启动起来后查询dockerip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; myblog</span><br></pre></td></tr></table></figure><p>修改nginx.conf 将请求转发到docker的4000端口，重启nginx容器，完美结束，最后把阿里云上的域名的规则修改为新的服务器的ip，成了</p><p>每次修改或者新增文件，重启hexo容器就可以了，最后别忘了提交文件到github中做备份 </p><p>后续</p><ul><li>将Dockerfile nginx.conf run.sh 复制到myblog中，提交到github中做备份</li><li>将最终的镜像上传至阿里云</li><li>如果容器没有变化迁移环境的话直接，从阿里云拉取镜像运行即可</li><li>如果内容变化就要先提交最新状态到github中，在新的环境中clone仓库，重新build镜像运行即可</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两个阶段是两个月前的试验版本，只是在本机上用docker模拟并没有真正做迁移，然而在真正迁移的过程中，虽然可以完整迁移，但是体验不友好，我改进了迁移方案，首先总结一下缺点吧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动容器后需要进入容器中，启动nginx做转发&lt;/li&gt;
&lt;li&gt;如果不
      
    
    </summary>
    
      <category term="容器" scheme="http://yoursite.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>揭秘京东微服务框架的负载均衡算法</title>
    <link href="http://yoursite.com/2020/03/27/%E6%8F%AD%E7%A7%98%E4%BA%AC%E4%B8%9C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/27/揭秘京东微服务框架的负载均衡算法/</id>
    <published>2020-03-27T14:38:43.000Z</published>
    <updated>2021-07-13T12:27:08.594Z</updated>
    
    <content type="html"><![CDATA[<p>在京东广泛使用的微服务框架是JSF(Jingdong Service Framework)，中文名叫杰夫，今天给大家分享一下JSF的负载均衡算法。先串一下服务调用的过程，consumer在向provider发起远程调用之前会从注册中心拿到自己订阅的provider列表，然后和列表中的provider建立连接缓存起来，当发起调用的时候会从缓存的provider中选择一个进行调用，从多个provider选择一个进行调用，那么具体选择哪一个就用到了负载均衡算法，下面分别介绍一下JSF中的负载均衡算法：</p><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><ul><li>无权重或权重相等则从provider列表中随机选择一个发起调用；</li><li>有权重，假定总的权重值为x，随机生成[0-x)的偏移量，然后遍历减去provider列表的权重，当偏移量为负是选择当前的provider发起调用</li></ul><p>附伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ...初始化总权重值totalWeight和权重是否相同sameWeight,length为providerList长度</span><br><span class="line"></span><br><span class="line">if (totalWeight &gt; 0 &amp;&amp; !sameWeight) &#123;</span><br><span class="line">    offset = random.nextInt(totalWeight);// 偏移量</span><br><span class="line">    for (item : providerList) &#123;</span><br><span class="line">        offset -= item.getWeight(i);</span><br><span class="line">        if (offset &lt; 0) &#123;</span><br><span class="line">            return item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;// 没有权重或权重相同随机选择</span><br><span class="line">    return providerList.get(random.nextInt(length));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析： 有权重值或无权重值都需要先初始化总权重值及权重值是否相等的变量复杂度为O(n)；没有权重值随机选择一个发起调用复杂度为O(1)；有权重值且权重值不同通过偏移量随机选择的复杂度为O(n)；<strong>无权重时的复杂度为O(n)，有权重时总的复杂度为2O(n)</strong></p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><ul><li>无权重，方法级别的轮询，方法的调用次数和provider列表数量取余的结果为选择的provider</li><li>有权重，在无权重的基础上，将调用次数和providerList中最大权重值取余，在List中筛选权重值大于余数的provider，最后调用次数和筛选结果长度取余的结果就是最终选择的provider<ul><li>取余的操作是让结果在[0-被取余数)之间循环，第一次和最大权重取余，是让权重从小到大循环起来；第二次在筛选的结果中取余，就是在权重值大于第一次余数的结果中循环选择</li><li>eg：第一次取余的结果大，筛选出来的List就相对较小，且List都是权重较大的provider，第二次取余是在权重较大的provider中进行轮询选择；反之，第一次取余的结果小，筛选出来的List相对较大，第二次取余是在相对较大的List中进行轮询选择；这样在轮询的基础上保证权重值大的provider的节点有更多次机会被轮询到</li></ul></li></ul><p>验证一下这个算法：假设有3个Provider A、B、C，他们的权重分别为3、3、4，进行10次调用试一下，每一行的结果分别为 调用次数、%最大权重、筛选出List长度、调用次数%List长度、最后选择</p><ul><li>0    0    3    0    A</li><li>1    1    3    1    B</li><li>2    2    3    2    C</li><li>3    3    1    -        C</li><li>4    0    3    1    B</li><li>5    1    3    2    C</li><li>6    2    3    0    A</li><li>7    3    1    -    C</li><li>8    0    3    2    B</li><li>9    1    3    0    A</li></ul><p>可以看到结果10次调用，基本是轮询的状态，而且权重为4的C节点被调用4次</p><p>附伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// key = className+alias+method</span><br><span class="line">// 初始化最小和最大权重 minWeight maxWeight</span><br><span class="line">if (maxWeight &gt; 0 &amp;&amp; minWeight &lt; maxWeight) &#123;</span><br><span class="line">    currentWeight = count % maxWeight;</span><br><span class="line">    subList = getSubList(providerList);// 选择权重大于当前权重的子集</span><br><span class="line">    return subList.get(count%subList.size());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 无权重或权重相等</span><br><span class="line">    count = getAndIncrement(key);// 通过key获取调用次数并自增1</span><br><span class="line">    return providerList.get(count%length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析：初始化最小和最大权重复杂度为O(n)，无权重或权重相同直接取余选择即可复杂度O(1)；有权重时需要筛选大于当前权重的自己复杂度为O(n)，对子集轮询算账复杂度为O(1)；<strong>无权重轮询的复杂度为O(n)，有权重轮询的复杂度为2O(n)</strong></p><h3 id="最少活跃优先"><a href="#最少活跃优先" class="headerlink" title="最少活跃优先"></a>最少活跃优先</h3><p>每次选择最少活跃的provider发起调用，当最少活跃的节点多时，在最少活跃的节点中使用随机算法，有权重随机或者无权重随机选择；</p><ul><li><p>最少活跃可以理解为最少并发数，并发数少的节点表示节点处理请求的速度快，性能强</p></li><li><p>最少活跃数以最近100次连接中的失败数量为准，如果为0表示最近没有失败连接，直接返回真实的并发数；如果大于0，限制最大值为90，在[0,100)中产生随机数，当随机数比失败连接数大时返回真实的并发数，否自返回最大值；也就是说节点中最近100次连接有失败的记录，该节点则有一定几率不会被选中调用，且失败的连接数越多，不被选中的几率越大</p><ul><li>当节点快速抛异常会被认为是处理请求速度快的节点，所以最大失败值限制90，provider抛异常最低有10%选中的概率，等provider恢复并不再抛异常了恢复正常</li></ul></li></ul><p>附伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 初始化 最小活跃数leastActive、最小活跃数的数量leastCount等</span><br><span class="line"></span><br><span class="line">if (leastCount == 1) &#123;</span><br><span class="line">    // 最少活跃数的provider列表只有1个直接返回</span><br><span class="line">&#125; else  &#123;</span><br><span class="line"> // 采用随机算法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析：初始化工作复杂度O(n)，最少活跃数量为1直接返回O(1)，否则使用随机算法；<strong>最少活跃优先算法，无权重情况下2O(n)，有权重情况下3O(n)</strong></p><h3 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h3><ul><li>以方法维度定义了选择器，保存映射关系，以interfaceName+methodName为key，自定义的选择器为value；</li><li>当首次对一个方法发起调用或者providerList发生变化时，初始化选择器<ul><li>每个节点创建128个虚拟节点，以 ip+port+index 为key得到128个hash值，保存虚拟节点的映射关系（要有序）</li></ul></li><li>如果当前方法存在选择器且providerList没变，用方法的第一个参数得到hash值，从虚拟节点的映射中get，命中直接返回，不命中选择第一个大于该hash值的节点，没有则选择虚拟节点中的第一个</li></ul><p>hash算法：通过对一个key使用MD5算法得到一个摘要，这个摘要是byte[16]类型，将数组按照索引 0-3 4-7 8-11 12-15 分成4段，每一个段有4个byte，组成一个32位的hash值，一个摘要可以生成4个hash值</p><p>附伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">selector = selectorMap.get(key);</span><br><span class="line">if (selector == null || selector.hash() != hashCode)&#123;</span><br><span class="line">    // 首次调用或者providerList发生变化</span><br><span class="line">    selectorMap.put(key, new Selector());</span><br><span class="line">&#125; </span><br><span class="line">return selecotr.select();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Selector&#123;</span><br><span class="line"></span><br><span class="line">    Selector()&#123;</span><br><span class="line">        // 初始化选择器</span><br><span class="line">        for(item : providerList) &#123;</span><br><span class="line">            for (0 : 31) &#123;</span><br><span class="line">                digest = md5.digist(key);// byte[16]类型，4个hash值</span><br><span class="line">                for (0 : 3) &#123;</span><br><span class="line">                    virtualNodes.put(hash(digest,index));// hash()就是将摘要分段返回index个段作为hash值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Provider select()&#123;</span><br><span class="line">        digest = md5.digest(arg[0]);// 方法的第一个参数作为key生成摘要</span><br><span class="line">        hashCode = hash(digest,0);// 将摘要的第一个端最为hash值</span><br><span class="line">        provider = virtualNodes.get(hashCode)</span><br><span class="line">        if (provider == null) &#123;</span><br><span class="line">            // 选择大于hashCode的第一个key对应的节点，没有就选择第一个key的节点</span><br><span class="line">        &#125;</span><br><span class="line">        return provider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法复杂度分析：<strong>在最坏的情况下，每次选择都要初始化选择器的复杂度为128O(n)，当provider列表不变时只需进行1次初始化，后续的选择操作复杂度为O(1)</strong></p><h3 id="本地优先随机算法"><a href="#本地优先随机算法" class="headerlink" title="本地优先随机算法"></a>本地优先随机算法</h3><p>判断provider列表中是否存在本地ip，有则发起调用，没有就使用随机算法</p><p>算法复杂度分析：<strong>最坏的情况下每次都找不到本地ip则比随机算法多O(n)的复杂度，如果能找到本地ip的复杂度为O(n)</strong></p><p>总结：</p><ul><li>随机算法和轮询算法，适用于节点差异不大的情景，节点有差异需要设置权重值<ul><li>优点，简单高效</li><li>缺点，需要找到最合适的权重值</li></ul></li><li>最少活跃优先算法，适用节点之间有差异的情景<ul><li>优点，无权重值下，可以均衡节点之间的差异，不用去设置权重值</li><li>缺点，算法复杂度较高</li></ul></li><li>一致性hash 适用于节点中有缓存数据的情景，相同的请求总是选择同样的节点<ul><li>缺点，算法复杂度较高</li></ul></li><li>本地IP调用优先 适用于本地同时提供服务的情景</li></ul><p><strong>综上，理论上，本地有自己要调用的服务配置本地IP调用优先，其他情况使用随机或者轮询都可以，默认随机算法不用管就好了</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在京东广泛使用的微服务框架是JSF(Jingdong Service Framework)，中文名叫杰夫，今天给大家分享一下JSF的负载均衡算法。先串一下服务调用的过程，consumer在向provider发起远程调用之前会从注册中心拿到自己订阅的provider列表，然后
      
    
    </summary>
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
