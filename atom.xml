<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YyWang&#39;s Blog</title>
  
  <subtitle>永远没时间的王先森</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-16T06:57:46.499Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YyWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL Explain记录(转载)</title>
    <link href="http://yoursite.com/2019/11/16/SQL-Explain%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/11/16/SQL-Explain记录/</id>
    <published>2019-11-16T06:43:30.000Z</published>
    <updated>2019-11-16T06:57:46.499Z</updated>
    
    <content type="html"><![CDATA[<p>要优化SQL必须得使用Explain，这里记录一下Explain的使用，直接查看即可，摘自<a href="https://www.cnblogs.com/tufujie/p/9413852.html" target="_blank" rel="noopener">MySQL Explain详解</a></p><p>explain 直接加载SQL语句之前，然后一起执行即可，只能分析查询语句，会出现以下结果<br><img src="/images/pasted-20.png" alt="upload successful"></p><h3 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h3><p>select的查询顺序标识，SQL顺序由大到小执行，id相同从上往下顺序执行</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select的类型</p><ul><li><p>SIMPLE(简单SELECT，不使用UNION或子查询等)</p></li><li><p>PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p></li><li><p>UNION(UNION中的第二个或后面的SELECT语句)</p></li><li><p>DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p></li><li><p>UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p></li><li><p>SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p></li><li><p>DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p></li><li><p>DERIVED(派生表的SELECT, FROM子句的子查询)</p></li><li><p>UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p></li></ul><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。</p><p>常用的类型有： ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）</p><ul><li><p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p></li><li><p>index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p></li><li><p>range:只检索给定范围的行，使用一个索引来选择行</p></li><li><p>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p></li><li><p>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p></li><li><p>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</p></li><li><p>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p></li></ul><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）</p><p>该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中</p><p>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</p><p>不损失精确性的情况下，长度越短越好 </p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>该列包含MySQL解决查询的详细信息,有以下几种情况：</p><ul><li><p>Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p></li><li><p>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p></li><li><p>Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</p></li><li><p>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p></li><li><p>Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p></li><li><p>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p></li><li><p>No tables used：Query语句中使用from dual 或不含任何from子句</p></li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>EXPLAIN不考虑各种Cache</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>部分统计信息是估算的，并非精确值</li><li>EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要优化SQL必须得使用Explain，这里记录一下Explain的使用，直接查看即可，摘自&lt;a href=&quot;https://www.cnblogs.com/tufujie/p/9413852.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQ
      
    
    </summary>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL级联查询一些总结</title>
    <link href="http://yoursite.com/2019/11/16/SQL/"/>
    <id>http://yoursite.com/2019/11/16/SQL/</id>
    <published>2019-11-16T06:34:28.000Z</published>
    <updated>2019-11-16T06:58:23.574Z</updated>
    
    <content type="html"><![CDATA[<p>子查询导致索引失效</p><p>连接查询（连接条件为索引）的效率更高</p><h5 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h5><p>微服务相关管理端的系统，用户会在自己对应服务的地方查询所需的server，新增需求为要查看自己的服务所在的app</p><h5 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h5><p>server在单独的一张表，可以根据服务名称（interface_name）来查询；AppName在另外的一张表中；两张表没有联系需要通过一个中间表来连接；interface_name有索引，三个表之间的链接字段都有索引</p><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p>需要联合3张表来查询所需要的数据，每张表的数据量都比较大，而且这个SQL是系统使用最频繁的部分查询的频率还特别高，所以要尽可能快的出结果</p><h5 id="我的心路历程："><a href="#我的心路历程：" class="headerlink" title="我的心路历程："></a>我的心路历程：</h5><p>先通过interface_name条件筛选出一部分数据再链接另外两张表查询，都有索引一定是最优的，SQL如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">app_name </span><br><span class="line">FROM</span><br><span class="line">saf_app </span><br><span class="line">WHERE</span><br><span class="line">app_id IN </span><br><span class="line">( </span><br><span class="line">SELECT DISTINCT app_id FROM saf_ins_hb WHERE ins_key IN </span><br><span class="line">(SELECT ins_key FROM saf_server WHERE interface_name = &apos;xxx&apos;) </span><br><span class="line">)</span><br><span class="line"> ORDER BY app._name</span><br></pre></td></tr></table></figure><p>查询时间竟然需要6s多，这绝对是不能忍的，接着我又试了一下级联查询，SQL如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT app.app_name </span><br><span class="line">FROM saf_server s </span><br><span class="line">LEFT JOIN saf_ins_hb hb ON s.ins_key = hb.ins_key</span><br><span class="line">LEFT JOIN saf_app app ON hb.app_id = app.app_id</span><br><span class="line">WHERE s.interface_name = &apos;xxx&apos; </span><br><span class="line">ORDER BY app.app_name</span><br></pre></td></tr></table></figure><p>这次的结果只需0.05s,相差100倍还多</p><p>explain看下呢</p><p>IN子查询如下</p><p><img src="/images/pasted-19.png" alt="upload successful"></p><p>可以看到id为2和3的查询都用到了索引并且只需扫描的很少的行数，到了最外层的查询就变成了全表扫描了，索引就失效了</p><p>级联查询如下</p><p><img src="/images/pasted-18.png" alt="upload successful"></p><p>级联查询全部使用到了索引，而且扫描的行数比子查询的要少很多，扫描的最终行数是乘积的关系，级联查询有两个子查询的rows为1所以要比IN子查询要小很多</p><p>所以说IN子查询会导致部分索引失效，我有了新的想法，既然连接查询会很快那么我先通过条件筛选出数据再做级联查询不是更快了，开整~ SQL如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT app.app_name </span><br><span class="line">    FROM (SELECT ins_key FROM saf_server WHERE interface_name = &apos;xxx&apos;) s </span><br><span class="line">LEFT JOIN saf_ins_hb hb ON s.ins_key = hb.ins_key</span><br><span class="line">LEFT JOIN saf_app app ON hb.app_id = app.app_id</span><br><span class="line">    ORDER BY app.app_name</span><br></pre></td></tr></table></figure><p>查询0.02s左右，我非常满意，explain一下呢</p><p><img src="/images/pasted-17.png" alt="upload successful"></p><p>相较于级联查询还多了7000多次的遍历？？？子查询害人啊，查询结果0.02s左右应该是有缓存</p><p>看了一篇文章说在on后面加限制条件会比where中加限制条件用时要少，on后面加条件在两张表做连接的同时过滤掉一些数据后再和第三张表做连接，where是将连接了所有表之后的结果进行筛选，听着很有道理，那我试一下呢，SQL如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT app.app_name </span><br><span class="line">    FROM saf_server s </span><br><span class="line">LEFT JOIN saf_ins_hb hb ON s.ins_key = hb.ins_key and s.interface_name = &apos;xxx&apos;</span><br><span class="line">LEFT JOIN saf_app app ON hb.app_id = app.app_id</span><br><span class="line">    ORDER BY app.app_name</span><br></pre></td></tr></table></figure><p>explain看下</p><p><img src="/images/pasted-16.png" alt="upload successful"></p><p>结果非常意外，不仅时间没有省下来，索引也没有使用，进行全表扫描，还好我验证了一下，原因的话还不知道，对mysql底层不是很熟悉，先暂时把遇到的问题记录下来吧 ^_^</p><p><strong>结论：子查询会导致索引失效，尽量不使用子查询，用级联查询代替，并将级联查询的条件设置建立索引</strong></p><h5 id="级联查询的原理"><a href="#级联查询的原理" class="headerlink" title="级联查询的原理"></a>级联查询的原理</h5><p>mysql会首先找到一张表作为驱动表，就是首先要进行查询的表，以驱动表为基础匹配剩下的表，inner join的情况mysql会选择数据量小的表作为驱动表，left/right join分别以左/右表作为驱动表；接着会根据on的条件过滤结果，最终将连接的表都筛选完成后如果有where语句指定条件将进行最后的筛选得到结果</p><p>连接的算法也很简单，连接条件没有索引则进行全表扫描然后进行匹配，如果还有表连接则将匹配的结果继续与剩余的表进行扫描匹配，这种方法简单粗暴，叫做嵌套循环连接（Nested-Loop Join）；Mysql对这种方式有了优化，增加了join buffer，是将驱动表关联条件的相关列缓存起来，并将多次匹配合并，减少的匹配的次数，以此方式来加速查询结果，叫做BLJ算法（Block Nested-Loop Join）；有索引则会先匹配索引，匹配后的结果再插到对应的数据返回</p><p>综上，级联查询的查询条件最好是加索引，虽然mysql对没有索引的链接做了优化，那也是没有索引的方式快的，而且最好链接的条件是主键索引，这是由于非主键索引指向的时主键索引，要得到数据还要跑一次主键索引；还有我想到了阿里巴巴java开发规范中写道多余三张表不能使用join，用多次简单查询代替这个也要注意一下</p><p>参考： <a href="https://www.jianshu.com/p/048d93d3ee54" target="_blank" rel="noopener">MySQL查询优化——连接以及连接原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;子查询导致索引失效&lt;/p&gt;
&lt;p&gt;连接查询（连接条件为索引）的效率更高&lt;/p&gt;
&lt;h5 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h5&gt;&lt;p&gt;微服务相关管理端的系统，用户会在自己对应服务的
      
    
    </summary>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>踩坑记录</title>
    <link href="http://yoursite.com/2019/11/06/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/11/06/踩坑记录/</id>
    <published>2019-11-06T05:52:26.000Z</published>
    <updated>2019-11-06T05:55:32.762Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在xml文件中if条件判断字符串相等时要用双引号而不是单引号"><a href="#在xml文件中if条件判断字符串相等时要用双引号而不是单引号" class="headerlink" title="在xml文件中if条件判断字符串相等时要用双引号而不是单引号"></a>在xml文件中if条件判断字符串相等时要用双引号而不是单引号</h4><ul><li><p>错误栗子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;if test=&quot;params.appName != null and params.appName != &apos;&apos; and params.appName != &apos;*&apos;&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>正确栗子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;if test=&apos;params.appName != null and params.appName != &quot;&quot; and params.appName != &quot;*&quot;&apos;&gt;</span><br></pre></td></tr></table></figure></li><li><p>MyBatis会将’*’转化为数字，并且会报NumberFormatException</p></li><li><p>原因百度了一下大概是这样，MyBatis使用OGNL表达式来解析，在OGNL表达式中单引号和其中的字符会被解析成一个字符，java对于没有引号的等式/不等式认为是数字类型并进行转化</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;在xml文件中if条件判断字符串相等时要用双引号而不是单引号&quot;&gt;&lt;a href=&quot;#在xml文件中if条件判断字符串相等时要用双引号而不是单引号&quot; class=&quot;headerlink&quot; title=&quot;在xml文件中if条件判断字符串相等时要用双引号而不是单引号&quot;&gt;
      
    
    </summary>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>maven-assembly插件打zip包</title>
    <link href="http://yoursite.com/2019/10/11/maven-assembly%E6%8F%92%E4%BB%B6%E6%89%93zip%E5%8C%85/"/>
    <id>http://yoursite.com/2019/10/11/maven-assembly插件打zip包/</id>
    <published>2019-10-11T09:50:37.000Z</published>
    <updated>2019-10-11T09:50:51.228Z</updated>
    
    <content type="html"><![CDATA[<p>web工程通过maven打包通常都是war包，Tomcat会自动将war包解压并发布出来，但如果本身做的不是web工程，是普通java项目如何发布到服务器上并运行main方法呢？公司里使用maven-assembly这个插件，将项目打包成zip压缩包，里面包含bin、conf和lib三个文件夹，bin目录中保存启动和停止的shell脚本，conf中保存配置文件，lib目录中保存编译好的jar和所依赖的jar；然后将zip包抽取并解压到服务器启动start.sh脚本来运行java项目。</p><p>在这个过程中就用到了maven-assembly这个插件来进行编译并打包，步骤如下</p><p>目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">  |--assembly</span><br><span class="line">         |----bin</span><br><span class="line">               |---start.sh</span><br><span class="line">               |---stop.sh</span><br><span class="line">               |---jvm.properties</span><br><span class="line">         |----assembly.xml</span><br></pre></td></tr></table></figure><ul><li><ol><li>pom中配置assembly插件</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!--打包规则的配置--&gt;</span><br><span class="line">&lt;descriptors&gt;</span><br><span class="line">&lt;descriptor&gt;src/main/assembly/assembly.xml&lt;/descriptor&gt;</span><br><span class="line">&lt;/descriptors&gt;</span><br><span class="line">&lt;tarLongFileMode&gt;posix&lt;/tarLongFileMode&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;executions&gt;</span><br><span class="line">&lt;execution&gt;</span><br><span class="line">&lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">&lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">&lt;goals&gt;</span><br><span class="line">&lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">&lt;/goals&gt;</span><br><span class="line">&lt;/execution&gt;</span><br><span class="line">&lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>注：使用assembly插件编译要讲该插件的配置放在plugins标签中的第一个，在我的工程中开始在前面的时spring-boot-maven-plugin插件导致编译失败了</p><ul><li>2.创建并配置assembly.xml文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;assembly&gt;</span><br><span class="line"></span><br><span class="line">    &lt;id&gt;assembly&lt;/id&gt;</span><br><span class="line"></span><br><span class="line">    &lt;formats&gt;</span><br><span class="line">        &lt;format&gt;zip&lt;/format&gt;</span><br><span class="line">        &lt;format&gt;dir&lt;/format&gt;</span><br><span class="line">    &lt;/formats&gt;</span><br><span class="line"></span><br><span class="line">    &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--输出文件的配置  3个属性分别是 编译路径 输出路径 文件权限--&gt;</span><br><span class="line">    &lt;fileSets&gt;</span><br><span class="line">        &lt;fileSet&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;outputDirectory&gt;conf&lt;/outputDirectory&gt;</span><br><span class="line">            &lt;fileMode&gt;0644&lt;/fileMode&gt;</span><br><span class="line">        &lt;/fileSet&gt;</span><br><span class="line">        &lt;fileSet&gt;</span><br><span class="line">            &lt;directory&gt;src/main/assembly/bin&lt;/directory&gt;</span><br><span class="line">            &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;start.sh&lt;/include&gt;</span><br><span class="line">                &lt;include&gt;stop.sh&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">            &lt;fileMode&gt;0755&lt;/fileMode&gt;</span><br><span class="line">        &lt;/fileSet&gt;</span><br><span class="line">        &lt;fileSet&gt;</span><br><span class="line">            &lt;directory&gt;src/main/assembly/bin&lt;/directory&gt;</span><br><span class="line">            &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;jvm.properties&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">            &lt;filtered&gt;true&lt;/filtered&gt;</span><br><span class="line">            &lt;fileMode&gt;0644&lt;/fileMode&gt;</span><br><span class="line">        &lt;/fileSet&gt;</span><br><span class="line">    &lt;/fileSets&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencySets&gt;</span><br><span class="line">        &lt;dependencySet&gt;</span><br><span class="line">            &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt;</span><br><span class="line">        &lt;/dependencySet&gt;</span><br><span class="line">    &lt;/dependencySets&gt;</span><br><span class="line"></span><br><span class="line">&lt;/assembly&gt;</span><br></pre></td></tr></table></figure><ul><li>3.编写脚本</li></ul><p>start.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">BASEDIR=`dirname $0`/..</span><br><span class="line">BASEDIR=`(cd &quot;$BASEDIR&quot;; pwd)`</span><br><span class="line">echo current path:$BASEDIR</span><br><span class="line"></span><br><span class="line">BASEBIN_DIR=$BASEDIR&quot;/bin&quot;</span><br><span class="line">cd $BASEBIN_DIR</span><br><span class="line"></span><br><span class="line">LAF_REG_INSTANCE=&quot;test-jsf-demo&quot;</span><br><span class="line">LOGPATH=&quot;&quot;</span><br><span class="line">LAF_REG_PIDPATH=&quot;$BASEBIN_DIR&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; != &quot;&quot; ] &amp;&amp; [ &quot;$2&quot; != &quot;&quot; ]; then</span><br><span class="line">    LAF_REG_INSTANCE=&quot;$1&quot;</span><br><span class="line">    LOGPATH=&quot;$2&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$3&quot; != &quot;&quot; ]; then</span><br><span class="line">    LAF_REG_PIDPATH=&quot;$3&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ------ check if server is already running</span><br><span class="line">PIDFILE=$LAF_REG_PIDPATH&quot;/&quot;$LAF_REG_INSTANCE&quot;_startup.pid&quot;</span><br><span class="line">if [ -f $PIDFILE ]; then</span><br><span class="line">    if kill -0 `cat $PIDFILE` &gt; /dev/null 2&gt;&amp;1; then</span><br><span class="line">        echo server already running as process `cat $PIDFILE`.</span><br><span class="line">        exit 0</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># ------ set JAVACMD</span><br><span class="line"># If a specific java binary isn&apos;t specified search for the standard &apos;java&apos; binary</span><br><span class="line">if [ -z &quot;$JAVACMD&quot; ] ; then</span><br><span class="line">  if [ -n &quot;$JAVA_HOME&quot;  ] ; then</span><br><span class="line">    if [ -x &quot;$JAVA_HOME/jre/sh/java&quot; ] ; then</span><br><span class="line">      # IBM&apos;s JDK on AIX uses strange locations for the executables</span><br><span class="line">      JAVACMD=&quot;$JAVA_HOME/jre/sh/java&quot;</span><br><span class="line">    else</span><br><span class="line">      JAVACMD=&quot;$JAVA_HOME/bin/java&quot;</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">    JAVACMD=`which java`</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -x &quot;$JAVACMD&quot; ] ; then</span><br><span class="line">  echo &quot;Error: JAVA_HOME is not defined correctly.&quot;</span><br><span class="line">  echo &quot;  We cannot execute $JAVACMD&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># ------ set CLASSPATH</span><br><span class="line">CLASSPATH=&quot;$BASEDIR&quot;/conf/:&quot;$BASEDIR&quot;/root/:&quot;$BASEDIR&quot;/lib/*</span><br><span class="line">echo &quot;$CLASSPATH&quot;</span><br><span class="line"></span><br><span class="line"># ------ set jvm memory</span><br><span class="line">sed &quot;s/\r$//g&quot; jvm.properties &gt; 1.properties</span><br><span class="line">mv 1.properties jvm.properties</span><br><span class="line">if [ -z &quot;$OPTS_MEMORY&quot; ] ; then</span><br><span class="line">    OPTS_MEMORY=&quot;`sed -n &apos;1p&apos; jvm.properties`&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;`sed -n &apos;2p&apos; jvm.properties`&quot; != &quot;&quot; ] ; then</span><br><span class="line">    JAVA_CMD=&quot;`sed -n &apos;2p&apos; jvm.properties`&quot;</span><br><span class="line">    if [ -f $JAVA_CMD ]; then</span><br><span class="line">        JAVACMD=$JAVA_CMD</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#DEBUG_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000&quot;</span><br><span class="line">#JPDA_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n&quot;</span><br><span class="line"># ------ run proxy</span><br><span class="line">nohup &quot;$JAVACMD&quot; $JPDA_OPTS \</span><br><span class="line">  $OPTS_MEMORY $DEBUG_OPTS \</span><br><span class="line">  -classpath &quot;$CLASSPATH&quot; \</span><br><span class="line">  -Dbasedir=&quot;$BASEDIR&quot; \</span><br><span class="line">  -Dfile.encoding=&quot;UTF-8&quot; \</span><br><span class="line">  com.jd.testjsfdemo.TestjsfdemoApplication \</span><br><span class="line">  &gt; /Users/Logs/testjsfdemo_std.out &amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ------ wirte pid to file</span><br><span class="line">if [ $? -eq 0 ]</span><br><span class="line">then</span><br><span class="line">    if /bin/echo -n $! &gt; &quot;$PIDFILE&quot;</span><br><span class="line">    then</span><br><span class="line">        sleep 1</span><br><span class="line">        echo STARTED SUCCESS</span><br><span class="line">    else</span><br><span class="line">        echo FAILED TO WRITE PID</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">#    tail -100f $LOGFILE</span><br><span class="line">else</span><br><span class="line">    echo SERVER DID NOT START</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>stop.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">BASEDIR=`dirname $0`</span><br><span class="line">BASEDIR=`(cd &quot;$BASEDIR&quot;; pwd)`</span><br><span class="line">echo current path $BASEDIR</span><br><span class="line"></span><br><span class="line">LAF_REG_INSTANCE=&quot;test-jsf-demo&quot;</span><br><span class="line">LAF_REG_PIDPATH=&quot;$BASEDIR&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; != &quot;&quot; ]; then</span><br><span class="line">    LAF_REG_INSTANCE=&quot;$1&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$2&quot; != &quot;&quot; ]; then</span><br><span class="line">    LAF_REG_PIDPATH=&quot;$2&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">PIDFILE=$LAF_REG_PIDPATH&quot;/&quot;$LAF_REG_INSTANCE&quot;_startup.pid&quot;</span><br><span class="line">echo $PIDFILE</span><br><span class="line"></span><br><span class="line">if [ ! -f &quot;$PIDFILE&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;no registry to stop (could not find file $PIDFILE)&quot;</span><br><span class="line">else</span><br><span class="line">    kill $(cat &quot;$PIDFILE&quot;)</span><br><span class="line">    sleep 10</span><br><span class="line">    kill -9 $(cat &quot;$PIDFILE&quot;)</span><br><span class="line">    rm -f &quot;$PIDFILE&quot;</span><br><span class="line">    echo STOPPED</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br><span class="line"></span><br><span class="line">echo stop finished.</span><br></pre></td></tr></table></figure><p>jvm.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m -Xmx1024m -Xmn400m</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin/java</span><br></pre></td></tr></table></figure><ul><li>4.编译后就成功啦，之后在jdos上配置一下就可以自动部署了</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;web工程通过maven打包通常都是war包，Tomcat会自动将war包解压并发布出来，但如果本身做的不是web工程，是普通java项目如何发布到服务器上并运行main方法呢？公司里使用maven-assembly这个插件，将项目打包成zip压缩包，里面包含bin、con
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://yoursite.com/2019/09/19/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/19/观察者模式/</id>
    <published>2019-09-19T11:43:41.000Z</published>
    <updated>2019-09-19T11:45:47.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>包含观察者和被观察者两个部分，原理也很简单，被观察者类中维护观察者对象的集合，当感兴趣的事件发生，遍历观察者的集合回调观察者对象中的相应方法（update）即可</p><p>被观察者除了维护观察者的集合外，还有对该集合的增（注册）、删（取消）及通知等操作</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">    update(String msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ObserverImpl implements Observer &#123;</span><br><span class="line">private String name = &quot;&quot;;</span><br><span class="line">Observer(String name)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">@override</span><br><span class="line">public void update(String msg)&#123;</span><br><span class="line">// 感兴趣的事件发生</span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="被观察者"><a href="#被观察者" class="headerlink" title="被观察者"></a>被观察者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Observed&#123;</span><br><span class="line">registerObserver(Observer observer);</span><br><span class="line">removeObserver(Observer observer);</span><br><span class="line">notify(Observer observer);</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ObservedImpl implements Observed&#123;</span><br><span class="line">    private static List&lt;Observer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void registerObserver(Observer observer)&#123;</span><br><span class="line">        list.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void removeObserver(Observer observer)&#123;</span><br><span class="line">        list.remove(Observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void notify(Observer observer)&#123;</span><br><span class="line">        list.stream().filter(n -&gt; n.equals(observer)).update(&quot;notify&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void notifyAll()&#123;</span><br><span class="line">        list.stream().map(n -&gt; n.update(&quot;notifyAll&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observed o = new ObservedImpl();</span><br><span class="line">Observer o1 = new ObserverImpl(&quot;o1&quot;);</span><br><span class="line">Observer o2 = new ObserverImpl(&quot;o2&quot;);</span><br><span class="line">o.registerObserver(o1);</span><br><span class="line">o.registerObserver(o2);</span><br><span class="line">o.notifyAll();</span><br></pre></td></tr></table></figure><h4 id="Observer-和-Observable"><a href="#Observer-和-Observable" class="headerlink" title="Observer 和 Observable"></a>Observer 和 Observable</h4><p>jdk中提供了观察者模式的API，java.util包下的Observer接口和Observable类，原理是一样的，这里只是进行的封装</p><p>上源码</p><h5 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">    void update(Observable o, Object arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面观察者的部分一样，实现一个回调方法，当感兴趣的事件发生回调该方法</p><p>使用时，实现Observer接口，重写update方法即可，当感兴趣的事件发生会回调update方法，这里会写增加的业务逻辑</p><h5 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class Observable &#123;</span><br><span class="line">    private boolean changed = false;</span><br><span class="line">    private Vector&lt;Observer&gt; obs;</span><br><span class="line">    </span><br><span class="line">    public Observable() &#123;</span><br><span class="line">        obs = new Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void addObserver(Observer o) &#123;</span><br><span class="line">        if (o == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        if (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void deleteObserver(Observer o) &#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void notifyObservers() &#123;</span><br><span class="line">        notifyObservers(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void notifyObservers(Object arg) &#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (!changed)</span><br><span class="line">                return;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = arrLocal.length-1; i&gt;=0; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(this, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void deleteObservers() &#123;</span><br><span class="line">        obs.removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected synchronized void setChanged() &#123;</span><br><span class="line">        changed = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected synchronized void clearChanged() &#123;</span><br><span class="line">        changed = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized boolean hasChanged() &#123;</span><br><span class="line">        return changed;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public synchronized int countObservers() &#123;</span><br><span class="line">        return obs.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同样，这里维护一个观察者的集合Vector，这里考虑了线程安全的问题，说明这种方式实现的观察者模式是线程安全的</li><li>除此之外还有一个bool类型的变量changed表示被观察者是否发生改变（也就是感兴趣的事件是否发生），通过该标志来通知观察者对象</li><li>同样，该类里有针对观察者集合的增、删、通知的操作，还多了对changed标志修改的操作；除此之外所有方法都有synchronized关键字，进一步说明了这种方式的观察者模式是线程安全的</li><li>使用时，在要被观察的类中继承Observable类，再添加实现了Observer接口的观察者对象，调用setChanged()方法改变changed标志后通过调用notify()方法进行通知</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h3&gt;&lt;p&gt;包含观察者和被观察者两个部分，原理也很简单，被观察者类中维护观察者对象的集合，当感兴趣的事件发生，遍历观察者的集合回
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper扫盲</title>
    <link href="http://yoursite.com/2019/08/29/Zookeeper%E6%89%AB%E7%9B%B2/"/>
    <id>http://yoursite.com/2019/08/29/Zookeeper扫盲/</id>
    <published>2019-08-29T07:23:15.000Z</published>
    <updated>2019-08-29T07:24:51.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>是一个分布式协调服务框架，这句话对于刚接触ZK（Zookeeper下文简称ZK）的我来说太抽象了，很难理解，只知道它能提供一些服务能够实现配置管理、命名服务、分布式锁等等，也就是在这些场景下会使用到ZK，这样说好像还是很难理解；之后，我找到了一个比较好理解的点，就是从CAP理论的角度，这需要对CAP有些了解，提前做了功课(<a href="http://yywang.top/2019/08/26/CAP%E5%92%8CBASE/#more" target="_blank" rel="noopener">CAP和BASE</a>)，简单来说在分布式系统中出现网络故障时，最多满足其中的两项，而P是必须要满足的，那么就需要从CP和AP中做选择了；ZK就是可保证CP的框架，最后我的理解就是ZK通过特定的数据结构，封装一系列算法通过API的方式提供分布式环境数据一致性的服务，所有需要数据一致性的场景都可以使用ZK，也就是上面提到的配置管理、命名服务、分布式锁等等场景</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>ZK提供了一套类似于文件目录的数据结构，叫做多层级的节点命名空间，每个节点（ZK中称为znode）都可以存放数据且每个节点下都有若干个子节点，听起来和树的结构差不多，其实也一样，目录也是一种树结构的实现，znode可以理解为文件夹，文件夹中可以存放文件（znode可以存放数据），也可以存放文件夹（znode也可以存放znode）</p><h5 id="znode的类型"><a href="#znode的类型" class="headerlink" title="znode的类型"></a>znode的类型</h5><ul><li>PERSISTENT–持久化目录节点<ul><li>客户端和ZK断开连接后节点依然存在</li></ul></li><li>PERSISTENT_SEQUENTIAL–持久化顺序编号目录节点<ul><li>与持久化目录节点相同，只是多了ZK对节点的顺序编号</li></ul></li><li>EPHEMERAL–临时目录节点<ul><li>客户端和ZK断开连接后节点被删除</li></ul></li><li>EPHEMERAL_SEQUENTIAL–临时顺序编号目录节点<ul><li>与临时目录节点相同，只是多了ZK对节点的顺序编号 </li></ul></li></ul><h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p>ZK还提供了类似于观察这模式的通知机制，称为watcher事件，可以观察到znode的变化，来通知客户端，之后客户端再做相应的业务逻辑</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h4><p>这里命名服务指的是通过指定名字获取对应的资源，将资源存储在特定路径的znode中，根据路径就可以找到资源，类比目录结构来说，拿到文件的地址就能通过地址来找到文件，有点像是URL的意思，但是由于ZK数据结构设计的因素ZK不能存放较大的数据；微服务框架中的注册中心需要存放provider和consumer的信息，并且consumer要能够感知provider的实时状态，ZK可以根据provider和consumer的地址映射成临时znode结构，这样既保存了provider和consumer的信息还能感知彼此的状态</p><h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p>一句话解释—-动态下发配置文件变化；通过ZK客户端watch配置文件，一旦配置文件发生变化马上通知客户端做对应的处理</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>多个客户端再ZK的同一个目录下尝试创建临时znode，成功创建znode意味着获得锁成功，下个客户端发现目录下已经存在znode则对该znode添加watch机制，当znode消失即为释放锁后，通知客户端尝试创建znode来获取锁，这是公平锁；非公平锁的则创建临时有序的znode，相当于一个队列，后面的节点watch前一个节点的znode的状态，队头的znode为获得锁成功的几点</p><h3 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h3><h4 id="ZK节点的状态"><a href="#ZK节点的状态" class="headerlink" title="ZK节点的状态"></a>ZK节点的状态</h4><ul><li>LOOKING–当前节点不知道leader是谁，正在搜索</li><li>LEADING–当前节点为集群的leader</li><li>FOLLOWING–目前已有leader，当前节点负责与leader节点同步</li></ul><h4 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h4><p>在两种情况下会进行选举，1.服务器初始化启动 2.集群中leader节点故障</p><p>起初集群中的节点没有leader或者不知道leader是谁，此时节点的状态为LOOKING，如果当前集群存在leader（该节点新加入集群），此节点发送投票信息想要选举leader会被告知当前leader的信息，此节点只需和leader节点建立连接，并进行状态同步即可；</p><p>如果当前集群不存在leader节点，则需要投票进行选举</p><ul><li>此时所有节点皆为LOOKING状态，并编辑投票信息发送给集群的其他节点，投票信息的格式为（SID,ZXID）（服务器的唯一标识，事务ID），SID是自己配置的，ZXID理解为当前节点数据的版本；</li><li>集群中的节点会受到其他节点的投票信息，加上自己的那一票会根据一个规则会投出第二轮的选票<ul><li>节点会在自己收到的选票中，选择ZXID最大的作为第二轮的选票发送给集群中其他节点</li><li>如果ZXID相同则选择SID最大的作为第二轮的选票发送给集群中其他节点</li></ul></li><li>集群中的节点在接收到第二轮选票后进行统计（包含自己的一票），获得集群中一半以上（&gt;n/2）数量投票的节点当选leader进入LEADING状态，其余节点进入FOLLOWING状态</li></ul><p>总结一下，集群中要获得一半以上的投票才能当选leader，所以集群最少为3台，并且数量是奇数；集群中ZXID越大的节点（当前节点数据版本越新）优先当选leader</p><h3 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h3><p>整个过程没有难度也很好理解，跟着<a href="https://www.jianshu.com/p/5491d16e6abd" target="_blank" rel="noopener">这篇文章</a>做就完事了</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本文是对于Zookeeper的扫盲，大致了解ZK的基本原理，为了更好的理解工作中的项目，具有目的性，一些细节没有去研究，下回再补，😋</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://jm.taobao.org/2011/10/08/1232/" target="_blank" rel="noopener">ZooKeeper典型应用场景一览</a></p><p><a href="https://www.jianshu.com/p/5491d16e6abd" target="_blank" rel="noopener">笔记：Mac上zookeeper的安装与启动</a></p><p><a href="https://segmentfault.com/a/1190000014479433?utm_source=tag-newest" target="_blank" rel="noopener">zookeeper面试题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Zookeeper&quot;&gt;&lt;a href=&quot;#Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper&quot;&gt;&lt;/a&gt;Zookeeper&lt;/h3&gt;&lt;p&gt;是一个分布式协调服务框架，这句话对于刚接触ZK（Zookeeper下文简称ZK）的我
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CAP和BASE</title>
    <link href="http://yoursite.com/2019/08/26/CAP%E5%92%8CBASE/"/>
    <id>http://yoursite.com/2019/08/26/CAP和BASE/</id>
    <published>2019-08-26T08:52:51.000Z</published>
    <updated>2019-08-29T07:24:22.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>Consistency（一致性） Availability（可用性） Partition tolerance（分区容错性）</p><p>CAP理论的内容是在分布式系统中出现网络故障时最多只能满足CAP中的两项</p><ul><li>Consistency 一致性<ul><li>“all node see the same data at the same time” 就是指分布式系统的数据一致性，可用看出这里的一致性指的是强一致性，要求分布式系统数据发生改变后所有节点在后续的请求中都能感知到</li><li>强一致性，当数据发生改变，系统中的其他节点在下次请求都会感知到</li><li>弱一致性，保证某个时间级别（比如xx秒），数据能够达到数据一致的状态</li><li>最终一致性，弱一致性的一个特例，保证在一段时间内达到数据一致的状态</li></ul></li><li>Availability 可用性<ul><li>“Reads and Writes always succeed”，这里的succeed指的是请求和响应的过程成功，也每次请求都会在有限的时间内收到回复，换句话说就是服务器可用；并不是请求的返回值是成功的意思，返回值是失败也是有返回值的，同样说明请求响应的过程是成功的。</li><li>系统可用性5个9，意为分布式系统的可用水平为99.999%，全年停机时间不超过 <strong>(1-0.99999)<em>365</em>24*60 = 5.256 min</strong></li></ul></li><li>Partition tolerance 分区容错性<ul><li>“the system continues to operate despite arbitrary message loss or failure of part of the system” 分区指的是由于网络异常集群中只有部分节点能够正常通信，可能存在多个能够通信的子网络，这些子网络就是分区；又或者说集群中部分服务器宕机，其他服务器依然可用，这部分可用的服务器组成的子网络也可以称为分区。分区容错性是指当出现网络延迟或者故障的情况时系统依然能够提供服务</li></ul></li></ul><p>怎么理解呢？简单来说就是在分布式系统中发生故障时，CAP最多只能满足其中的两项，也就是CAP三选二呗，但是我们发现P（分区容错性）说白了就是指网络出问题后系统依然可用，这可是分布式系统的基础条件，应该必须满足；在满足分区容错性时有可能会存在两种问题</p><ul><li>1.用户访问部分服务器间的网络异常，这时只需将请求转发到可用的服务器即可，这时在理想情况下（服务器间的网络通畅）是可以满足CAP的，除非和所有服务器的网络都有问题（<strong>这只是理想情况</strong>）</li><li>2.除了用户访问服务器的网络异常之外，分布式系统中不同服务器直接的网络也可能存在异常，例如分布式系统中有A、B两台服务器，假设A、B之间存在网络故障，当服务器A改变数据之后无法同步到服务器B，此时就不能保证强一致性和可用性同时满足<ul><li>放弃强一致性（C），用户请求A可以得到最新的数据，用户请求B得到的是旧数据；可以保证用户每次请求都会返回结果，但不能保证数据的一致性</li><li>放弃可用性（A），为了保证数据的强一致性，数据每次修改后都需要等待所有的数据源都同步后才能进行读写，用户请求服务器A或者B，由于数据始终不能同步，最后会一直阻塞下去，不能保证用户的每次都能短时间内得到返回值甚至得不到返回值</li></ul></li></ul><p>综上，我认为的CAP理论是在分布式系统中服务器之间网络出现问题时，CAP最多只能满足其二，并不是分布式系统就只能满足CAP中的两项，理想情况下是都可满足的（虽然现在不大可能）；况且在分布式系统中P是必须满足的，也就是说CA只能满足其一，具体的取舍需要根据不同的业务场景权衡</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><ul><li>Basically Available（基本可用）<ul><li>系统设计中可以牺牲部分可用性，比如允许响应时间增加1-2秒，服务降级等</li></ul></li><li>Soft state（软状态）<ul><li>允许系统中的数据存在中间状态，允许数据同步过程存在延迟</li></ul></li><li>Eventually consistent（最终一致性）<ul><li>所有数据再一段时间的数据同步后都能达到一致的状态 </li></ul></li></ul><p>综上，不同的业务以BASE理论为基础对可用性和一致性进行一个权衡；zk和数据库的主从都是舍弃高可用性；涉及到用户体验的场景则需要舍弃数据强一致性如12306买火车票，618和双11等对于用户的每个请求都需要给与响应，允许存在短时间数据不一致的状态</p><p><a href="http://www.hollischuang.com/archives/666" target="_blank" rel="noopener">参考资料</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CAP理论&quot;&gt;&lt;a href=&quot;#CAP理论&quot; class=&quot;headerlink&quot; title=&quot;CAP理论&quot;&gt;&lt;/a&gt;CAP理论&lt;/h3&gt;&lt;p&gt;Consistency（一致性） Availability（可用性） Partition tolerance（分区容
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>缓存更新的套路 总结与感受</title>
    <link href="http://yoursite.com/2019/08/21/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%A5%97%E8%B7%AF-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%84%9F%E5%8F%97/"/>
    <id>http://yoursite.com/2019/08/21/缓存更新的套路-总结与感受/</id>
    <published>2019-08-21T06:51:35.000Z</published>
    <updated>2019-08-21T06:57:48.631Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注：</strong> 本文是阅读 [缓存更新的套路] (<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17416.html</a>) 一文的总结，本文是以经常用到的Redis+MySQL的角度解读</p><h3 id="经典方法-–-Cache-Aside-Pattern"><a href="#经典方法-–-Cache-Aside-Pattern" class="headerlink" title="经典方法 – Cache Aside Pattern"></a>经典方法 – Cache Aside Pattern</h3><ul><li>读操作：先从Redis中获取，没有命中则从MySQL中获取，最后更新到Redis中</li><li>写操作：先写MySQL，成功后删除Redis中的数据</li></ul><p>为什么这样的方案会是经典方法呢？因为简单，有效，错误少</p><ul><li>场景1–写操作如果先删除Redis中的数据再操作数据库<ul><li>如果一个写操作和读操作并发执行，写操作删除了Redis中的数据还没来得及将数据更新到MySQL中，读操作没有在Redis中读取到数据，而从MySQL中读到旧的数据并更新到了Redis中，这样虽然MySQL中的数据是正确的，因为Redis的存在使得每次读取的数据都是脏数据。（这种情况只会发生在删除Redis数据后，写MySQL前这段时间，因为写MySQL时可以通过加悲观锁来避免问题）</li></ul></li><li>场景2–写操作后增加更新Redis数据<ul><li>这样读和写的操作都会更新Redis数据看似更稳健了，其实不然，更新操作变多了脏数据也会变多，比如有两个写操作a和b，按照请求的时间来说最终的状态应该是b，极端情况下ab都完成了更新数据库的操作，在更新Redis的时候，b先完成了，随后a完成又将Redis数据改成了a的状态，这样还是会存在脏数据 ，虽然出现的概率不大相对于经典方法多了产生脏数据的可能性，所以不可取</li></ul></li><li>场景3–脏数据<ul><li>经典方法可以避免场景1和2的问题，但也不是万无一失的，当一个读操作在Redis中没有命中时，从MySQL中获取了数据，在更新Redis数据之前，有一个写操作完成，此时MySQL的数据已经变了，而读操作会把之前的数据写入Redis中，产生脏数据。而这样的场景发生的几率非常非常小，由于MySQL锁的限制，只能发生在读操作读取数据之后读操作更新Redis数据之前，并且这段时间有一个写操作完成，同样因为锁的存在写操作一般都比读操作会耗时，并且给Redis数据增加过期时间进一步减小脏数据的产生几率</li></ul></li></ul><p>综上所述，虽然经典方法在场景3略有瑕疵，但依然经典可用，因为其简单，有效，错误少</p><h3 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h3><ul><li>读操作：Redis命中直接返回；没有命中从MySQL中读取后更新到Redis中</li><li>写操作：Redis中命中更新Redis；没有命中更新MySQL</li></ul><p>这种模式写操作只针对于一个数据库（MySQL或者Redis），读数据时在Redis中没有命中会从MySQL中读取到Redis中，长时间运行后大部分数据都会在Redis中命中，写操作也会针对于Redis，相当于是强依赖于Redis，弱依赖甚至不依赖于MySQL，这么看来这种方式是最高效的，但是有一个致命的缺点，数据可能会丢失，由于强依赖于Redis中的数据，同样强依赖于Redis的高可用性，当Redis的数据丢失没有很好的灾备的话，数据就没了，这时如果想通过MySQL恢复几乎是不可能的了。总结一下，这种模式有利有弊，具体使用场景需要针对于具体的业务场景，我认为如果有比较好的Redis高可用和灾备的策略，这种模式还是非常好用的。</p><h3 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h3><ul><li>读操作：Redis命中直接返回；没有命中则从MySQL中获取数据返回</li><li>写操作：无论Redis命中与否都先更新Redis，接着异步更新MySQL中的数据</li></ul><p>原文中也提到，这么做会极大的提高I/O，相当于只操作了Redis，是内存级别的读写，同时这么做也有缺点，就是在同步数据到MySQL时如果服务器宕机断电等事故将会永久性的数据丢失</p><h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>摘取了一些大佬们的评论，很有启发</p><ul><li>一位名叫 ty 的大佬说：”Cache Aside Pattern模式，两个更新操作同时进来，也可能会有cache脏数据的问题啊<br>顺序如下：<br>第一个写数据库，第二个写数据库，第二个写cache，第一个写cache<br>这样cache里是第一个数据，而数据库里是第二个“</li><li>——–这和我想的是一样的，哈哈</li></ul><hr><ul><li>一位名叫 letsgowei 的大佬说：”在做更新操作时不可以更改数据库后直接更新缓存吗？这样最多也就一两次脏数据“</li><li>——–这位大佬的疑惑应该是为什么更新操作只是删除缓存或者把缓存设置为无效，而不是更新缓存呢？还有一位评论有同样的疑惑；这个问题我没有考虑到，觉得他们说的有道理直接更新也可以啊？</li><li>一位名叫 longsen 的大佬做出了解答：”1. 读线程查key未在cache中；2.读线程从db读数据；3.写线程更改数据库；4.写线程看key未在cache中，无法更新cache；5.读线程将旧数据写入cache中。这种场景旧数据可能在cache存在很长时间“</li><li>——–大佬给出的解释是cache中没有key无法更新，I don’t think so！至少在Redis的环境下是不存在的，key不存在直接set，key存在直接覆盖，Redis是有这样的命令的，所以这个回答我不同意，如果将写MySQL后将Redis中的key删除的操作，改成更新Redis的Key操作，这样一来就和我上面提到的场景2是一样的的了，读写都更新Redis增加了产生脏数据的概率，所以是不可取的</li></ul><hr><ul><li>一位名叫 泪滴 的大佬说：”大神！你的这个更新顺序是建立在更新数据库，更新缓存都不会发生失败的情况下的，单独考虑并发问题得到的顺序！<br>方案1：先更新数据库，再删除缓存，当出现并发问题概率很小(假设概率为R1)，会造成脏数据。当出现网络等问题导致删除缓存失败(假设概率为R2)，会导致之后的请求一直是脏数据。<br>方案2：先删除缓存，再更新数据库，当出现并发问题概率较大(假设概率为R3)，会导致之后的请求一直是脏数据，当出现网络问题，删除缓存成功，更新数据库失败，只会引发一次cache miss，在业务上基本没啥影响。当然为了弥补，我们一般都会设置缓存的过期时间，来缩短出现脏数据的时间。现在问题的关键就是R1+R2和R3的大小问题了，如果大厂，网络基础设施啥的比较牛，当然R1+R2&lt;R3选择方案1比较合适，对于广大小厂来说还真的可能R1+R2&gt;R3那怎么选择，就比较清楚了。“</li><li>——–说实话，他的评论让我眼前一亮，他的分析具体到了应用场景上，而且确实有这样的情况出现，所以说没有最完美的设计只有最合适的设计，给这位大佬点赞</li></ul><hr><ul><li>还有一些则是针对于原文中Write Behind Caching Pattern部分的流程图的疑问，例如缓存未命中为什么回写数据再更新数据，直接更新数据不就好了吗？写数据未命中为什么还有判断dirty的标志？等等，这些问题我也不懂，云里雾里的，不知道为什么这么设计，不就是异步更新MySQL吗，搞这么复杂是为什么，后来我冷静的分析一下，这篇文章是缓存更新的套路，当前部分是缓存异步更新MySQL的介绍，而流程图和异步半毛钱关系都没有，为什么？</li><li>——–因为我太垃圾了，文章中 xxPattern 指的是Linux内核中的缓存更新模式，作者是将这些模式应用到分布式环境下缓存更新中，所以说这部分的流程图是指Linux内核的缓存更新而不是分布式环境下的缓存更新，作者在文章中不止一次提到了基础很重要就体现出来了，而且作者也提到宏观的系统架构设计其实和计算机系统结构中微观的设计是相似的，所以想要设计好一个大型的分布式系统必须对计算机系统结构非常了解</li></ul><hr><p>综上所述–基础很重要</p><p>以上是我拜读耗子哥的<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">《缓存更新的套路》</a>一文后的一些总结和思考，推荐大家读原文哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 本文是阅读 [缓存更新的套路] (&lt;a href=&quot;https://coolshell.cn/articles/17416.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coolshell.
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>一次Spring事务不回滚的踩坑记录</title>
    <link href="http://yoursite.com/2019/08/16/%E4%B8%80%E6%AC%A1Spring%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%9B%9E%E6%BB%9A%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/08/16/一次Spring事务不回滚的踩坑记录/</id>
    <published>2019-08-16T13:01:13.000Z</published>
    <updated>2019-08-16T13:02:23.912Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一次Spring事务不回滚的踩坑记录"><a href="#一次Spring事务不回滚的踩坑记录" class="headerlink" title="一次Spring事务不回滚的踩坑记录"></a>一次Spring事务不回滚的踩坑记录</h3><p>Spring事务不回滚八成是不知道Spring默认在捕获到unchecked异常才会自动回滚，然而我早已踩过个坑，是一个有经验的人，当我自信满满的加上一行 1/0，并在catch中 throw new RuntimeException，debug之后我懵了，咋不回滚呢？重启Tomcat，浏览器缓存清理之后再试一次，还是不行！！！我就难受了，这和我预想的不一样，检查代码没有发现错误，那咋办呢？开始百度吧，百度的结果千篇一律，都是针对不了解Spring默认捕获unchecked异常的解决办法，这些早已在我的经验里了，有3种方法</p><ul><li>1.手动抛出unchecked异常，让Spring去捕获，然后自动回滚数据</li><li>2.手动回滚，在发生异常的地方添加代码 <strong>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</strong></li><li>3.在注解的地方添加配置<strong>rollbackFor = { Exception.class }</strong>，让Spring在捕获到特定的异常自动回滚数据 </li></ul><p>3种方法我都知道，但是我一般只用第一种，因为简单，这次我选择用第二种方法试下，竟然没问题了，我意识到是我的问题了，开始检查代码，我的代码逻辑如下（见笑）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean result = false;</span><br><span class="line">try &#123;</span><br><span class="line">    // ...业务逻辑</span><br><span class="line">    System.out.println(1/0);</span><br><span class="line">    // ...业务逻辑</span><br><span class="line">    result = true;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">    // rollback</span><br><span class="line">    throw new RuntimeException(e);</span><br><span class="line">    result = false;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是不知道错在哪里，没有办法开始Debug，惊奇的发现RuntimeException竟然被忽略了，这才发现我finally中有return，被我自己蠢哭了，基础真是太重要了，我还盲目自信的知道Spring的事务如何使用，到头来连try catch finally都没搞清楚，真是太蠢了。接着我修改了代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boolean result = false;</span><br><span class="line">try &#123;</span><br><span class="line">    // ...业务逻辑</span><br><span class="line">    System.out.println(1/0);</span><br><span class="line">    // ...业务逻辑</span><br><span class="line">    result = true;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">    // rollback</span><br><span class="line">    throw new RuntimeException(e);</span><br><span class="line">&#125; </span><br><span class="line">return result;</span><br></pre></td></tr></table></figure><p>这下确实是回滚了，但是返回值是true，想得到的时false，这又难受了，再次Debug，很多次F6后我明白了，RuntimeException是被Spring框架里的层层代理catch了————————————————————————————————————————————————————————————–<br>我把我自己给骗了，RuntimeException抛出程序已经终止了，即使再多的catch最后也不会回到result = true那一行，最终得出原因是其他ajax请求的结果返回到了前台给的提示让我误解了</p><hr><p>到这里我意识到自己是真的菜，补习一下try catch finally吧<br>找到<a href="https://blog.csdn.net/mxd446814583/article/details/80355572" target="_blank" rel="noopener">一篇好文</a></p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><ul><li>如果finally中有return，try和catch中的return会失效，并且<strong>catch中即使抛出unchecked异常也同样会失效</strong>（这是今天踩的坑）；如果finally中有异常相当于整个方法有了异常，那么就没有最终的返回值了,catch中有了异常同样的效果，所以catch和finally中不要出现异常</li><li>如果finally中没有return，try和catch中走最先到达return逻辑的地方，并且在return前将返回值暂存，即使finally中修改也不会有效果；（也就是说没有异常最先到达try块中的return，返回值是try块的返回值，catch和finally修改也不会生效；如果try块有异常最先到达catch块中的return，返回值是catch块的返回值，前提是catch块中没有异常，有异常整个方法都没有返回值）</li><li>综上所述，<strong>使用Spring事务避免不出错优先使用方法2和方法3，方法1比较绕并且对有返回值的逻辑不是很友好；finally块中尽量不要return，这样会忽略try和catch中的异常；最后，基础真的很重要</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一次Spring事务不回滚的踩坑记录&quot;&gt;&lt;a href=&quot;#一次Spring事务不回滚的踩坑记录&quot; class=&quot;headerlink&quot; title=&quot;一次Spring事务不回滚的踩坑记录&quot;&gt;&lt;/a&gt;一次Spring事务不回滚的踩坑记录&lt;/h3&gt;&lt;p&gt;Spring
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Optional 使用及源码</title>
    <link href="http://yoursite.com/2019/08/15/Optional/"/>
    <id>http://yoursite.com/2019/08/15/Optional/</id>
    <published>2019-08-15T12:58:37.000Z</published>
    <updated>2019-08-15T13:12:43.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Optional-使用及源码分析"><a href="#Optional-使用及源码分析" class="headerlink" title="Optional 使用及源码分析"></a>Optional 使用及源码分析</h3><p>A container object which may or may not contain a non-null value.</p><p>可能包含空值的容器对象。</p><p>怎么理解呢？就把它当成是和Collection一样的容器，Collection是通过不同的数据结构和API来操作容器中的元素；Optional则是提供API来判断容器中的元素是否为空，在此基础上还能根据是否为空的不同结果给出自定义的处理逻辑。这么说还是很抽象，直接上源码就会好理解一些。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 空的Optional对象</span><br><span class="line">private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();</span><br><span class="line">// 容器中元素的值</span><br><span class="line">private final T value;</span><br></pre></td></tr></table></figure><p>这个value是容器中元素的值，怎么理解呢，使用Optional是要通过它的API进行判空来达到避免NPE的现象，上面说到将Optional当成是一个容器，这个容器中的元素则是需要判空的对象，也就是说容器中的元素就是你传入的参数，这个value就是传参的值</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>无参构造，只是将value置为null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Optional() &#123;</span><br><span class="line">        this.value = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有参构造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Optional(T value) &#123;</span><br><span class="line">    this.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中返回Objects中的requireNonNull的方法，再看这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T requireNonNull(T obj) &#123;</span><br><span class="line">    if (obj == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单如果obj为空抛出异常，不为空返回本身，所以有参构造的效果就是确认value不为空并给value赋值，如果是空就抛异常</p><p>而且这两个构造函数是私有的，也就是说我们不能new出来</p><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><ul><li>empty()–返回空的Optional对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Optional&lt;T&gt; empty() &#123;</span><br><span class="line">    Optional var0 = EMPTY;</span><br><span class="line">    return var0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>of(T var1)–调用了有参构造，即有值返回带有该值得Optional对象，为空则会抛异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Optional&lt;T&gt; of(T var0) &#123;</span><br><span class="line">    return new Optional(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ofNullable(T var0)–元素为null返回空的Option对象，不是null返回本身</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T var0) &#123;</span><br><span class="line">    return var0 == null ? empty() : of(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>get()–从名字就可以看出是获取元素的值，也就是返回value，如果是null的话会抛异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    if (this.value == null) &#123;</span><br><span class="line">        throw new NoSuchElementException(&quot;No value present&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>isPresent()–返回value是否为null</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPresent() &#123;</span><br><span class="line">    return this.value != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ifPresent(Consumer&lt;? super T&gt; var)–如果元素不是空的话执行var1中的逻辑，Consumer之前有文章写过，是接收一个参数执行一个没有返回值得逻辑</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void ifPresent(Consumer&lt;? super T&gt; var1) &#123;</span><br><span class="line">if (this.value != null) &#123;</span><br><span class="line">    var1.accept(this.value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>filter(Predicate&lt;? super T&gt; var1)–首先确保predicate对象和value不是null，然后用predicate对象对value进行筛选，满足条件返回本身，不满足条件返回空的对象（看源码是这个意思，具体怎什么情况用还想不到~）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; var1) &#123;</span><br><span class="line">    Objects.requireNonNull(var1);</span><br><span class="line">    if (!this.isPresent()) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return var1.test(this.value) ? this : empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map(Function&lt;? super T, ? extends U&gt; var1)–同样确保var1不是null，之后value为空值返回空的Optional对象，value有值执行var1中的逻辑</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public &lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; var1) &#123;</span><br><span class="line">    Objects.requireNonNull(var1);</span><br><span class="line">    return !this.isPresent() ? empty() : ofNullable(var1.apply(this.value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flatMap(Function&lt;? super T, Optional&lt; U &gt;&gt; var1)–与map方法相同,不同的是入参，根据不同的参数结构使用不同的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public &lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; var1) &#123;</span><br><span class="line">    Objects.requireNonNull(var1);</span><br><span class="line">    return !this.isPresent() ? empty() : (Optional)Objects.requireNonNull(var1.apply(this.value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>T orElse(T var1)–获取value的值，不为空返回本身，为空返回入参var1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public T orElse(T var1) &#123;</span><br><span class="line">    return this.value != null ? this.value : var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>T orElseGet(Supplier&lt;? extends T&gt; var1)–与orElse的逻辑一样，不同的是value为空返回的是supplier对象的逻辑</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public T orElseGet(Supplier&lt;? extends T&gt; var1) &#123;</span><br><span class="line">    return this.value != null ? this.value : var1.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>T orElseThrow(Supplier&lt;? extends X&gt; var1)–同样的逻辑，不同的是value为null会抛异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; var1) throws X &#123;</span><br><span class="line">    if (this.value != null) &#123;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw (Throwable)var1.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>of和ofNullable<ul><li>都是取值，如果元素是null的话of会报空指针–不用，ofNullable将null转为空的对象没有空指针；</li><li>get方法同样是取值，value是null也会抛异常–不用</li><li>最后，取值用ofNullable就完事了</li></ul></li><li>isPresent和ifPresent<ul><li>isPresent返回元素是否为null，有返回值</li><li>ifPresent元素不为空执行一段逻辑，无返回值</li><li>最后，只判断用isPresent有逻辑用ifPresent</li></ul></li><li>filter、map和flatMap<ul><li>都是将不是null的元素执行传入的逻辑，根据不同的需求选择方法</li></ul></li><li>orElse、orElseGet和orElseThrow<ul><li>都是将null的元素做转换，orElse返回传入的值，orElseGet返回传入的逻辑，这两个方法看需求没有逻辑有orElse有逻辑用orElseGet；orElseThrow元素为null抛异常–不用</li></ul></li></ul><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>刚刚学习还不知道怎么使用，看到[一篇文章]（<a href="https://www.cnblogs.com/rjzheng/p/9163246.html）" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9163246.html）</a> 给的栗子不错，很有借鉴意义，但是我对这篇文章中的orElse和orElseGet的栗子有不同意见。</p><h5 id="栗子1"><a href="#栗子1" class="headerlink" title="栗子1"></a>栗子1</h5><ul><li>使用前</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public String getCity(User user)  throws Exception&#123;</span><br><span class="line">    if(user!=null)&#123;</span><br><span class="line">        if(user.getAddress()!=null)&#123;</span><br><span class="line">            Address address = user.getAddress();</span><br><span class="line">            if(address.getCity()!=null)&#123;</span><br><span class="line">                return address.getCity();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new Excpetion(&quot;取值错误&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用后</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String getCity(User user) throws Exception&#123;</span><br><span class="line">    return Optional.ofNullable(user)</span><br><span class="line">                   .map(u-&gt; u.getAddress())</span><br><span class="line">                   .map(a-&gt;a.getCity())</span><br><span class="line">                   .orElseThrow(()-&gt;new Exception(&quot;取指错误&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="栗子2"><a href="#栗子2" class="headerlink" title="栗子2"></a>栗子2</h5><ul><li>使用前</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(user!=null)&#123;</span><br><span class="line">    dosomething(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用后</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(user)</span><br><span class="line">        .ifPresent(u-&gt;&#123;</span><br><span class="line">           dosomething(u);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h5 id="栗子3"><a href="#栗子3" class="headerlink" title="栗子3"></a>栗子3</h5><ul><li>使用前</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public User getUser(User user) throws Exception&#123;</span><br><span class="line">if(user!=null)&#123;</span><br><span class="line">    String name = user.getName();</span><br><span class="line">    if(&quot;zhangsan&quot;.equals(name))&#123;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    user = new User();</span><br><span class="line">    user.setName(&quot;zhangsan&quot;);</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用后</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public User getUser(User user) &#123;</span><br><span class="line">    return Optional.ofNullable(user)</span><br><span class="line">                   .filter(u-&gt;&quot;zhangsan&quot;.equals(u.getName()))</span><br><span class="line">                   .orElseGet(()-&gt; &#123;</span><br><span class="line">                        User user1 = new User();</span><br><span class="line">                        user1.setName(&quot;zhangsan&quot;);</span><br><span class="line">                        return user1;</span><br><span class="line">                   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Optional-使用及源码分析&quot;&gt;&lt;a href=&quot;#Optional-使用及源码分析&quot; class=&quot;headerlink&quot; title=&quot;Optional 使用及源码分析&quot;&gt;&lt;/a&gt;Optional 使用及源码分析&lt;/h3&gt;&lt;p&gt;A container ob
      
    
    </summary>
    
      <category term="Java8" scheme="http://yoursite.com/categories/Java8/"/>
    
    
      <category term="Java8" scheme="http://yoursite.com/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>mac 设置</title>
    <link href="http://yoursite.com/2019/08/13/mac-%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/08/13/mac-设置/</id>
    <published>2019-08-13T08:44:33.000Z</published>
    <updated>2019-08-13T09:14:55.008Z</updated>
    
    <content type="html"><![CDATA[<h6 id="外接键盘的调整"><a href="#外接键盘的调整" class="headerlink" title="外接键盘的调整"></a>外接键盘的调整</h6><p>键盘设置中将control和command互换就可以达到和Windows下的复制粘贴时一样的，切换程序则由alt+tab变成了ctrl+tab需要适应一下，不过复制，粘贴，撤销，保存这些不用再去适应新的快捷键了<br><img src="/images/pasted-14.png" alt="upload successful"></p><h6 id="idea中的调整"><a href="#idea中的调整" class="headerlink" title="idea中的调整"></a>idea中的调整</h6><p>preferences中找到keymap选择Eclipse(macOS)，这样加上第一步的配置复制粘贴这些快捷键与Windows相同，不用再去适应新的快捷键</p><h6 id="自动补全变量"><a href="#自动补全变量" class="headerlink" title="自动补全变量"></a>自动补全变量</h6><p>keymap中搜索variable   默认为：option+command+L 通过以上设置后为：Ctrl+alt+L</p><h5 id="另一种使用方法"><a href="#另一种使用方法" class="headerlink" title="另一种使用方法"></a>另一种使用方法</h5><p>不做任何配置，idea中使用eclipse风格的快捷键，idea中的使用不影响，但是在idea以外就得适应mac中的快捷键，感觉还是这个方法更容易接受一些</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;外接键盘的调整&quot;&gt;&lt;a href=&quot;#外接键盘的调整&quot; class=&quot;headerlink&quot; title=&quot;外接键盘的调整&quot;&gt;&lt;/a&gt;外接键盘的调整&lt;/h6&gt;&lt;p&gt;键盘设置中将control和command互换就可以达到和Windows下的复制粘贴时一样的，切换程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="http://yoursite.com/2019/08/05/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/05/Lambda表达式/</id>
    <published>2019-08-05T01:06:59.000Z</published>
    <updated>2019-08-05T01:10:06.276Z</updated>
    
    <content type="html"><![CDATA[<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>包含3个部分：参数 -&gt; 表达式/代码块</p><ul><li>(params) -&gt; expression</li><li>(params) -&gt; statement</li><li>(params) -&gt; { statements }</li></ul><p><strong>与内部类相同，lambda表达式不可以修改外部变量，这点与匿名内部类相同，不同的是lambda表达式不用将变量显示的声名为final，如果是在自己的作用域中定义局部变量可以进行修改，最终保证线程安全</strong></p><p><strong>（踩坑）lambda表达式中的this并不是代表当前使用lambda表达式的对象，而是外部类的对象</strong></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><h5 id="可代替匿名内部类"><a href="#可代替匿名内部类" class="headerlink" title="可代替匿名内部类"></a>可代替匿名内部类</h5><ul><li>可以代替只包含一个抽象方法的接口，也叫做函数式接口，例如；Comparator、Runnable</li><li>Java8内置了四大函数式接口分别为：Consumer，Supplier，Function，Predicate</li><li>jdk8中提供@FunctionalInterface 注解来检查接口是否符号函数式接口的标准</li></ul><h5 id="可代替迭代操作"><a href="#可代替迭代操作" class="headerlink" title="可代替迭代操作"></a>可代替迭代操作</h5><ul><li>list.forEach(n -&gt; {});</li></ul><h5 id="通过Stream操作集合"><a href="#通过Stream操作集合" class="headerlink" title="通过Stream操作集合"></a>通过Stream操作集合</h5><ul><li>list.stream().filter()…collect();</li></ul><h5 id="对数据处理"><a href="#对数据处理" class="headerlink" title="对数据处理"></a>对数据处理</h5><ul><li>与Spark相似java8可以将集合转化为流（Stream），在对流进行map和reduce操作，与Spark相同这些方法也是惰性求值的</li></ul><h4 id="Java8的函数式接口"><a href="#Java8的函数式接口" class="headerlink" title="Java8的函数式接口"></a>Java8的函数式接口</h4><h5 id="消费型接口-Consumer"><a href="#消费型接口-Consumer" class="headerlink" title="消费型接口 Consumer"></a>消费型接口 Consumer<t></t></h5><ul><li>抽象方法-void accept(T t);</li><li>参数类型-T</li><li>返回类型-void</li></ul><p>这个还没有用过，因为返回值为空并且传递一个参数，我感觉和集合的遍历差不多 list.forEach(n -&gt; sout(n)); 通过定义多个Consumer对象相当于定义多个逻辑块，最终consumer1.addThen(consumer2) 连接，也就是说consumer1逻辑完成后执行consumer2（为什么不写在一个逻辑里呢？我猜可能需要解耦吧）</p><h5 id="供给型接口-Supplier"><a href="#供给型接口-Supplier" class="headerlink" title="供给型接口 Supplier"></a>供给型接口 Supplier<t></t></h5><ul><li>抽象方法-T get();</li><li>参数类型-无参数</li><li>返回类型-T</li><li>这个感觉很简单，没有参数但要返回一个值，可能new一个对象的时候会用到吧，声名Supplier对象后直接调用get执行定义的逻辑（箭头后面的逻辑）返回一个值</li></ul><h5 id="函数型接口-Function-lt-T-R-gt"><a href="#函数型接口-Function-lt-T-R-gt" class="headerlink" title="函数型接口 Function&lt;T,R&gt;"></a>函数型接口 Function&lt;T,R&gt;</h5><ul><li>抽象方法-R apply(T t)</li><li>参数类型-T</li><li>返回类型-R</li></ul><p>同样是创建Function对象定义一个方法逻辑，接口中有Consumer接口同样的实现方法andThen，用法也相同，不同的是Function定义中有返回值，fun1.addThen(fun2)是将fun1执行的返回值传入fun2中再执行fun2中的逻辑，除此之外该接口还有一个实现方法compose，用法和andThen相反，fun1.compose(fun2) 是先执行fun2中的逻辑将返回值作为参数传入fun1中再执行fun1中的逻辑</p><h5 id="断言型接口-Predicate"><a href="#断言型接口-Predicate" class="headerlink" title="断言型接口 Predicate"></a>断言型接口 Predicate<t></t></h5><ul><li>抽象方法-boolean test(T t)</li><li>参数类型-T</li><li>返回类型-boolean</li><li>定义的Predicate对象相当于筛选条件的对象，最终通过stream中的filter进行过滤，多个条件可以用and和or来进行组合相当于运算符 &amp;&amp; 和 ||</li><li>多用做集合筛选 eg:</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 筛选大于18岁的女性用户</span><br><span class="line">Predicate&lt;User&gt; matchAge = u -&gt; u.age &gt; 18;</span><br><span class="line">Predicate&lt;User&gt; matchSex = u -&gt; u.sex.equals(&quot;f&quot;);</span><br><span class="line">resultList = userList.stream().filter(matchAge.and(matchSex)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li></ul><p>我的理解是在定义Predicate的对象时，-&gt; 前传入参数， -&gt; 后定义test的方法体，最终补充抽象方法test，通过stream的filter筛选相当于将集合中的每个元素都调用一次test方法，将返回值为true的筛选出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h4&gt;&lt;p&gt;包含3个部分：参数 -&amp;gt; 表达式/代码块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(params) -&amp;gt; expression&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Java8" scheme="http://yoursite.com/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>StringUtils</title>
    <link href="http://yoursite.com/2019/07/26/StringUtils/"/>
    <id>http://yoursite.com/2019/07/26/StringUtils/</id>
    <published>2019-07-26T11:32:04.000Z</published>
    <updated>2019-07-26T11:35:18.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="StringUtils"><a href="#StringUtils" class="headerlink" title="StringUtils"></a>StringUtils</h2><ul><li>工作中很多操作字符串的操作，使用到了工具类这里总结下，org.apache.commons.lang3包下的</li></ul><h3 id="split-String-str-String-separatorChars-–-gt-切分字符串"><a href="#split-String-str-String-separatorChars-–-gt-切分字符串" class="headerlink" title="split(String str, String separatorChars)–&gt;切分字符串"></a>split(String str, String separatorChars)–&gt;切分字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String[] split(String str, String separatorChars) &#123;</span><br><span class="line">    return splitWorker(str, separatorChars, -1, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>int max -&gt;the maximum number of elements to include in the array. A zero or negative value implies no limit.<br>这个参数代表返回的字符串的最大长度，0或者-1代表不限制长度</li><li>boolean preserveAllTokens -&gt; if {@code true}, adjacent separators are treated as empty token separators; if {@code false}, adjacent separators are treated as one separator. 这个参数是连续分隔符规则的标志，如果为true连续的分隔符都会匹配，最终得到的字符串数组会有空的值，jdk中的split就是这个规则；如果为false，连续的分隔符只会匹配一次，最终得到的数组不会有空值。eg(“1,2,3,,4,5”切分后，true得到[1,2,3,,4,5]而false得到[1,2,3,4,5])，</li><li>这也是与jdk中的split方法的区别，如果需要使用与jdk相同的规则，工具类中的splitPreserveAllTokens方法可以实现，该方法会调用splitWorker方法且最后的参数为true</li></ul><p>所以split方法默认参数为-1和false表示数组长度不收限制，及使用第二个规则进行切割，确保得到的字符串数组没有空值<br>原理：</p><ul><li>先将字符串与分隔符做匹配</li><li>匹配到之后将分隔符之前的子串分割add到一个list集合中</li><li>最后使用list.toArray返回最终的数组</li></ul><h4 id="join-待续"><a href="#join-待续" class="headerlink" title="join  待续"></a>join  待续</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;StringUtils&quot;&gt;&lt;a href=&quot;#StringUtils&quot; class=&quot;headerlink&quot; title=&quot;StringUtils&quot;&gt;&lt;/a&gt;StringUtils&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;工作中很多操作字符串的操作，使用到了工具类这里总结下，o
      
    
    </summary>
    
    
      <category term="utils" scheme="http://yoursite.com/tags/utils/"/>
    
  </entry>
  
  <entry>
    <title>Arrays</title>
    <link href="http://yoursite.com/2019/07/26/Arrays/"/>
    <id>http://yoursite.com/2019/07/26/Arrays/</id>
    <published>2019-07-26T11:31:27.000Z</published>
    <updated>2019-07-29T07:50:19.522Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h4 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看要被拷贝到的数组长度是不是够用，够用的话直接调用System.arraycopy方法；不够用创建一个新的与源数组同样长度的数组进行拷贝<br><strong>如果数组中是引用类型，Arrays.copy拷贝的是引用，不会新创建对象，如果要对拷贝的数组做修改操作源数组同样会受到影响，而字符串数组由于字符串常量池的存在，当修改字符串的时候会新创建一个字符串并将新的引用付给数组，所以源数组对应的字符串并不会发生变化</strong></p><h5 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy"></a>System.arraycopy</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static native void arraycopy(Object src,  int  srcPos,</span><br><span class="line">                                    Object dest, int destPos,</span><br><span class="line">                                    int length);</span><br></pre></td></tr></table></figure><p>这是一个本地方法，就看一下参数吧</p><ul><li>src—-the source array. </li><li>srcPos—-starting position in the source array.</li><li>dest—-the destination array.</li><li>destPos—-starting position in the destination data.</li><li>length—-the number of array elements to be copied.</li></ul><h4 id="asList"><a href="#asList" class="headerlink" title="asList"></a>asList</h4><p>将字符串转成ArrayList集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class="line">    return new ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的ArrayList是Arrays中的一个内部类，继承了AbstractList方法，内部值实现了部分方法，简单点说这个集合是只读的，不能进行修改和删除操作，因为没有重写相关的方法。</p><h4 id="copyOfRange"><a href="#copyOfRange" class="headerlink" title="copyOfRange"></a>copyOfRange</h4><p>按照范围拷贝数组 [from,to) 左开右闭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T[] copyOfRange(T[] original, int from, int to) &#123;</span><br><span class="line">    return copyOfRange(original, from, to, (Class&lt;? extends T[]&gt;) original.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>集合工具类 Collections.sort 其实就是调用 Arrays.sort 方法对集合进行排序的，该方法先调用 toArray 方法将集合转成object数组，然后再调用 Arrays.sort 方法对数组进行排序，最后再将排序号的数组通过迭代器set到新的集合中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Object[] a) &#123;</span><br><span class="line">    if (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a);</span><br><span class="line">    else</span><br><span class="line">        ComparableTimSort.sort(a, 0, a.length, null, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到sort方法是通过userRequested的标志来选中排序的方式，从jdk7以后默认为false，使用TimSort的方式排序，（通过System.setProperty(“java.util.Arrays.useLegacyMergeSort”, “true”)修改）</p><ul><li>userRequested为true使用LegacyMergeSort的方式进行排序，当数组长度小于7时使用插入排序，当数组长度大于7时使用归并排序，归并到长度小于7的长度再次使用插入排序</li><li>userRequested为false采用TimSort的方式排序</li></ul><h5 id="TimSort"><a href="#TimSort" class="headerlink" title="TimSort"></a>TimSort</h5><ul><li>1.数组长度小于32时，首先在数组中从开头开始寻找升序的子数组，没有的话找降序的子数组再反转，然后将数组中的剩余元素使用二分查找的方式插入到子数组中</li><li>2.数组长度大于32时，将数组切分若干个长度在[16,32)的区块（jdk里叫run，我理解为区块）</li><li>3.每个区块再使用第一步的方式进行排序排序后将每个区块进行合并，合并的过程有两点优化<ul><li>a.合并区块的过程中通过限制条件来完成将连续的三个区块中较小的两个优先合并降低复杂度</li><li>b.两个区块合并时，先将区块1的头元素和尾元素插入到区块2中，相当于缩小了插入区块2的范围降低复杂度</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) &#123;</span><br><span class="line">    assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">    int nRemaining  = hi - lo;</span><br><span class="line">    if (nRemaining &lt; 2)</span><br><span class="line">        return;  // Arrays of size 0 and 1 are always sorted</span><br><span class="line"></span><br><span class="line">    // If array is small, do a &quot;mini-TimSort&quot; with no merges</span><br><span class="line">    if (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">        int initRunLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line">        binarySort(a, lo, hi, lo + initRunLen);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * March over the array once, left to right, finding natural runs,</span><br><span class="line">     * extending short natural runs to minRun elements, and merging runs</span><br><span class="line">     * to maintain stack invariant.</span><br><span class="line">     */</span><br><span class="line">    ComparableTimSort ts = new ComparableTimSort(a, work, workBase, workLen);</span><br><span class="line">    int minRun = minRunLength(nRemaining);</span><br><span class="line">    do &#123;</span><br><span class="line">        // Identify next run</span><br><span class="line">        int runLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line"></span><br><span class="line">        // If run is short, extend to min(minRun, nRemaining)</span><br><span class="line">        if (runLen &lt; minRun) &#123;</span><br><span class="line">            int force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">            binarySort(a, lo, lo + force, lo + runLen);</span><br><span class="line">            runLen = force;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Push run onto pending-run stack, and maybe merge</span><br><span class="line">        ts.pushRun(lo, runLen);</span><br><span class="line">        ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">        // Advance to find next run</span><br><span class="line">        lo += runLen;</span><br><span class="line">        nRemaining -= runLen;</span><br><span class="line">    &#125; while (nRemaining != 0);</span><br><span class="line"></span><br><span class="line">    // Merge all remaining runs to complete sort</span><br><span class="line">    assert lo == hi;</span><br><span class="line">    ts.mergeForceCollapse();</span><br><span class="line">    assert ts.stackSize == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Arrays&quot;&gt;&lt;a href=&quot;#Arrays&quot; class=&quot;headerlink&quot; title=&quot;Arrays&quot;&gt;&lt;/a&gt;Arrays&lt;/h3&gt;&lt;h4 id=&quot;copyOf&quot;&gt;&lt;a href=&quot;#copyOf&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="jdk" scheme="http://yoursite.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList</title>
    <link href="http://yoursite.com/2019/07/26/ArrayList/"/>
    <id>http://yoursite.com/2019/07/26/ArrayList/</id>
    <published>2019-07-26T11:31:05.000Z</published>
    <updated>2019-08-05T01:13:45.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="toArray-T-a"><a href="#toArray-T-a" class="headerlink" title="toArray(T[] a)"></a>toArray(T[] a)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    if (a.length &lt; size)</span><br><span class="line">        // Make a new array of a&apos;s runtime type, but my contents:</span><br><span class="line">        return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">    if (a.length &gt; size)</span><br><span class="line">        a[size] = null;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了Arrays.copyOf方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h3&gt;&lt;h4 id=&quot;toArray-T-a&quot;&gt;&lt;a href=&quot;#toArray-T-a&quot; c
      
    
    </summary>
    
    
      <category term="collections" scheme="http://yoursite.com/tags/collections/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis入门（续）-CRUD</title>
    <link href="http://yoursite.com/2019/07/12/MyBatis%E5%85%A5%E9%97%A8%E7%BB%AD-CRUD%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/07/12/MyBatis入门续-CRUD测试/</id>
    <published>2019-07-12T08:04:18.000Z</published>
    <updated>2019-11-13T06:27:22.176Z</updated>
    
    <content type="html"><![CDATA[<h4 id="根据用户名查询"><a href="#根据用户名查询" class="headerlink" title="根据用户名查询"></a>根据用户名查询</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUserByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.example.mybatisdemo.bean.User&quot;&gt;</span><br><span class="line">        SELECT * FROM users WHERE name = #&#123;VALUE&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.selectOne(&quot;test.findUserByName&quot;, &quot;yywang&quot;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="模糊查询，返回多个值"><a href="#模糊查询，返回多个值" class="headerlink" title="模糊查询，返回多个值"></a>模糊查询，返回多个值</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUserLikeName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.example.mybatisdemo.bean.User&quot;&gt;</span><br><span class="line">        SELECT * FROM users WHERE name like #&#123;VALUE&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.selectList(&quot;test.findUserLikeName&quot;, &quot;%yy%&quot;);</span><br></pre></td></tr></table></figure></li></ul><p>查询的resutlType分三种情况</p><ul><li>基本类型：resultType=”基本类型”</li><li>List类型：resultType=”List集合中的元素类型”</li><li>Map类型：<ul><li>单条记录 resultType=”java.util.Map”</li><li>多条记录 resultType=”Map中value的类型”</li></ul></li></ul><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.example.mybatisdemo.bean.User&quot;&gt;</span><br><span class="line">        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">            SELECT LAST_INSERT_ID()</span><br><span class="line">        &lt;/selectKey&gt;</span><br><span class="line">        INSERT into users(uname,sex,age,udesc) values (#&#123;uname&#125;,#&#123;sex&#125;,#&#123;age&#125;,#&#123;udesc&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = new User(&quot;bangni&quot;,&quot;female&quot;,22,&quot;tc&quot;);</span><br><span class="line">sqlSession.commit(); // 必加</span><br></pre></td></tr></table></figure><h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><ul><li><em>selectKey</em> 用来配置返回主键 </li><li><em>keyProperty</em>  表中主键的名称</li><li><em>order</em> 表示SELECT LAST_INSERT_ID()在insert语句发生的顺序，after意为insert执行之后返回，用于自增主键，UUID的方式可以配置为before</li><li><em>resultType</em> 返回值类型</li></ul><p><strong><em>注1：sql语句中有多个参数，占位符#{}也需要指定不同的表示方式，如上#{uname},#{sex}等</em></strong></p><p><strong><em>注2：sql没问题运行报错，因为之前的数据表设计问题，name和desc是关键字，这里开始做了修改</em></strong></p><p><strong><em>注3：修改之后运行通过，数据库查不到记录，想到之前测试Junit回自动回滚，于是添加@Rollback注解导入依赖后还是无果，最终加上session.commit()解决，由于MyBatis接管了JDBC的事务管理器，JDBC回自动提交而MyBatis不会，这里需要自行手动提交，修改删除同样</em></strong></p></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete id=&quot;delUserById&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">        delete from users where id = #&#123;id&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.delete(&quot;test.delUserById&quot;,3);</span><br><span class="line">  sqlSession.commit();</span><br></pre></td></tr></table></figure></li></ul><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;updateUserById&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">        update users set age = 0 where id = #&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.update(&quot;test.updateUserById&quot;,8);</span><br><span class="line">  sqlSession.commit();</span><br></pre></td></tr></table></figure></li></ul><h4 id="查看最后执行的SQL"><a href="#查看最后执行的SQL" class="headerlink" title="查看最后执行的SQL"></a>查看最后执行的SQL</h4><p>只需在配置文件中添加配置即可打印查询语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;根据用户名查询&quot;&gt;&lt;a href=&quot;#根据用户名查询&quot; class=&quot;headerlink&quot; title=&quot;根据用户名查询&quot;&gt;&lt;/a&gt;根据用户名查询&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>IDEA配置Junit测试</title>
    <link href="http://yoursite.com/2019/07/12/IDEA%E9%85%8D%E7%BD%AEJunit%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/07/12/IDEA配置Junit测试/</id>
    <published>2019-07-12T07:10:02.000Z</published>
    <updated>2019-07-12T07:28:44.583Z</updated>
    
    <content type="html"><![CDATA[<p>看了很多博客后感觉还是比较乱，这篇还不错马一下<br><em><a href="https://blog.csdn.net/hanchao5272/article/details/79197989" target="_blank" rel="noopener">https://blog.csdn.net/hanchao5272/article/details/79197989</a></em></p><h4 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1.安装插件"></a>1.安装插件</h4><p>File-&gt;setting-&gt;Plugins-&gt;搜索并安装Junit Generator 2.0-&gt;重启IDEA</p><h4 id="2-配置插件"><a href="#2-配置插件" class="headerlink" title="2.配置插件"></a>2.配置插件</h4><p>File-&gt;setting-&gt;    OtherSettings-&gt;Junit Generator-&gt;properties</p><ul><li>修改<em>Output Path[输出路径]</em>为<em>${SOURCEPATH}/../../test/java/${PACKAGE}/${FILENAME}</em></li><li>修改 Default Template[默认模板]为JUnit4</li><li>选中JUnit4页签，将<em>package test.$entry.packageName;</em> 修改成<em>package $entry.packageName;</em></li></ul><h4 id="3-配置测试的目录"><a href="#3-配置测试的目录" class="headerlink" title="3.配置测试的目录"></a>3.配置测试的目录</h4><p>File-&gt;Project Structure-&gt;Modules中将测试目录设置为Test Source Floder</p><h4 id="4-生成测试类"><a href="#4-生成测试类" class="headerlink" title="4.生成测试类"></a>4.生成测试类</h4><ul><li>在要测试的类中用快捷键 alt+insert -&gt; Junit Test -&gt; Junit4</li></ul><h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h4><ul><li>鼠标右键菜单<ul><li>将鼠标光标放在方法相关代码中，右键弹出菜单中会显示运行此测试方法的菜单，点击就会运行方法单独测试。<br>将鼠标光标放在方法之外的代码中，右键弹出菜单中会显示运行此类的所有测试方法的菜单，点击就会运行所有测试方法。</li></ul></li><li>快捷键<ul><li>将鼠标光标放在方法相关代码中，通过快捷键Ctrl+Shift+F10，运行当前测试方法。</li><li>将鼠标光标放在方法之外的代码中，通过快捷键Ctrl+Shift+F10，运行当前类的所有测试方法。</li></ul></li><li>快捷按钮<ul><li>点击方法左侧的Run Test按钮，运行当前测试方法。</li><li>点击类左侧的Run Test按钮，运行当前类的所有测试方法。</li></ul></li></ul><h4 id="6-测试结果"><a href="#6-测试结果" class="headerlink" title="6.测试结果"></a>6.测试结果</h4><p><img src="/images/pasted-12.png" alt="upload successful"></p><ul><li>1.方法测试成功</li><li>2.方法测试失败</li><li>3.测试用时（毫秒）</li><li>4.期望值</li><li>5.实际值</li><li>6.异常信息</li></ul><h4 id="7-异常"><a href="#7-异常" class="headerlink" title="7.异常"></a>7.异常</h4><ul><li><img src="/images/pasted-13.png" alt="upload successful"></li><li>原因：4.11以上版本不在包含hamcrest</li><li>解决：改用4.10  ^_^</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看了很多博客后感觉还是比较乱，这篇还不错马一下&lt;br&gt;&lt;em&gt;&lt;a href=&quot;https://blog.csdn.net/hanchao5272/article/details/79197989&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
      <category term="IDEA" scheme="http://yoursite.com/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis入门</title>
    <link href="http://yoursite.com/2019/07/12/MyBatis%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/07/12/MyBatis入门/</id>
    <published>2019-07-12T05:16:20.000Z</published>
    <updated>2019-11-06T05:53:15.438Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MyBatis环境"><a href="#MyBatis环境" class="headerlink" title="MyBatis环境"></a>MyBatis环境</h4><h5 id="首先准备数据库表"><a href="#首先准备数据库表" class="headerlink" title="首先准备数据库表"></a>首先准备数据库表</h5><ul><li>对应的实体类为</li></ul><ul><li><figure class="highlight plain"><figcaption><span>class User &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> private int id;</span><br><span class="line"> private String name;</span><br><span class="line"> private String sex;</span><br><span class="line"> private int age;</span><br><span class="line"> private String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="数据库配置文件-SqlMapConfig-xml"><a href="#数据库配置文件-SqlMapConfig-xml" class="headerlink" title="数据库配置文件 SqlMapConfig.xml"></a>数据库配置文件 <em>SqlMapConfig.xml</em></h5><ul><li>配置数据库环境相关</li></ul><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line"> &lt;/environments&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="sql映射文件-user-xml"><a href="#sql映射文件-user-xml" class="headerlink" title="sql映射文件 user.xml"></a>sql映射文件 <em>user.xml</em></h5><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;test&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.example.mybatisdemo.bean.User&quot;&gt;</span><br><span class="line">        SELECT * FROM user WHERE id =#&#123;VALUE&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="将sql映射添加到SqlMapConfig-xml中"><a href="#将sql映射添加到SqlMapConfig-xml中" class="headerlink" title="将sql映射添加到SqlMapConfig.xml中"></a>将sql映射添加到SqlMapConfig.xml中</h5><ul><li>最终的配置文件为</li></ul><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;mapper/user.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession sqlSession = factory.openSession();</span><br><span class="line">        // 参数1 sql映射中的 namespace + &quot;.&quot; + sqlId</span><br><span class="line">        // 参数2为sql的参数</span><br><span class="line">        User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        sqlSession.close();</span><br></pre></td></tr></table></figure></li></ul><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p><em>基于sql语句的轻量级ORM框架，将sql语句写入配置文件映射中，进一步解耦，但是多了一步操作感觉比hibernate繁琐一些，但是比hibernate要快，有舍有得吧（为什么快还不知道，后续再看吧╮(╯▽╰)╭ ）</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MyBatis环境&quot;&gt;&lt;a href=&quot;#MyBatis环境&quot; class=&quot;headerlink&quot; title=&quot;MyBatis环境&quot;&gt;&lt;/a&gt;MyBatis环境&lt;/h4&gt;&lt;h5 id=&quot;首先准备数据库表&quot;&gt;&lt;a href=&quot;#首先准备数据库表&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC入门</title>
    <link href="http://yoursite.com/2019/07/11/SpringMVC/"/>
    <id>http://yoursite.com/2019/07/11/SpringMVC/</id>
    <published>2019-07-11T07:22:35.000Z</published>
    <updated>2019-07-12T05:15:14.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC配置"><a href="#SpringMVC配置" class="headerlink" title="SpringMVC配置"></a>SpringMVC配置</h2><p><em>注解&amp;配置文件</em></p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h4><ul><li><p><img src="/images/pasted-5.png" alt="upload successful"></p></li><li><p>①指定Spring配置文件的位置</p></li><li><p>②配置Listener，初始化SpringIOC容器</p></li><li><p>③配置前端控制器servlet，其中可以自定义配置文件位置，不配置默认寻找xxxx-servlet.xml的配置文件</p></li><li><p>url-pattern中/和/*区别</p><ul><li>/*    匹配所有url  有后缀或者无后缀都会匹配   .jsp  .css  .js</li><li>/      只匹配无后缀的url</li></ul></li></ul><p><strong><em>注：截图为项目中的配置  自己测试时改为 /  项目中拦截所有页面应该会有拦截器或者过滤器做处理，demo中如果配置成截图这样会报错</em></strong></p><h4 id="springmvc-servlet-xml"><a href="#springmvc-servlet-xml" class="headerlink" title="springmvc-servlet.xml"></a>springmvc-servlet.xml</h4><p><img src="/images/pasted-6.png" alt="upload successful"></p><ul><li><p>指定基础包名scan，将指定的包名注入SpringIOC容器（先要添加context的xsd约束）</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br></pre></td></tr></table></figure><p>xsi中添加<br>“<a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a>       <a href="http://www.springframework.org/schema/context/spring-context.xsd&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/context/spring-context.xsd&quot;</a></p></li></ul></li></ul><ul><li><p>exclude-filter 指定类与Spring容器分开加载（先这么理解）</p></li><li><p>配置视图解析器（前缀和后缀）</p></li></ul><p><strong>方法中使用@RequestMapping(value=”search”)  理解为匹配URL中search的字样</strong></p><p><strong>方法return “iface/manage”;  从匹配的前后缀中寻找应该返回的视图，例如通过上图的配置找到/iface/manage.vm</strong></p><p><em>在Controller类上添加@Controller，方法上添加@RequestMapping(“xxxx”)，即可完成映射</em></p><h4 id="配置完成访问报错"><a href="#配置完成访问报错" class="headerlink" title="配置完成访问报错"></a>配置完成访问报错</h4><p><img src="/images/pasted-7.png" alt="upload successful"></p><ul><li><p>没有jstl标签库，导入依赖即可</p></li><li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="web-xml-1"><a href="#web-xml-1" class="headerlink" title="web.xml"></a>web.xml</h4><ul><li>和注解方式一样<br><img src="/images/pasted-8.png" alt="upload successful"><h4 id="springmvc-servlet-xml-1"><a href="#springmvc-servlet-xml-1" class="headerlink" title="springmvc-servlet.xml"></a>springmvc-servlet.xml</h4></li><li><img src="/images/pasted-9.png" alt="upload successful"></li><li>①配置处理器映射器</li><li>②配置处理器适配器</li><li>③配置视图解析器（同注解方式）</li><li>④配置映射（相当于注解中的@RequestMapping）</li></ul><p><em>相较于注解方式该配置文件中多了对 处理器映射器、处理器适配器 以及映射的配置</em></p><p><em>实现方面在controller类中不添加任何注解，实现Controller接口，重写方法即可</em></p><p>demo：<a href="https://github.com/panniyuyu/frameworkdemo.git" target="_blank" rel="noopener">https://github.com/panniyuyu/frameworkdemo.git</a></p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>通过使用不同方式对springMVC进行配置，感觉对SpringMVC框架大致的原理有一些认识</p><p>SpringMVC使将MVC的模式进一步拆分解耦，整个过程主要包含4个主要的部分依次是 前端控制器（DispatcherServlet）、处理器映射器（HandlerMapping）、处理器适配器（HandlerAdapter）、视图解析器（ViewResolver）</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><ul><li>1.用户发起请求，被前端控制器（DispatcherServlet）拦截，并根据请求内容询问处理器映射器（HandlerMapping）改请求应该由哪个Controller处理，处理器映射器将匹配到的Controller信息返回给前端控制器</li><li>2.前端控制器知道该请求应该由哪个Controller处理，但不会自己处理，将Controller信息交给处理器适配器（HandlerAdapter）处理，返回ModelAndView对象</li><li>3.前端控制器得到ModelAndView对象将其转发给视图解析器，将对象解析成view页面返回</li><li>4.前端控制器将view页面相应给浏览器</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringMVC配置&quot;&gt;&lt;a href=&quot;#SpringMVC配置&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC配置&quot;&gt;&lt;/a&gt;SpringMVC配置&lt;/h2&gt;&lt;p&gt;&lt;em&gt;注解&amp;amp;配置文件&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;注
      
    
    </summary>
    
    
      <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>org.apache.tomcat.util.bcel.classfile.ClassFormatException</title>
    <link href="http://yoursite.com/2019/07/11/%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/07/11/异常/</id>
    <published>2019-07-11T03:41:21.000Z</published>
    <updated>2019-07-11T10:21:53.613Z</updated>
    
    <content type="html"><![CDATA[<h4 id="org-apache-tomcat-util-bcel-classfile-ClassFormatException"><a href="#org-apache-tomcat-util-bcel-classfile-ClassFormatException" class="headerlink" title="org.apache.tomcat.util.bcel.classfile.ClassFormatException"></a>org.apache.tomcat.util.bcel.classfile.ClassFormatException</h4><ul><li><img src="/images/pasted-4.png" alt="upload successful"></li><li>原因：jdk版本不兼容</li><li>原环境 jkd8+tomcat7+spring4  </li><li>解决：tomcat7换tomcat8</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;org-apache-tomcat-util-bcel-classfile-ClassFormatException&quot;&gt;&lt;a href=&quot;#org-apache-tomcat-util-bcel-classfile-ClassFormatException&quot; cl
      
    
    </summary>
    
    
      <category term="exception" scheme="http://yoursite.com/tags/exception/"/>
    
  </entry>
  
</feed>
