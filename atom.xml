<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YyWang&#39;s Blog</title>
  
  <subtitle>永远没时间的王先森</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-29T07:24:51.226Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YyWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Zookeeper扫盲</title>
    <link href="http://yoursite.com/2019/08/29/Zookeeper%E6%89%AB%E7%9B%B2/"/>
    <id>http://yoursite.com/2019/08/29/Zookeeper扫盲/</id>
    <published>2019-08-29T07:23:15.000Z</published>
    <updated>2019-08-29T07:24:51.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>是一个分布式协调服务框架，这句话对于刚接触ZK（Zookeeper下文简称ZK）的我来说太抽象了，很难理解，只知道它能提供一些服务能够实现配置管理、命名服务、分布式锁等等，也就是在这些场景下会使用到ZK，这样说好像还是很难理解；之后，我找到了一个比较好理解的点，就是从CAP理论的角度，这需要对CAP有些了解，提前做了功课(<a href="http://yywang.top/2019/08/26/CAP%E5%92%8CBASE/#more" target="_blank" rel="noopener">CAP和BASE</a>)，简单来说在分布式系统中出现网络故障时，最多满足其中的两项，而P是必须要满足的，那么就需要从CP和AP中做选择了；ZK就是可保证CP的框架，最后我的理解就是ZK通过特定的数据结构，封装一系列算法通过API的方式提供分布式环境数据一致性的服务，所有需要数据一致性的场景都可以使用ZK，也就是上面提到的配置管理、命名服务、分布式锁等等场景</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>ZK提供了一套类似于文件目录的数据结构，叫做多层级的节点命名空间，每个节点（ZK中称为znode）都可以存放数据且每个节点下都有若干个子节点，听起来和树的结构差不多，其实也一样，目录也是一种树结构的实现，znode可以理解为文件夹，文件夹中可以存放文件（znode可以存放数据），也可以存放文件夹（znode也可以存放znode）</p><h5 id="znode的类型"><a href="#znode的类型" class="headerlink" title="znode的类型"></a>znode的类型</h5><ul><li>PERSISTENT–持久化目录节点<ul><li>客户端和ZK断开连接后节点依然存在</li></ul></li><li>PERSISTENT_SEQUENTIAL–持久化顺序编号目录节点<ul><li>与持久化目录节点相同，只是多了ZK对节点的顺序编号</li></ul></li><li>EPHEMERAL–临时目录节点<ul><li>客户端和ZK断开连接后节点被删除</li></ul></li><li>EPHEMERAL_SEQUENTIAL–临时顺序编号目录节点<ul><li>与临时目录节点相同，只是多了ZK对节点的顺序编号 </li></ul></li></ul><h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p>ZK还提供了类似于观察这模式的通知机制，称为watcher事件，可以观察到znode的变化，来通知客户端，之后客户端再做相应的业务逻辑</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h4><p>这里命名服务指的是通过指定名字获取对应的资源，将资源存储在特定路径的znode中，根据路径就可以找到资源，类比目录结构来说，拿到文件的地址就能通过地址来找到文件，有点像是URL的意思，但是由于ZK数据结构设计的因素ZK不能存放较大的数据；微服务框架中的注册中心需要存放provider和consumer的信息，并且consumer要能够感知provider的实时状态，ZK可以根据provider和consumer的地址映射成临时znode结构，这样既保存了provider和consumer的信息还能感知彼此的状态</p><h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p>一句话解释—-动态下发配置文件变化；通过ZK客户端watch配置文件，一旦配置文件发生变化马上通知客户端做对应的处理</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>多个客户端再ZK的同一个目录下尝试创建临时znode，成功创建znode意味着获得锁成功，下个客户端发现目录下已经存在znode则对该znode添加watch机制，当znode消失即为释放锁后，通知客户端尝试创建znode来获取锁，这是公平锁；非公平锁的则创建临时有序的znode，相当于一个队列，后面的节点watch前一个节点的znode的状态，队头的znode为获得锁成功的几点</p><h3 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h3><h4 id="ZK节点的状态"><a href="#ZK节点的状态" class="headerlink" title="ZK节点的状态"></a>ZK节点的状态</h4><ul><li>LOOKING–当前节点不知道leader是谁，正在搜索</li><li>LEADING–当前节点为集群的leader</li><li>FOLLOWING–目前已有leader，当前节点负责与leader节点同步</li></ul><h4 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h4><p>在两种情况下会进行选举，1.服务器初始化启动 2.集群中leader节点故障</p><p>起初集群中的节点没有leader或者不知道leader是谁，此时节点的状态为LOOKING，如果当前集群存在leader（该节点新加入集群），此节点发送投票信息想要选举leader会被告知当前leader的信息，此节点只需和leader节点建立连接，并进行状态同步即可；</p><p>如果当前集群不存在leader节点，则需要投票进行选举</p><ul><li>此时所有节点皆为LOOKING状态，并编辑投票信息发送给集群的其他节点，投票信息的格式为（SID,ZXID）（服务器的唯一标识，事务ID），SID是自己配置的，ZXID理解为当前节点数据的版本；</li><li>集群中的节点会受到其他节点的投票信息，加上自己的那一票会根据一个规则会投出第二轮的选票<ul><li>节点会在自己收到的选票中，选择ZXID最大的作为第二轮的选票发送给集群中其他节点</li><li>如果ZXID相同则选择SID最大的作为第二轮的选票发送给集群中其他节点</li></ul></li><li>集群中的节点在接收到第二轮选票后进行统计（包含自己的一票），获得集群中一半以上（&gt;n/2）数量投票的节点当选leader进入LEADING状态，其余节点进入FOLLOWING状态</li></ul><p>总结一下，集群中要获得一半以上的投票才能当选leader，所以集群最少为3台，并且数量是奇数；集群中ZXID越大的节点（当前节点数据版本越新）优先当选leader</p><h3 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h3><p>整个过程没有难度也很好理解，跟着<a href="https://www.jianshu.com/p/5491d16e6abd" target="_blank" rel="noopener">这篇文章</a>做就完事了</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本文是对于Zookeeper的扫盲，大致了解ZK的基本原理，为了更好的理解工作中的项目，具有目的性，一些细节没有去研究，下回再补，😋</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://jm.taobao.org/2011/10/08/1232/" target="_blank" rel="noopener">ZooKeeper典型应用场景一览</a></p><p><a href="https://www.jianshu.com/p/5491d16e6abd" target="_blank" rel="noopener">笔记：Mac上zookeeper的安装与启动</a></p><p><a href="https://segmentfault.com/a/1190000014479433?utm_source=tag-newest" target="_blank" rel="noopener">zookeeper面试题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Zookeeper&quot;&gt;&lt;a href=&quot;#Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper&quot;&gt;&lt;/a&gt;Zookeeper&lt;/h3&gt;&lt;p&gt;是一个分布式协调服务框架，这句话对于刚接触ZK（Zookeeper下文简称ZK）的我
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CAP和BASE</title>
    <link href="http://yoursite.com/2019/08/26/CAP%E5%92%8CBASE/"/>
    <id>http://yoursite.com/2019/08/26/CAP和BASE/</id>
    <published>2019-08-26T08:52:51.000Z</published>
    <updated>2019-08-29T07:24:22.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>Consistency（一致性） Availability（可用性） Partition tolerance（分区容错性）</p><p>CAP理论的内容是在分布式系统中出现网络故障时最多只能满足CAP中的两项</p><ul><li>Consistency 一致性<ul><li>“all node see the same data at the same time” 就是指分布式系统的数据一致性，可用看出这里的一致性指的是强一致性，要求分布式系统数据发生改变后所有节点在后续的请求中都能感知到</li><li>强一致性，当数据发生改变，系统中的其他节点在下次请求都会感知到</li><li>弱一致性，保证某个时间级别（比如xx秒），数据能够达到数据一致的状态</li><li>最终一致性，弱一致性的一个特例，保证在一段时间内达到数据一致的状态</li></ul></li><li>Availability 可用性<ul><li>“Reads and Writes always succeed”，这里的succeed指的是请求和响应的过程成功，也每次请求都会在有限的时间内收到回复，换句话说就是服务器可用；并不是请求的返回值是成功的意思，返回值是失败也是有返回值的，同样说明请求响应的过程是成功的。</li><li>系统可用性5个9，意为分布式系统的可用水平为99.999%，全年停机时间不超过 <strong>(1-0.99999)<em>365</em>24*60 = 5.256 min</strong></li></ul></li><li>Partition tolerance 分区容错性<ul><li>“the system continues to operate despite arbitrary message loss or failure of part of the system” 分区指的是由于网络异常集群中只有部分节点能够正常通信，可能存在多个能够通信的子网络，这些子网络就是分区；又或者说集群中部分服务器宕机，其他服务器依然可用，这部分可用的服务器组成的子网络也可以称为分区。分区容错性是指当出现网络延迟或者故障的情况时系统依然能够提供服务</li></ul></li></ul><p>怎么理解呢？简单来说就是在分布式系统中发生故障时，CAP最多只能满足其中的两项，也就是CAP三选二呗，但是我们发现P（分区容错性）说白了就是指网络出问题后系统依然可用，这可是分布式系统的基础条件，应该必须满足；在满足分区容错性时有可能会存在两种问题</p><ul><li>1.用户访问部分服务器间的网络异常，这时只需将请求转发到可用的服务器即可，这时在理想情况下（服务器间的网络通畅）是可以满足CAP的，除非和所有服务器的网络都有问题（<strong>这只是理想情况</strong>）</li><li>2.除了用户访问服务器的网络异常之外，分布式系统中不同服务器直接的网络也可能存在异常，例如分布式系统中有A、B两台服务器，假设A、B之间存在网络故障，当服务器A改变数据之后无法同步到服务器B，此时就不能保证强一致性和可用性同时满足<ul><li>放弃强一致性（C），用户请求A可以得到最新的数据，用户请求B得到的是旧数据；可以保证用户每次请求都会返回结果，但不能保证数据的一致性</li><li>放弃可用性（A），为了保证数据的强一致性，数据每次修改后都需要等待所有的数据源都同步后才能进行读写，用户请求服务器A或者B，由于数据始终不能同步，最后会一直阻塞下去，不能保证用户的每次都能短时间内得到返回值甚至得不到返回值</li></ul></li></ul><p>综上，我认为的CAP理论是在分布式系统中服务器之间网络出现问题时，CAP最多只能满足其二，并不是分布式系统就只能满足CAP中的两项，理想情况下是都可满足的（虽然现在不大可能）；况且在分布式系统中P是必须满足的，也就是说CA只能满足其一，具体的取舍需要根据不同的业务场景权衡</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><ul><li>Basically Available（基本可用）<ul><li>系统设计中可以牺牲部分可用性，比如允许响应时间增加1-2秒，服务降级等</li></ul></li><li>Soft state（软状态）<ul><li>允许系统中的数据存在中间状态，允许数据同步过程存在延迟</li></ul></li><li>Eventually consistent（最终一致性）<ul><li>所有数据再一段时间的数据同步后都能达到一致的状态 </li></ul></li></ul><p>综上，不同的业务以BASE理论为基础对可用性和一致性进行一个权衡；zk和数据库的主从都是舍弃高可用性；涉及到用户体验的场景则需要舍弃数据强一致性如12306买火车票，618和双11等对于用户的每个请求都需要给与响应，允许存在短时间数据不一致的状态</p><p><a href="http://www.hollischuang.com/archives/666" target="_blank" rel="noopener">参考资料</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CAP理论&quot;&gt;&lt;a href=&quot;#CAP理论&quot; class=&quot;headerlink&quot; title=&quot;CAP理论&quot;&gt;&lt;/a&gt;CAP理论&lt;/h3&gt;&lt;p&gt;Consistency（一致性） Availability（可用性） Partition tolerance（分区容
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>缓存更新的套路 总结与感受</title>
    <link href="http://yoursite.com/2019/08/21/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%A5%97%E8%B7%AF-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%84%9F%E5%8F%97/"/>
    <id>http://yoursite.com/2019/08/21/缓存更新的套路-总结与感受/</id>
    <published>2019-08-21T06:51:35.000Z</published>
    <updated>2019-08-21T06:57:48.631Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注：</strong> 本文是阅读 [缓存更新的套路] (<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17416.html</a>) 一文的总结，本文是以经常用到的Redis+MySQL的角度解读</p><h3 id="经典方法-–-Cache-Aside-Pattern"><a href="#经典方法-–-Cache-Aside-Pattern" class="headerlink" title="经典方法 – Cache Aside Pattern"></a>经典方法 – Cache Aside Pattern</h3><ul><li>读操作：先从Redis中获取，没有命中则从MySQL中获取，最后更新到Redis中</li><li>写操作：先写MySQL，成功后删除Redis中的数据</li></ul><p>为什么这样的方案会是经典方法呢？因为简单，有效，错误少</p><ul><li>场景1–写操作如果先删除Redis中的数据再操作数据库<ul><li>如果一个写操作和读操作并发执行，写操作删除了Redis中的数据还没来得及将数据更新到MySQL中，读操作没有在Redis中读取到数据，而从MySQL中读到旧的数据并更新到了Redis中，这样虽然MySQL中的数据是正确的，因为Redis的存在使得每次读取的数据都是脏数据。（这种情况只会发生在删除Redis数据后，写MySQL前这段时间，因为写MySQL时可以通过加悲观锁来避免问题）</li></ul></li><li>场景2–写操作后增加更新Redis数据<ul><li>这样读和写的操作都会更新Redis数据看似更稳健了，其实不然，更新操作变多了脏数据也会变多，比如有两个写操作a和b，按照请求的时间来说最终的状态应该是b，极端情况下ab都完成了更新数据库的操作，在更新Redis的时候，b先完成了，随后a完成又将Redis数据改成了a的状态，这样还是会存在脏数据 ，虽然出现的概率不大相对于经典方法多了产生脏数据的可能性，所以不可取</li></ul></li><li>场景3–脏数据<ul><li>经典方法可以避免场景1和2的问题，但也不是万无一失的，当一个读操作在Redis中没有命中时，从MySQL中获取了数据，在更新Redis数据之前，有一个写操作完成，此时MySQL的数据已经变了，而读操作会把之前的数据写入Redis中，产生脏数据。而这样的场景发生的几率非常非常小，由于MySQL锁的限制，只能发生在读操作读取数据之后读操作更新Redis数据之前，并且这段时间有一个写操作完成，同样因为锁的存在写操作一般都比读操作会耗时，并且给Redis数据增加过期时间进一步减小脏数据的产生几率</li></ul></li></ul><p>综上所述，虽然经典方法在场景3略有瑕疵，但依然经典可用，因为其简单，有效，错误少</p><h3 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h3><ul><li>读操作：Redis命中直接返回；没有命中从MySQL中读取后更新到Redis中</li><li>写操作：Redis中命中更新Redis；没有命中更新MySQL</li></ul><p>这种模式写操作只针对于一个数据库（MySQL或者Redis），读数据时在Redis中没有命中会从MySQL中读取到Redis中，长时间运行后大部分数据都会在Redis中命中，写操作也会针对于Redis，相当于是强依赖于Redis，弱依赖甚至不依赖于MySQL，这么看来这种方式是最高效的，但是有一个致命的缺点，数据可能会丢失，由于强依赖于Redis中的数据，同样强依赖于Redis的高可用性，当Redis的数据丢失没有很好的灾备的话，数据就没了，这时如果想通过MySQL恢复几乎是不可能的了。总结一下，这种模式有利有弊，具体使用场景需要针对于具体的业务场景，我认为如果有比较好的Redis高可用和灾备的策略，这种模式还是非常好用的。</p><h3 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h3><ul><li>读操作：Redis命中直接返回；没有命中则从MySQL中获取数据返回</li><li>写操作：无论Redis命中与否都先更新Redis，接着异步更新MySQL中的数据</li></ul><p>原文中也提到，这么做会极大的提高I/O，相当于只操作了Redis，是内存级别的读写，同时这么做也有缺点，就是在同步数据到MySQL时如果服务器宕机断电等事故将会永久性的数据丢失</p><h3 id="精彩评论"><a href="#精彩评论" class="headerlink" title="精彩评论"></a>精彩评论</h3><p>摘取了一些大佬们的评论，很有启发</p><ul><li>一位名叫 ty 的大佬说：”Cache Aside Pattern模式，两个更新操作同时进来，也可能会有cache脏数据的问题啊<br>顺序如下：<br>第一个写数据库，第二个写数据库，第二个写cache，第一个写cache<br>这样cache里是第一个数据，而数据库里是第二个“</li><li>——–这和我想的是一样的，哈哈</li></ul><hr><ul><li>一位名叫 letsgowei 的大佬说：”在做更新操作时不可以更改数据库后直接更新缓存吗？这样最多也就一两次脏数据“</li><li>——–这位大佬的疑惑应该是为什么更新操作只是删除缓存或者把缓存设置为无效，而不是更新缓存呢？还有一位评论有同样的疑惑；这个问题我没有考虑到，觉得他们说的有道理直接更新也可以啊？</li><li>一位名叫 longsen 的大佬做出了解答：”1. 读线程查key未在cache中；2.读线程从db读数据；3.写线程更改数据库；4.写线程看key未在cache中，无法更新cache；5.读线程将旧数据写入cache中。这种场景旧数据可能在cache存在很长时间“</li><li>——–大佬给出的解释是cache中没有key无法更新，I don’t think so！至少在Redis的环境下是不存在的，key不存在直接set，key存在直接覆盖，Redis是有这样的命令的，所以这个回答我不同意，如果将写MySQL后将Redis中的key删除的操作，改成更新Redis的Key操作，这样一来就和我上面提到的场景2是一样的的了，读写都更新Redis增加了产生脏数据的概率，所以是不可取的</li></ul><hr><ul><li>一位名叫 泪滴 的大佬说：”大神！你的这个更新顺序是建立在更新数据库，更新缓存都不会发生失败的情况下的，单独考虑并发问题得到的顺序！<br>方案1：先更新数据库，再删除缓存，当出现并发问题概率很小(假设概率为R1)，会造成脏数据。当出现网络等问题导致删除缓存失败(假设概率为R2)，会导致之后的请求一直是脏数据。<br>方案2：先删除缓存，再更新数据库，当出现并发问题概率较大(假设概率为R3)，会导致之后的请求一直是脏数据，当出现网络问题，删除缓存成功，更新数据库失败，只会引发一次cache miss，在业务上基本没啥影响。当然为了弥补，我们一般都会设置缓存的过期时间，来缩短出现脏数据的时间。现在问题的关键就是R1+R2和R3的大小问题了，如果大厂，网络基础设施啥的比较牛，当然R1+R2&lt;R3选择方案1比较合适，对于广大小厂来说还真的可能R1+R2&gt;R3那怎么选择，就比较清楚了。“</li><li>——–说实话，他的评论让我眼前一亮，他的分析具体到了应用场景上，而且确实有这样的情况出现，所以说没有最完美的设计只有最合适的设计，给这位大佬点赞</li></ul><hr><ul><li>还有一些则是针对于原文中Write Behind Caching Pattern部分的流程图的疑问，例如缓存未命中为什么回写数据再更新数据，直接更新数据不就好了吗？写数据未命中为什么还有判断dirty的标志？等等，这些问题我也不懂，云里雾里的，不知道为什么这么设计，不就是异步更新MySQL吗，搞这么复杂是为什么，后来我冷静的分析一下，这篇文章是缓存更新的套路，当前部分是缓存异步更新MySQL的介绍，而流程图和异步半毛钱关系都没有，为什么？</li><li>——–因为我太垃圾了，文章中 xxPattern 指的是Linux内核中的缓存更新模式，作者是将这些模式应用到分布式环境下缓存更新中，所以说这部分的流程图是指Linux内核的缓存更新而不是分布式环境下的缓存更新，作者在文章中不止一次提到了基础很重要就体现出来了，而且作者也提到宏观的系统架构设计其实和计算机系统结构中微观的设计是相似的，所以想要设计好一个大型的分布式系统必须对计算机系统结构非常了解</li></ul><hr><p>综上所述–基础很重要</p><p>以上是我拜读耗子哥的<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">《缓存更新的套路》</a>一文后的一些总结和思考，推荐大家读原文哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 本文是阅读 [缓存更新的套路] (&lt;a href=&quot;https://coolshell.cn/articles/17416.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coolshell.
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>一次Spring事务不回滚的踩坑记录</title>
    <link href="http://yoursite.com/2019/08/16/%E4%B8%80%E6%AC%A1Spring%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%9B%9E%E6%BB%9A%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/08/16/一次Spring事务不回滚的踩坑记录/</id>
    <published>2019-08-16T13:01:13.000Z</published>
    <updated>2019-08-16T13:02:23.912Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一次Spring事务不回滚的踩坑记录"><a href="#一次Spring事务不回滚的踩坑记录" class="headerlink" title="一次Spring事务不回滚的踩坑记录"></a>一次Spring事务不回滚的踩坑记录</h3><p>Spring事务不回滚八成是不知道Spring默认在捕获到unchecked异常才会自动回滚，然而我早已踩过个坑，是一个有经验的人，当我自信满满的加上一行 1/0，并在catch中 throw new RuntimeException，debug之后我懵了，咋不回滚呢？重启Tomcat，浏览器缓存清理之后再试一次，还是不行！！！我就难受了，这和我预想的不一样，检查代码没有发现错误，那咋办呢？开始百度吧，百度的结果千篇一律，都是针对不了解Spring默认捕获unchecked异常的解决办法，这些早已在我的经验里了，有3种方法</p><ul><li>1.手动抛出unchecked异常，让Spring去捕获，然后自动回滚数据</li><li>2.手动回滚，在发生异常的地方添加代码 <strong>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</strong></li><li>3.在注解的地方添加配置<strong>rollbackFor = { Exception.class }</strong>，让Spring在捕获到特定的异常自动回滚数据 </li></ul><p>3种方法我都知道，但是我一般只用第一种，因为简单，这次我选择用第二种方法试下，竟然没问题了，我意识到是我的问题了，开始检查代码，我的代码逻辑如下（见笑）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean result = false;</span><br><span class="line">try &#123;</span><br><span class="line">    // ...业务逻辑</span><br><span class="line">    System.out.println(1/0);</span><br><span class="line">    // ...业务逻辑</span><br><span class="line">    result = true;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">    // rollback</span><br><span class="line">    throw new RuntimeException(e);</span><br><span class="line">    result = false;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是不知道错在哪里，没有办法开始Debug，惊奇的发现RuntimeException竟然被忽略了，这才发现我finally中有return，被我自己蠢哭了，基础真是太重要了，我还盲目自信的知道Spring的事务如何使用，到头来连try catch finally都没搞清楚，真是太蠢了。接着我修改了代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boolean result = false;</span><br><span class="line">try &#123;</span><br><span class="line">    // ...业务逻辑</span><br><span class="line">    System.out.println(1/0);</span><br><span class="line">    // ...业务逻辑</span><br><span class="line">    result = true;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">    // rollback</span><br><span class="line">    throw new RuntimeException(e);</span><br><span class="line">&#125; </span><br><span class="line">return result;</span><br></pre></td></tr></table></figure><p>这下确实是回滚了，但是返回值是true，想得到的时false，这又难受了，再次Debug，很多次F6后我明白了，RuntimeException是被Spring框架里的层层代理catch了————————————————————————————————————————————————————————————–<br>我把我自己给骗了，RuntimeException抛出程序已经终止了，即使再多的catch最后也不会回到result = true那一行，最终得出原因是其他ajax请求的结果返回到了前台给的提示让我误解了</p><hr><p>到这里我意识到自己是真的菜，补习一下try catch finally吧<br>找到<a href="https://blog.csdn.net/mxd446814583/article/details/80355572" target="_blank" rel="noopener">一篇好文</a></p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><ul><li>如果finally中有return，try和catch中的return会失效，并且<strong>catch中即使抛出unchecked异常也同样会失效</strong>（这是今天踩的坑）；如果finally中有异常相当于整个方法有了异常，那么就没有最终的返回值了,catch中有了异常同样的效果，所以catch和finally中不要出现异常</li><li>如果finally中没有return，try和catch中走最先到达return逻辑的地方，并且在return前将返回值暂存，即使finally中修改也不会有效果；（也就是说没有异常最先到达try块中的return，返回值是try块的返回值，catch和finally修改也不会生效；如果try块有异常最先到达catch块中的return，返回值是catch块的返回值，前提是catch块中没有异常，有异常整个方法都没有返回值）</li><li>综上所述，<strong>使用Spring事务避免不出错优先使用方法2和方法3，方法1比较绕并且对有返回值的逻辑不是很友好；finally块中尽量不要return，这样会忽略try和catch中的异常；最后，基础真的很重要</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一次Spring事务不回滚的踩坑记录&quot;&gt;&lt;a href=&quot;#一次Spring事务不回滚的踩坑记录&quot; class=&quot;headerlink&quot; title=&quot;一次Spring事务不回滚的踩坑记录&quot;&gt;&lt;/a&gt;一次Spring事务不回滚的踩坑记录&lt;/h3&gt;&lt;p&gt;Spring
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Optional 使用及源码</title>
    <link href="http://yoursite.com/2019/08/15/Optional/"/>
    <id>http://yoursite.com/2019/08/15/Optional/</id>
    <published>2019-08-15T12:58:37.000Z</published>
    <updated>2019-08-15T13:12:43.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Optional-使用及源码分析"><a href="#Optional-使用及源码分析" class="headerlink" title="Optional 使用及源码分析"></a>Optional 使用及源码分析</h3><p>A container object which may or may not contain a non-null value.</p><p>可能包含空值的容器对象。</p><p>怎么理解呢？就把它当成是和Collection一样的容器，Collection是通过不同的数据结构和API来操作容器中的元素；Optional则是提供API来判断容器中的元素是否为空，在此基础上还能根据是否为空的不同结果给出自定义的处理逻辑。这么说还是很抽象，直接上源码就会好理解一些。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 空的Optional对象</span><br><span class="line">private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();</span><br><span class="line">// 容器中元素的值</span><br><span class="line">private final T value;</span><br></pre></td></tr></table></figure><p>这个value是容器中元素的值，怎么理解呢，使用Optional是要通过它的API进行判空来达到避免NPE的现象，上面说到将Optional当成是一个容器，这个容器中的元素则是需要判空的对象，也就是说容器中的元素就是你传入的参数，这个value就是传参的值</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>无参构造，只是将value置为null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Optional() &#123;</span><br><span class="line">        this.value = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有参构造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Optional(T value) &#123;</span><br><span class="line">    this.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中返回Objects中的requireNonNull的方法，再看这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T requireNonNull(T obj) &#123;</span><br><span class="line">    if (obj == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单如果obj为空抛出异常，不为空返回本身，所以有参构造的效果就是确认value不为空并给value赋值，如果是空就抛异常</p><p>而且这两个构造函数是私有的，也就是说我们不能new出来</p><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><ul><li>empty()–返回空的Optional对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Optional&lt;T&gt; empty() &#123;</span><br><span class="line">    Optional var0 = EMPTY;</span><br><span class="line">    return var0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>of(T var1)–调用了有参构造，即有值返回带有该值得Optional对象，为空则会抛异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Optional&lt;T&gt; of(T var0) &#123;</span><br><span class="line">    return new Optional(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ofNullable(T var0)–元素为null返回空的Option对象，不是null返回本身</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T var0) &#123;</span><br><span class="line">    return var0 == null ? empty() : of(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>get()–从名字就可以看出是获取元素的值，也就是返回value，如果是null的话会抛异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    if (this.value == null) &#123;</span><br><span class="line">        throw new NoSuchElementException(&quot;No value present&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>isPresent()–返回value是否为null</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPresent() &#123;</span><br><span class="line">    return this.value != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ifPresent(Consumer&lt;? super T&gt; var)–如果元素不是空的话执行var1中的逻辑，Consumer之前有文章写过，是接收一个参数执行一个没有返回值得逻辑</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void ifPresent(Consumer&lt;? super T&gt; var1) &#123;</span><br><span class="line">if (this.value != null) &#123;</span><br><span class="line">    var1.accept(this.value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>filter(Predicate&lt;? super T&gt; var1)–首先确保predicate对象和value不是null，然后用predicate对象对value进行筛选，满足条件返回本身，不满足条件返回空的对象（看源码是这个意思，具体怎什么情况用还想不到~）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; var1) &#123;</span><br><span class="line">    Objects.requireNonNull(var1);</span><br><span class="line">    if (!this.isPresent()) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return var1.test(this.value) ? this : empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map(Function&lt;? super T, ? extends U&gt; var1)–同样确保var1不是null，之后value为空值返回空的Optional对象，value有值执行var1中的逻辑</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public &lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; var1) &#123;</span><br><span class="line">    Objects.requireNonNull(var1);</span><br><span class="line">    return !this.isPresent() ? empty() : ofNullable(var1.apply(this.value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flatMap(Function&lt;? super T, Optional&lt; U &gt;&gt; var1)–与map方法相同,不同的是入参，根据不同的参数结构使用不同的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public &lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; var1) &#123;</span><br><span class="line">    Objects.requireNonNull(var1);</span><br><span class="line">    return !this.isPresent() ? empty() : (Optional)Objects.requireNonNull(var1.apply(this.value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>T orElse(T var1)–获取value的值，不为空返回本身，为空返回入参var1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public T orElse(T var1) &#123;</span><br><span class="line">    return this.value != null ? this.value : var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>T orElseGet(Supplier&lt;? extends T&gt; var1)–与orElse的逻辑一样，不同的是value为空返回的是supplier对象的逻辑</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public T orElseGet(Supplier&lt;? extends T&gt; var1) &#123;</span><br><span class="line">    return this.value != null ? this.value : var1.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>T orElseThrow(Supplier&lt;? extends X&gt; var1)–同样的逻辑，不同的是value为null会抛异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; var1) throws X &#123;</span><br><span class="line">    if (this.value != null) &#123;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw (Throwable)var1.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>of和ofNullable<ul><li>都是取值，如果元素是null的话of会报空指针–不用，ofNullable将null转为空的对象没有空指针；</li><li>get方法同样是取值，value是null也会抛异常–不用</li><li>最后，取值用ofNullable就完事了</li></ul></li><li>isPresent和ifPresent<ul><li>isPresent返回元素是否为null，有返回值</li><li>ifPresent元素不为空执行一段逻辑，无返回值</li><li>最后，只判断用isPresent有逻辑用ifPresent</li></ul></li><li>filter、map和flatMap<ul><li>都是将不是null的元素执行传入的逻辑，根据不同的需求选择方法</li></ul></li><li>orElse、orElseGet和orElseThrow<ul><li>都是将null的元素做转换，orElse返回传入的值，orElseGet返回传入的逻辑，这两个方法看需求没有逻辑有orElse有逻辑用orElseGet；orElseThrow元素为null抛异常–不用</li></ul></li></ul><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>刚刚学习还不知道怎么使用，看到[一篇文章]（<a href="https://www.cnblogs.com/rjzheng/p/9163246.html）" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9163246.html）</a> 给的栗子不错，很有借鉴意义，但是我对这篇文章中的orElse和orElseGet的栗子有不同意见。</p><h5 id="栗子1"><a href="#栗子1" class="headerlink" title="栗子1"></a>栗子1</h5><ul><li>使用前</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public String getCity(User user)  throws Exception&#123;</span><br><span class="line">    if(user!=null)&#123;</span><br><span class="line">        if(user.getAddress()!=null)&#123;</span><br><span class="line">            Address address = user.getAddress();</span><br><span class="line">            if(address.getCity()!=null)&#123;</span><br><span class="line">                return address.getCity();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new Excpetion(&quot;取值错误&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用后</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String getCity(User user) throws Exception&#123;</span><br><span class="line">    return Optional.ofNullable(user)</span><br><span class="line">                   .map(u-&gt; u.getAddress())</span><br><span class="line">                   .map(a-&gt;a.getCity())</span><br><span class="line">                   .orElseThrow(()-&gt;new Exception(&quot;取指错误&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="栗子2"><a href="#栗子2" class="headerlink" title="栗子2"></a>栗子2</h5><ul><li>使用前</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(user!=null)&#123;</span><br><span class="line">    dosomething(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用后</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(user)</span><br><span class="line">        .ifPresent(u-&gt;&#123;</span><br><span class="line">           dosomething(u);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h5 id="栗子3"><a href="#栗子3" class="headerlink" title="栗子3"></a>栗子3</h5><ul><li>使用前</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public User getUser(User user) throws Exception&#123;</span><br><span class="line">if(user!=null)&#123;</span><br><span class="line">    String name = user.getName();</span><br><span class="line">    if(&quot;zhangsan&quot;.equals(name))&#123;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    user = new User();</span><br><span class="line">    user.setName(&quot;zhangsan&quot;);</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用后</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public User getUser(User user) &#123;</span><br><span class="line">    return Optional.ofNullable(user)</span><br><span class="line">                   .filter(u-&gt;&quot;zhangsan&quot;.equals(u.getName()))</span><br><span class="line">                   .orElseGet(()-&gt; &#123;</span><br><span class="line">                        User user1 = new User();</span><br><span class="line">                        user1.setName(&quot;zhangsan&quot;);</span><br><span class="line">                        return user1;</span><br><span class="line">                   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Optional-使用及源码分析&quot;&gt;&lt;a href=&quot;#Optional-使用及源码分析&quot; class=&quot;headerlink&quot; title=&quot;Optional 使用及源码分析&quot;&gt;&lt;/a&gt;Optional 使用及源码分析&lt;/h3&gt;&lt;p&gt;A container ob
      
    
    </summary>
    
      <category term="Java8" scheme="http://yoursite.com/categories/Java8/"/>
    
    
      <category term="Java8" scheme="http://yoursite.com/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>mac 设置</title>
    <link href="http://yoursite.com/2019/08/13/mac-%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/08/13/mac-设置/</id>
    <published>2019-08-13T08:44:33.000Z</published>
    <updated>2019-08-13T09:14:55.008Z</updated>
    
    <content type="html"><![CDATA[<h6 id="外接键盘的调整"><a href="#外接键盘的调整" class="headerlink" title="外接键盘的调整"></a>外接键盘的调整</h6><p>键盘设置中将control和command互换就可以达到和Windows下的复制粘贴时一样的，切换程序则由alt+tab变成了ctrl+tab需要适应一下，不过复制，粘贴，撤销，保存这些不用再去适应新的快捷键了<br><img src="/images/pasted-14.png" alt="upload successful"></p><h6 id="idea中的调整"><a href="#idea中的调整" class="headerlink" title="idea中的调整"></a>idea中的调整</h6><p>preferences中找到keymap选择Eclipse(macOS)，这样加上第一步的配置复制粘贴这些快捷键与Windows相同，不用再去适应新的快捷键</p><h6 id="自动补全变量"><a href="#自动补全变量" class="headerlink" title="自动补全变量"></a>自动补全变量</h6><p>keymap中搜索variable   默认为：option+command+L 通过以上设置后为：Ctrl+alt+L</p><h5 id="另一种使用方法"><a href="#另一种使用方法" class="headerlink" title="另一种使用方法"></a>另一种使用方法</h5><p>不做任何配置，idea中使用eclipse风格的快捷键，idea中的使用不影响，但是在idea以外就得适应mac中的快捷键，感觉还是这个方法更容易接受一些</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;外接键盘的调整&quot;&gt;&lt;a href=&quot;#外接键盘的调整&quot; class=&quot;headerlink&quot; title=&quot;外接键盘的调整&quot;&gt;&lt;/a&gt;外接键盘的调整&lt;/h6&gt;&lt;p&gt;键盘设置中将control和command互换就可以达到和Windows下的复制粘贴时一样的，切换程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="http://yoursite.com/2019/08/05/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/05/Lambda表达式/</id>
    <published>2019-08-05T01:06:59.000Z</published>
    <updated>2019-08-05T01:10:06.276Z</updated>
    
    <content type="html"><![CDATA[<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>包含3个部分：参数 -&gt; 表达式/代码块</p><ul><li>(params) -&gt; expression</li><li>(params) -&gt; statement</li><li>(params) -&gt; { statements }</li></ul><p><strong>与内部类相同，lambda表达式不可以修改外部变量，这点与匿名内部类相同，不同的是lambda表达式不用将变量显示的声名为final，如果是在自己的作用域中定义局部变量可以进行修改，最终保证线程安全</strong></p><p><strong>（踩坑）lambda表达式中的this并不是代表当前使用lambda表达式的对象，而是外部类的对象</strong></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><h5 id="可代替匿名内部类"><a href="#可代替匿名内部类" class="headerlink" title="可代替匿名内部类"></a>可代替匿名内部类</h5><ul><li>可以代替只包含一个抽象方法的接口，也叫做函数式接口，例如；Comparator、Runnable</li><li>Java8内置了四大函数式接口分别为：Consumer，Supplier，Function，Predicate</li><li>jdk8中提供@FunctionalInterface 注解来检查接口是否符号函数式接口的标准</li></ul><h5 id="可代替迭代操作"><a href="#可代替迭代操作" class="headerlink" title="可代替迭代操作"></a>可代替迭代操作</h5><ul><li>list.forEach(n -&gt; {});</li></ul><h5 id="通过Stream操作集合"><a href="#通过Stream操作集合" class="headerlink" title="通过Stream操作集合"></a>通过Stream操作集合</h5><ul><li>list.stream().filter()…collect();</li></ul><h5 id="对数据处理"><a href="#对数据处理" class="headerlink" title="对数据处理"></a>对数据处理</h5><ul><li>与Spark相似java8可以将集合转化为流（Stream），在对流进行map和reduce操作，与Spark相同这些方法也是惰性求值的</li></ul><h4 id="Java8的函数式接口"><a href="#Java8的函数式接口" class="headerlink" title="Java8的函数式接口"></a>Java8的函数式接口</h4><h5 id="消费型接口-Consumer"><a href="#消费型接口-Consumer" class="headerlink" title="消费型接口 Consumer"></a>消费型接口 Consumer<t></t></h5><ul><li>抽象方法-void accept(T t);</li><li>参数类型-T</li><li>返回类型-void</li></ul><p>这个还没有用过，因为返回值为空并且传递一个参数，我感觉和集合的遍历差不多 list.forEach(n -&gt; sout(n)); 通过定义多个Consumer对象相当于定义多个逻辑块，最终consumer1.addThen(consumer2) 连接，也就是说consumer1逻辑完成后执行consumer2（为什么不写在一个逻辑里呢？我猜可能需要解耦吧）</p><h5 id="供给型接口-Supplier"><a href="#供给型接口-Supplier" class="headerlink" title="供给型接口 Supplier"></a>供给型接口 Supplier<t></t></h5><ul><li>抽象方法-T get();</li><li>参数类型-无参数</li><li>返回类型-T</li><li>这个感觉很简单，没有参数但要返回一个值，可能new一个对象的时候会用到吧，声名Supplier对象后直接调用get执行定义的逻辑（箭头后面的逻辑）返回一个值</li></ul><h5 id="函数型接口-Function-lt-T-R-gt"><a href="#函数型接口-Function-lt-T-R-gt" class="headerlink" title="函数型接口 Function&lt;T,R&gt;"></a>函数型接口 Function&lt;T,R&gt;</h5><ul><li>抽象方法-R apply(T t)</li><li>参数类型-T</li><li>返回类型-R</li></ul><p>同样是创建Function对象定义一个方法逻辑，接口中有Consumer接口同样的实现方法andThen，用法也相同，不同的是Function定义中有返回值，fun1.addThen(fun2)是将fun1执行的返回值传入fun2中再执行fun2中的逻辑，除此之外该接口还有一个实现方法compose，用法和andThen相反，fun1.compose(fun2) 是先执行fun2中的逻辑将返回值作为参数传入fun1中再执行fun1中的逻辑</p><h5 id="断言型接口-Predicate"><a href="#断言型接口-Predicate" class="headerlink" title="断言型接口 Predicate"></a>断言型接口 Predicate<t></t></h5><ul><li>抽象方法-boolean test(T t)</li><li>参数类型-T</li><li>返回类型-boolean</li><li>定义的Predicate对象相当于筛选条件的对象，最终通过stream中的filter进行过滤，多个条件可以用and和or来进行组合相当于运算符 &amp;&amp; 和 ||</li><li>多用做集合筛选 eg:</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 筛选大于18岁的女性用户</span><br><span class="line">Predicate&lt;User&gt; matchAge = u -&gt; u.age &gt; 18;</span><br><span class="line">Predicate&lt;User&gt; matchSex = u -&gt; u.sex.equals(&quot;f&quot;);</span><br><span class="line">resultList = userList.stream().filter(matchAge.and(matchSex)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li></ul><p>我的理解是在定义Predicate的对象时，-&gt; 前传入参数， -&gt; 后定义test的方法体，最终补充抽象方法test，通过stream的filter筛选相当于将集合中的每个元素都调用一次test方法，将返回值为true的筛选出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h4&gt;&lt;p&gt;包含3个部分：参数 -&amp;gt; 表达式/代码块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(params) -&amp;gt; expression&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Java8" scheme="http://yoursite.com/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>StringUtils</title>
    <link href="http://yoursite.com/2019/07/26/StringUtils/"/>
    <id>http://yoursite.com/2019/07/26/StringUtils/</id>
    <published>2019-07-26T11:32:04.000Z</published>
    <updated>2019-07-26T11:35:18.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="StringUtils"><a href="#StringUtils" class="headerlink" title="StringUtils"></a>StringUtils</h2><ul><li>工作中很多操作字符串的操作，使用到了工具类这里总结下，org.apache.commons.lang3包下的</li></ul><h3 id="split-String-str-String-separatorChars-–-gt-切分字符串"><a href="#split-String-str-String-separatorChars-–-gt-切分字符串" class="headerlink" title="split(String str, String separatorChars)–&gt;切分字符串"></a>split(String str, String separatorChars)–&gt;切分字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String[] split(String str, String separatorChars) &#123;</span><br><span class="line">    return splitWorker(str, separatorChars, -1, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>int max -&gt;the maximum number of elements to include in the array. A zero or negative value implies no limit.<br>这个参数代表返回的字符串的最大长度，0或者-1代表不限制长度</li><li>boolean preserveAllTokens -&gt; if {@code true}, adjacent separators are treated as empty token separators; if {@code false}, adjacent separators are treated as one separator. 这个参数是连续分隔符规则的标志，如果为true连续的分隔符都会匹配，最终得到的字符串数组会有空的值，jdk中的split就是这个规则；如果为false，连续的分隔符只会匹配一次，最终得到的数组不会有空值。eg(“1,2,3,,4,5”切分后，true得到[1,2,3,,4,5]而false得到[1,2,3,4,5])，</li><li>这也是与jdk中的split方法的区别，如果需要使用与jdk相同的规则，工具类中的splitPreserveAllTokens方法可以实现，该方法会调用splitWorker方法且最后的参数为true</li></ul><p>所以split方法默认参数为-1和false表示数组长度不收限制，及使用第二个规则进行切割，确保得到的字符串数组没有空值<br>原理：</p><ul><li>先将字符串与分隔符做匹配</li><li>匹配到之后将分隔符之前的子串分割add到一个list集合中</li><li>最后使用list.toArray返回最终的数组</li></ul><h4 id="join-待续"><a href="#join-待续" class="headerlink" title="join  待续"></a>join  待续</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;StringUtils&quot;&gt;&lt;a href=&quot;#StringUtils&quot; class=&quot;headerlink&quot; title=&quot;StringUtils&quot;&gt;&lt;/a&gt;StringUtils&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;工作中很多操作字符串的操作，使用到了工具类这里总结下，o
      
    
    </summary>
    
    
      <category term="utils" scheme="http://yoursite.com/tags/utils/"/>
    
  </entry>
  
  <entry>
    <title>Arrays</title>
    <link href="http://yoursite.com/2019/07/26/Arrays/"/>
    <id>http://yoursite.com/2019/07/26/Arrays/</id>
    <published>2019-07-26T11:31:27.000Z</published>
    <updated>2019-07-29T07:50:19.522Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h4 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看要被拷贝到的数组长度是不是够用，够用的话直接调用System.arraycopy方法；不够用创建一个新的与源数组同样长度的数组进行拷贝<br><strong>如果数组中是引用类型，Arrays.copy拷贝的是引用，不会新创建对象，如果要对拷贝的数组做修改操作源数组同样会受到影响，而字符串数组由于字符串常量池的存在，当修改字符串的时候会新创建一个字符串并将新的引用付给数组，所以源数组对应的字符串并不会发生变化</strong></p><h5 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy"></a>System.arraycopy</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static native void arraycopy(Object src,  int  srcPos,</span><br><span class="line">                                    Object dest, int destPos,</span><br><span class="line">                                    int length);</span><br></pre></td></tr></table></figure><p>这是一个本地方法，就看一下参数吧</p><ul><li>src—-the source array. </li><li>srcPos—-starting position in the source array.</li><li>dest—-the destination array.</li><li>destPos—-starting position in the destination data.</li><li>length—-the number of array elements to be copied.</li></ul><h4 id="asList"><a href="#asList" class="headerlink" title="asList"></a>asList</h4><p>将字符串转成ArrayList集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;</span><br><span class="line">    return new ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的ArrayList是Arrays中的一个内部类，继承了AbstractList方法，内部值实现了部分方法，简单点说这个集合是只读的，不能进行修改和删除操作，因为没有重写相关的方法。</p><h4 id="copyOfRange"><a href="#copyOfRange" class="headerlink" title="copyOfRange"></a>copyOfRange</h4><p>按照范围拷贝数组 [from,to) 左开右闭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T[] copyOfRange(T[] original, int from, int to) &#123;</span><br><span class="line">    return copyOfRange(original, from, to, (Class&lt;? extends T[]&gt;) original.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>集合工具类 Collections.sort 其实就是调用 Arrays.sort 方法对集合进行排序的，该方法先调用 toArray 方法将集合转成object数组，然后再调用 Arrays.sort 方法对数组进行排序，最后再将排序号的数组通过迭代器set到新的集合中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Object[] a) &#123;</span><br><span class="line">    if (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a);</span><br><span class="line">    else</span><br><span class="line">        ComparableTimSort.sort(a, 0, a.length, null, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到sort方法是通过userRequested的标志来选中排序的方式，从jdk7以后默认为false，使用TimSort的方式排序，（通过System.setProperty(“java.util.Arrays.useLegacyMergeSort”, “true”)修改）</p><ul><li>userRequested为true使用LegacyMergeSort的方式进行排序，当数组长度小于7时使用插入排序，当数组长度大于7时使用归并排序，归并到长度小于7的长度再次使用插入排序</li><li>userRequested为false采用TimSort的方式排序</li></ul><h5 id="TimSort"><a href="#TimSort" class="headerlink" title="TimSort"></a>TimSort</h5><ul><li>1.数组长度小于32时，首先在数组中从开头开始寻找升序的子数组，没有的话找降序的子数组再反转，然后将数组中的剩余元素使用二分查找的方式插入到子数组中</li><li>2.数组长度大于32时，将数组切分若干个长度在[16,32)的区块（jdk里叫run，我理解为区块）</li><li>3.每个区块再使用第一步的方式进行排序排序后将每个区块进行合并，合并的过程有两点优化<ul><li>a.合并区块的过程中通过限制条件来完成将连续的三个区块中较小的两个优先合并降低复杂度</li><li>b.两个区块合并时，先将区块1的头元素和尾元素插入到区块2中，相当于缩小了插入区块2的范围降低复杂度</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) &#123;</span><br><span class="line">    assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">    int nRemaining  = hi - lo;</span><br><span class="line">    if (nRemaining &lt; 2)</span><br><span class="line">        return;  // Arrays of size 0 and 1 are always sorted</span><br><span class="line"></span><br><span class="line">    // If array is small, do a &quot;mini-TimSort&quot; with no merges</span><br><span class="line">    if (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">        int initRunLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line">        binarySort(a, lo, hi, lo + initRunLen);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * March over the array once, left to right, finding natural runs,</span><br><span class="line">     * extending short natural runs to minRun elements, and merging runs</span><br><span class="line">     * to maintain stack invariant.</span><br><span class="line">     */</span><br><span class="line">    ComparableTimSort ts = new ComparableTimSort(a, work, workBase, workLen);</span><br><span class="line">    int minRun = minRunLength(nRemaining);</span><br><span class="line">    do &#123;</span><br><span class="line">        // Identify next run</span><br><span class="line">        int runLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line"></span><br><span class="line">        // If run is short, extend to min(minRun, nRemaining)</span><br><span class="line">        if (runLen &lt; minRun) &#123;</span><br><span class="line">            int force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">            binarySort(a, lo, lo + force, lo + runLen);</span><br><span class="line">            runLen = force;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Push run onto pending-run stack, and maybe merge</span><br><span class="line">        ts.pushRun(lo, runLen);</span><br><span class="line">        ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">        // Advance to find next run</span><br><span class="line">        lo += runLen;</span><br><span class="line">        nRemaining -= runLen;</span><br><span class="line">    &#125; while (nRemaining != 0);</span><br><span class="line"></span><br><span class="line">    // Merge all remaining runs to complete sort</span><br><span class="line">    assert lo == hi;</span><br><span class="line">    ts.mergeForceCollapse();</span><br><span class="line">    assert ts.stackSize == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Arrays&quot;&gt;&lt;a href=&quot;#Arrays&quot; class=&quot;headerlink&quot; title=&quot;Arrays&quot;&gt;&lt;/a&gt;Arrays&lt;/h3&gt;&lt;h4 id=&quot;copyOf&quot;&gt;&lt;a href=&quot;#copyOf&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="jdk" scheme="http://yoursite.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList</title>
    <link href="http://yoursite.com/2019/07/26/ArrayList/"/>
    <id>http://yoursite.com/2019/07/26/ArrayList/</id>
    <published>2019-07-26T11:31:05.000Z</published>
    <updated>2019-08-05T01:13:45.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="toArray-T-a"><a href="#toArray-T-a" class="headerlink" title="toArray(T[] a)"></a>toArray(T[] a)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    if (a.length &lt; size)</span><br><span class="line">        // Make a new array of a&apos;s runtime type, but my contents:</span><br><span class="line">        return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">    if (a.length &gt; size)</span><br><span class="line">        a[size] = null;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了Arrays.copyOf方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h3&gt;&lt;h4 id=&quot;toArray-T-a&quot;&gt;&lt;a href=&quot;#toArray-T-a&quot; c
      
    
    </summary>
    
    
      <category term="collections" scheme="http://yoursite.com/tags/collections/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis入门（续）-CRUD</title>
    <link href="http://yoursite.com/2019/07/12/MyBatis%E5%85%A5%E9%97%A8%E7%BB%AD-CRUD%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/07/12/MyBatis入门续-CRUD测试/</id>
    <published>2019-07-12T08:04:18.000Z</published>
    <updated>2019-08-14T09:38:11.533Z</updated>
    
    <content type="html"><![CDATA[<h4 id="根据用户名查询"><a href="#根据用户名查询" class="headerlink" title="根据用户名查询"></a>根据用户名查询</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUserByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.example.mybatisdemo.bean.User&quot;&gt;</span><br><span class="line">        SELECT * FROM users WHERE name = #&#123;VALUE&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.selectOne(&quot;test.findUserByName&quot;, &quot;yywang&quot;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="模糊查询，返回多个值"><a href="#模糊查询，返回多个值" class="headerlink" title="模糊查询，返回多个值"></a>模糊查询，返回多个值</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUserLikeName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.example.mybatisdemo.bean.User&quot;&gt;</span><br><span class="line">        SELECT * FROM users WHERE name like #&#123;VALUE&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.selectList(&quot;test.findUserLikeName&quot;, &quot;%yy%&quot;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.example.mybatisdemo.bean.User&quot;&gt;</span><br><span class="line">        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt;</span><br><span class="line">            SELECT LAST_INSERT_ID()</span><br><span class="line">        &lt;/selectKey&gt;</span><br><span class="line">        INSERT into users(uname,sex,age,udesc) values (#&#123;uname&#125;,#&#123;sex&#125;,#&#123;age&#125;,#&#123;udesc&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = new User(&quot;bangni&quot;,&quot;female&quot;,22,&quot;tc&quot;);</span><br><span class="line">sqlSession.commit(); // 必加</span><br></pre></td></tr></table></figure><h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><ul><li><em>selectKey</em> 用来配置返回主键 </li><li><em>keyProperty</em>  表中主键的名称</li><li><em>order</em> 表示SELECT LAST_INSERT_ID()在insert语句发生的顺序，after意为insert执行之后返回，用于自增主键，UUID的方式可以配置为before</li><li><em>resultType</em> 返回值类型</li></ul><p><strong><em>注1：sql语句中有多个参数，占位符#{}也需要指定不同的表示方式，如上#{uname},#{sex}等</em></strong></p><p><strong><em>注2：sql没问题运行报错，因为之前的数据表设计问题，name和desc是关键字，这里开始做了修改</em></strong></p><p><strong><em>注3：修改之后运行通过，数据库查不到记录，想到之前测试Junit回自动回滚，于是添加@Rollback注解导入依赖后还是无果，最终加上session.commit()解决，由于MyBatis接管了JDBC的事务管理器，JDBC回自动提交而MyBatis不会，这里需要自行手动提交，修改删除同样</em></strong></p></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete id=&quot;delUserById&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">        delete from users where id = #&#123;id&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.delete(&quot;test.delUserById&quot;,3);</span><br><span class="line">  sqlSession.commit();</span><br></pre></td></tr></table></figure></li></ul><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;updateUserById&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">        update users set age = 0 where id = #&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.update(&quot;test.updateUserById&quot;,8);</span><br><span class="line">  sqlSession.commit();</span><br></pre></td></tr></table></figure></li></ul><h4 id="查看最后执行的SQL"><a href="#查看最后执行的SQL" class="headerlink" title="查看最后执行的SQL"></a>查看最后执行的SQL</h4><p>只需在配置文件中添加配置即可打印查询语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;根据用户名查询&quot;&gt;&lt;a href=&quot;#根据用户名查询&quot; class=&quot;headerlink&quot; title=&quot;根据用户名查询&quot;&gt;&lt;/a&gt;根据用户名查询&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>IDEA配置Junit测试</title>
    <link href="http://yoursite.com/2019/07/12/IDEA%E9%85%8D%E7%BD%AEJunit%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/07/12/IDEA配置Junit测试/</id>
    <published>2019-07-12T07:10:02.000Z</published>
    <updated>2019-07-12T07:28:44.583Z</updated>
    
    <content type="html"><![CDATA[<p>看了很多博客后感觉还是比较乱，这篇还不错马一下<br><em><a href="https://blog.csdn.net/hanchao5272/article/details/79197989" target="_blank" rel="noopener">https://blog.csdn.net/hanchao5272/article/details/79197989</a></em></p><h4 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1.安装插件"></a>1.安装插件</h4><p>File-&gt;setting-&gt;Plugins-&gt;搜索并安装Junit Generator 2.0-&gt;重启IDEA</p><h4 id="2-配置插件"><a href="#2-配置插件" class="headerlink" title="2.配置插件"></a>2.配置插件</h4><p>File-&gt;setting-&gt;    OtherSettings-&gt;Junit Generator-&gt;properties</p><ul><li>修改<em>Output Path[输出路径]</em>为<em>${SOURCEPATH}/../../test/java/${PACKAGE}/${FILENAME}</em></li><li>修改 Default Template[默认模板]为JUnit4</li><li>选中JUnit4页签，将<em>package test.$entry.packageName;</em> 修改成<em>package $entry.packageName;</em></li></ul><h4 id="3-配置测试的目录"><a href="#3-配置测试的目录" class="headerlink" title="3.配置测试的目录"></a>3.配置测试的目录</h4><p>File-&gt;Project Structure-&gt;Modules中将测试目录设置为Test Source Floder</p><h4 id="4-生成测试类"><a href="#4-生成测试类" class="headerlink" title="4.生成测试类"></a>4.生成测试类</h4><ul><li>在要测试的类中用快捷键 alt+insert -&gt; Junit Test -&gt; Junit4</li></ul><h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h4><ul><li>鼠标右键菜单<ul><li>将鼠标光标放在方法相关代码中，右键弹出菜单中会显示运行此测试方法的菜单，点击就会运行方法单独测试。<br>将鼠标光标放在方法之外的代码中，右键弹出菜单中会显示运行此类的所有测试方法的菜单，点击就会运行所有测试方法。</li></ul></li><li>快捷键<ul><li>将鼠标光标放在方法相关代码中，通过快捷键Ctrl+Shift+F10，运行当前测试方法。</li><li>将鼠标光标放在方法之外的代码中，通过快捷键Ctrl+Shift+F10，运行当前类的所有测试方法。</li></ul></li><li>快捷按钮<ul><li>点击方法左侧的Run Test按钮，运行当前测试方法。</li><li>点击类左侧的Run Test按钮，运行当前类的所有测试方法。</li></ul></li></ul><h4 id="6-测试结果"><a href="#6-测试结果" class="headerlink" title="6.测试结果"></a>6.测试结果</h4><p><img src="/images/pasted-12.png" alt="upload successful"></p><ul><li>1.方法测试成功</li><li>2.方法测试失败</li><li>3.测试用时（毫秒）</li><li>4.期望值</li><li>5.实际值</li><li>6.异常信息</li></ul><h4 id="7-异常"><a href="#7-异常" class="headerlink" title="7.异常"></a>7.异常</h4><ul><li><img src="/images/pasted-13.png" alt="upload successful"></li><li>原因：4.11以上版本不在包含hamcrest</li><li>解决：改用4.10  ^_^</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看了很多博客后感觉还是比较乱，这篇还不错马一下&lt;br&gt;&lt;em&gt;&lt;a href=&quot;https://blog.csdn.net/hanchao5272/article/details/79197989&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
      <category term="IDEA" scheme="http://yoursite.com/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis入门</title>
    <link href="http://yoursite.com/2019/07/12/MyBatis%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/07/12/MyBatis入门/</id>
    <published>2019-07-12T05:16:20.000Z</published>
    <updated>2019-07-12T06:21:23.205Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MyBatis环境"><a href="#MyBatis环境" class="headerlink" title="MyBatis环境"></a>MyBatis环境</h4><h5 id="首先准备数据库表"><a href="#首先准备数据库表" class="headerlink" title="首先准备数据库表"></a>首先准备数据库表</h5><ul><li>对应的实体类为</li></ul><ul><li><figure class="highlight plain"><figcaption><span>class User &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> private int id;</span><br><span class="line"> private String name;</span><br><span class="line"> private String sex;</span><br><span class="line"> private int age;</span><br><span class="line"> private String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="数据库配置文件-SqlMapConfig-xml"><a href="#数据库配置文件-SqlMapConfig-xml" class="headerlink" title="数据库配置文件 SqlMapConfig.xml"></a>数据库配置文件 <em>SqlMapConfig.xml</em></h5><ul><li>配置数据库环境相关</li></ul><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line"> &lt;/environments&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="sql映射文件-user-xml"><a href="#sql映射文件-user-xml" class="headerlink" title="sql映射文件 user.xml"></a>sql映射文件 <em>user.xml</em></h5><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;test&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.example.mybatisdemo.bean.User&quot;&gt;</span><br><span class="line">        SELECT * FROM user WHERE id =#&#123;VALUE&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="将sql映射添加到SqlMapConfig-xml中"><a href="#将sql映射添加到SqlMapConfig-xml中" class="headerlink" title="将sql映射添加到SqlMapConfig.xml中"></a>将sql映射添加到SqlMapConfig.xml中</h5><ul><li>最终的配置文件为</li></ul><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;mapper/user.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession sqlSession = factory.openSession();</span><br><span class="line">        // 参数1 sql映射中的 namespace + &quot;.&quot; + sqlId</span><br><span class="line">        // 参数2为sql的参数</span><br><span class="line">        User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        sqlSession.close();</span><br></pre></td></tr></table></figure></li></ul><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p><em>基于sql语句的轻量级ORM框架，将sql语句写入配置文件映射中，进一步解耦，但是多了一步操作感觉比hibernate繁琐一些，但是比hibernate要快，有舍有得吧（为什么快还不知道，后续再看吧╮(╯▽╰)╭ ）</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;MyBatis环境&quot;&gt;&lt;a href=&quot;#MyBatis环境&quot; class=&quot;headerlink&quot; title=&quot;MyBatis环境&quot;&gt;&lt;/a&gt;MyBatis环境&lt;/h4&gt;&lt;h5 id=&quot;首先准备数据库表&quot;&gt;&lt;a href=&quot;#首先准备数据库表&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC入门</title>
    <link href="http://yoursite.com/2019/07/11/SpringMVC/"/>
    <id>http://yoursite.com/2019/07/11/SpringMVC/</id>
    <published>2019-07-11T07:22:35.000Z</published>
    <updated>2019-07-12T05:15:14.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC配置"><a href="#SpringMVC配置" class="headerlink" title="SpringMVC配置"></a>SpringMVC配置</h2><p><em>注解&amp;配置文件</em></p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h4><ul><li><p><img src="/images/pasted-5.png" alt="upload successful"></p></li><li><p>①指定Spring配置文件的位置</p></li><li><p>②配置Listener，初始化SpringIOC容器</p></li><li><p>③配置前端控制器servlet，其中可以自定义配置文件位置，不配置默认寻找xxxx-servlet.xml的配置文件</p></li><li><p>url-pattern中/和/*区别</p><ul><li>/*    匹配所有url  有后缀或者无后缀都会匹配   .jsp  .css  .js</li><li>/      只匹配无后缀的url</li></ul></li></ul><p><strong><em>注：截图为项目中的配置  自己测试时改为 /  项目中拦截所有页面应该会有拦截器或者过滤器做处理，demo中如果配置成截图这样会报错</em></strong></p><h4 id="springmvc-servlet-xml"><a href="#springmvc-servlet-xml" class="headerlink" title="springmvc-servlet.xml"></a>springmvc-servlet.xml</h4><p><img src="/images/pasted-6.png" alt="upload successful"></p><ul><li><p>指定基础包名scan，将指定的包名注入SpringIOC容器（先要添加context的xsd约束）</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br></pre></td></tr></table></figure><p>xsi中添加<br>“<a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a>       <a href="http://www.springframework.org/schema/context/spring-context.xsd&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/context/spring-context.xsd&quot;</a></p></li></ul></li></ul><ul><li><p>exclude-filter 指定类与Spring容器分开加载（先这么理解）</p></li><li><p>配置视图解析器（前缀和后缀）</p></li></ul><p><strong>方法中使用@RequestMapping(value=”search”)  理解为匹配URL中search的字样</strong></p><p><strong>方法return “iface/manage”;  从匹配的前后缀中寻找应该返回的视图，例如通过上图的配置找到/iface/manage.vm</strong></p><p><em>在Controller类上添加@Controller，方法上添加@RequestMapping(“xxxx”)，即可完成映射</em></p><h4 id="配置完成访问报错"><a href="#配置完成访问报错" class="headerlink" title="配置完成访问报错"></a>配置完成访问报错</h4><p><img src="/images/pasted-7.png" alt="upload successful"></p><ul><li><p>没有jstl标签库，导入依赖即可</p></li><li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="web-xml-1"><a href="#web-xml-1" class="headerlink" title="web.xml"></a>web.xml</h4><ul><li>和注解方式一样<br><img src="/images/pasted-8.png" alt="upload successful"><h4 id="springmvc-servlet-xml-1"><a href="#springmvc-servlet-xml-1" class="headerlink" title="springmvc-servlet.xml"></a>springmvc-servlet.xml</h4></li><li><img src="/images/pasted-9.png" alt="upload successful"></li><li>①配置处理器映射器</li><li>②配置处理器适配器</li><li>③配置视图解析器（同注解方式）</li><li>④配置映射（相当于注解中的@RequestMapping）</li></ul><p><em>相较于注解方式该配置文件中多了对 处理器映射器、处理器适配器 以及映射的配置</em></p><p><em>实现方面在controller类中不添加任何注解，实现Controller接口，重写方法即可</em></p><p>demo：<a href="https://github.com/panniyuyu/frameworkdemo.git" target="_blank" rel="noopener">https://github.com/panniyuyu/frameworkdemo.git</a></p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>通过使用不同方式对springMVC进行配置，感觉对SpringMVC框架大致的原理有一些认识</p><p>SpringMVC使将MVC的模式进一步拆分解耦，整个过程主要包含4个主要的部分依次是 前端控制器（DispatcherServlet）、处理器映射器（HandlerMapping）、处理器适配器（HandlerAdapter）、视图解析器（ViewResolver）</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><ul><li>1.用户发起请求，被前端控制器（DispatcherServlet）拦截，并根据请求内容询问处理器映射器（HandlerMapping）改请求应该由哪个Controller处理，处理器映射器将匹配到的Controller信息返回给前端控制器</li><li>2.前端控制器知道该请求应该由哪个Controller处理，但不会自己处理，将Controller信息交给处理器适配器（HandlerAdapter）处理，返回ModelAndView对象</li><li>3.前端控制器得到ModelAndView对象将其转发给视图解析器，将对象解析成view页面返回</li><li>4.前端控制器将view页面相应给浏览器</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringMVC配置&quot;&gt;&lt;a href=&quot;#SpringMVC配置&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC配置&quot;&gt;&lt;/a&gt;SpringMVC配置&lt;/h2&gt;&lt;p&gt;&lt;em&gt;注解&amp;amp;配置文件&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;注
      
    
    </summary>
    
    
      <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>org.apache.tomcat.util.bcel.classfile.ClassFormatException</title>
    <link href="http://yoursite.com/2019/07/11/%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/07/11/异常/</id>
    <published>2019-07-11T03:41:21.000Z</published>
    <updated>2019-07-11T10:21:53.613Z</updated>
    
    <content type="html"><![CDATA[<h4 id="org-apache-tomcat-util-bcel-classfile-ClassFormatException"><a href="#org-apache-tomcat-util-bcel-classfile-ClassFormatException" class="headerlink" title="org.apache.tomcat.util.bcel.classfile.ClassFormatException"></a>org.apache.tomcat.util.bcel.classfile.ClassFormatException</h4><ul><li><img src="/images/pasted-4.png" alt="upload successful"></li><li>原因：jdk版本不兼容</li><li>原环境 jkd8+tomcat7+spring4  </li><li>解决：tomcat7换tomcat8</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;org-apache-tomcat-util-bcel-classfile-ClassFormatException&quot;&gt;&lt;a href=&quot;#org-apache-tomcat-util-bcel-classfile-ClassFormatException&quot; cl
      
    
    </summary>
    
    
      <category term="exception" scheme="http://yoursite.com/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>IDEA使用笔记</title>
    <link href="http://yoursite.com/2019/07/11/IDEA%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/11/IDEA使用笔记/</id>
    <published>2019-07-11T03:22:21.000Z</published>
    <updated>2019-07-11T10:40:59.503Z</updated>
    
    <content type="html"><![CDATA[<h4 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h4><p>Run-&gt;Edit Configurations-&gt;Telplates中配置后在该页面左上角添加-&gt;选中Tomcat的Deployment点击部署(选用Artifacts方式)</p><h4 id="配置文件取消Unicode编码"><a href="#配置文件取消Unicode编码" class="headerlink" title="配置文件取消Unicode编码"></a>配置文件取消Unicode编码</h4><p>File-&gt;Setting-&gt;搜索file encoding-&gt;勾选Transparent native-to-ascii conversion</p><h4 id="文件目录变红色"><a href="#文件目录变红色" class="headerlink" title="文件目录变红色"></a>文件目录变红色</h4><p><img src="/images/pasted-1.png" alt="upload successful"></p><ul><li>解除版本控制即可 file-&gt;setting-&gt;version control-&gt;右上角加号-&gt;添加项目目录即可</li></ul><h4 id="新建的maven项目没有web项目的目录结构，也没有web-xml"><a href="#新建的maven项目没有web项目的目录结构，也没有web-xml" class="headerlink" title="新建的maven项目没有web项目的目录结构，也没有web.xml"></a>新建的maven项目没有web项目的目录结构，也没有web.xml</h4><ul><li>增加main目录下增加/webapp/WEB-INF目录</li><li>File-&gt;Project Structure-&gt;facets-&gt;加号-&gt;选中目录</li><li>确认路径depolyment路径为…./webapp/WEB-INF/web.xml</li><li>确认路径resource路径为 …./webapp/</li></ul><p><strong>直接创建maven web项目最为简单</strong></p><ul><li>createProject-&gt;maven-&gt;勾选Creater from archetype-&gt;选择 <strong><em>maven-archetype-webapp</em></strong> </li><li><img src="/images/pasted-2.png" alt="upload successful"></li></ul><h4 id="右键没有new-package"><a href="#右键没有new-package" class="headerlink" title="右键没有new package"></a>右键没有new package</h4><p>修改目录性质，在该目录右键-&gt;Mark Directory as-&gt;Source Root</p><h4 id="发布方式（参考https-www-cnblogs-com-dpl9963-p-10075456-html）"><a href="#发布方式（参考https-www-cnblogs-com-dpl9963-p-10075456-html）" class="headerlink" title="发布方式（参考https://www.cnblogs.com/dpl9963/p/10075456.html）"></a>发布方式（参考<a href="https://www.cnblogs.com/dpl9963/p/10075456.html）" target="_blank" rel="noopener">https://www.cnblogs.com/dpl9963/p/10075456.html）</a></h4><ul><li>jar：Java ARchrive，仅仅是编译好的Java类的聚合</li><li>war：Web application ARchrive，除Java类之外还包含jsp，config等静态资源的聚合</li><li>exploded：理解为展开不压缩，jar和war是压缩的目录节后，exploded表示不压缩的文件目录，开发是用该方式较好，文件更改后不用重新启动服务器看到效果</li></ul><h4 id="Debug模式"><a href="#Debug模式" class="headerlink" title="Debug模式"></a>Debug模式</h4><ul><li>快捷键改为eclipse后，F5，F6不变，eclipse的F8变为F9（程序放行）</li></ul><h4 id="修改文件后没有效果必须重启tomcat"><a href="#修改文件后没有效果必须重启tomcat" class="headerlink" title="修改文件后没有效果必须重启tomcat"></a>修改文件后没有效果必须重启tomcat</h4><ul><li>runConfigurations中配置</li><li><img src="/images/pasted-3.png" alt="upload successful"></li></ul><h4 id="部署项目到tomcat上，这里的url一定要改成"><a href="#部署项目到tomcat上，这里的url一定要改成" class="headerlink" title="部署项目到tomcat上，这里的url一定要改成 /"></a>部署项目到tomcat上，这里的url一定要改成 /</h4><p><img src="/images/pasted-11.png" alt="upload successful"></p><h4 id="启动tomcat日志输出乱码-淇℃伅（https-www-cnblogs-com-Yin-BoKeYuan-p-10320622-html）"><a href="#启动tomcat日志输出乱码-淇℃伅（https-www-cnblogs-com-Yin-BoKeYuan-p-10320622-html）" class="headerlink" title="启动tomcat日志输出乱码 淇℃伅（https://www.cnblogs.com/Yin-BoKeYuan/p/10320622.html）"></a>启动tomcat日志输出乱码 淇℃伅（<a href="https://www.cnblogs.com/Yin-BoKeYuan/p/10320622.html）" target="_blank" rel="noopener">https://www.cnblogs.com/Yin-BoKeYuan/p/10320622.html）</a></h4><p>打开到tomcat安装目录下的conf/文件夹 修改logging.properties文件，<br>找到 java.util.logging.ConsoleHandler.encoding = utf-8<br>更改为 java.util.logging.ConsoleHandler.encoding = GBK</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;配置Tomcat&quot;&gt;&lt;a href=&quot;#配置Tomcat&quot; class=&quot;headerlink&quot; title=&quot;配置Tomcat&quot;&gt;&lt;/a&gt;配置Tomcat&lt;/h4&gt;&lt;p&gt;Run-&amp;gt;Edit Configurations-&amp;gt;Telplates中配置后在
      
    
    </summary>
    
      <category term="IDEA" scheme="http://yoursite.com/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>知识点复习</title>
    <link href="http://yoursite.com/2019/07/09/%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/07/09/知识点复习/</id>
    <published>2019-07-09T07:49:00.000Z</published>
    <updated>2019-07-17T10:36:53.087Z</updated>
    
    <content type="html"><![CDATA[<p>整理一些在看项目时候遇到的小的知识点，先写个大概，后续再做详细的补充</p><h4 id="HTTP和TCP"><a href="#HTTP和TCP" class="headerlink" title="HTTP和TCP"></a>HTTP和TCP</h4><p>Http是在Tcp的基础之上的，也就是说Http的请求和相应是在建立Tcp链接之后发生的</p><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h4><p>一次或者多次请求同一个资源得到的结果是一样的，多次请求不会影响最终的结果。（增加去重的逻辑则无需满足幂等性）</p><h4 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h4><ul><li>在方法中锁住的是该类的实例对象</li><li>在静态方法中锁住的是类对象</li><li>代码块中（this）锁住的是该类的实例对象</li><li>代码块中（xxx.class）锁住的是类对象</li></ul><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>保证线程数据可见</p><h4 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h4><p>不做序列化和反序列化操作</p><h4 id="synchronized在方法中声名为什么还用线程安全的数据结构来存放变量"><a href="#synchronized在方法中声名为什么还用线程安全的数据结构来存放变量" class="headerlink" title="synchronized在方法中声名为什么还用线程安全的数据结构来存放变量"></a>synchronized在方法中声名为什么还用线程安全的数据结构来存放变量</h4><p>该变量可能在其他地方被调用，如果该变量只在synchronized关键字声名在方法中使用，则无需使用线程安全的数据结构。</p><h4 id="TPS-（Transaction-Per-Second）"><a href="#TPS-（Transaction-Per-Second）" class="headerlink" title="TPS （Transaction Per Second）"></a>TPS （Transaction Per Second）</h4><p>服务器每秒处理的事务个数，一个事务是从向服务器发送请求开始，客户端接收到响应结束</p><h4 id="QPS-（Query-Per-Second）"><a href="#QPS-（Query-Per-Second）" class="headerlink" title="QPS  （Query Per Second）"></a>QPS  （Query Per Second）</h4><p>服务器每秒处理查询的次数，查询开始到返回结果结束</p><h4 id="Git克隆分支命令"><a href="#Git克隆分支命令" class="headerlink" title="Git克隆分支命令"></a>Git克隆分支命令</h4><p>git clone -b [分支名称] [git地址]</p><h4 id="Git提交代码到GitHub"><a href="#Git提交代码到GitHub" class="headerlink" title="Git提交代码到GitHub"></a>Git提交代码到GitHub</h4><ul><li>创建仓库，在本地clone</li><li>本地在.git所在的目录打开git bansh</li><li><p>指定远程仓库</p><p><em>git remote add origin <a href="https://github.com/panniyuyu/frameworkdemo.git" target="_blank" rel="noopener">https://github.com/panniyuyu/frameworkdemo.git</a></em></p><ul><li>会提示 remote origin already exists    </li></ul><ul><li><p>执行删除命令后再重新指定远程仓库</p><p><em>git remote rm origin</em></p></li></ul></li><li><p>添加文件<br><em>git add </em> *</p></li><li>提交改动<br><em>git commit -m “xxxx”</em></li><li>推到远程仓库<br><em>git push origin master</em></li></ul><h4 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h4><ul><li><p>会暂停当前线程，让出CPU时间，同时让出锁，等待notify()或者notifyAll()唤醒后重新获得锁执行</p><p><em>sleep()方法同样会暂停当前线程，让出CPU时间，与 wait()方法不同的是，sleep()方法不会释放锁，会阻塞当前的线程，且sleep()是Thread类中的方法, wait()是Object的方法</em></p></li></ul><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><ul><li><p>Java中优先级低的线程，用来服务于用户线程的，当Java程序退出或者jvm退出时，守护线程自动退出，jvm运行时只需关注用户线程即可。</p><p><em>Jvm中的垃圾收集器可以理解为守护线程，当jvm退出时会自动退出</em></p><p><em>使用 thread.setDaemon(true)设置，要在start()方法之前</em></p></li></ul><h4 id="Class的isAssignableFrom方法"><a href="#Class的isAssignableFrom方法" class="headerlink" title="Class的isAssignableFrom方法"></a>Class的isAssignableFrom方法</h4><ul><li>Class中的方法，如：a.isAssignableFrom(b) 在a是b的父类或接口，亦或是a、b是同一个类或者接口的情况下返回true，其他情况返回false</li></ul><h4 id="Class的getFields和getDeclaredFields"><a href="#Class的getFields和getDeclaredFields" class="headerlink" title="Class的getFields和getDeclaredFields"></a>Class的getFields和getDeclaredFields</h4><ul><li>都是获取类中的字段，getFields获取类中public的字段，getDeclaredFields获取类中所有声名的字段，不包含父类中的字段</li></ul><h4 id="Field的getModifiers"><a href="#Field的getModifiers" class="headerlink" title="Field的getModifiers"></a>Field的getModifiers</h4><ul><li>获取字段的修饰符，返回值为int型对应不同的类型</li><li>PUBLIC: 1</li><li>PRIVATE: 2</li><li>PROTECTED: 4</li><li>STATIC: 8</li><li>FINAL: 16</li><li>SYNCHRONIZED: 32</li><li>VOLATILE: 64</li><li>TRANSIENT: 128</li><li>NATIVE: 256</li><li>INTERFACE: 512</li><li>ABSTRACT: 1024</li><li>STRICT: 2048</li></ul><h4 id="Field的setAccessible-true"><a href="#Field的setAccessible-true" class="headerlink" title="Field的setAccessible(true)"></a>Field的setAccessible(true)</h4><ul><li>字段被声名是私有的，在取值前必须设置accessible为true，不然会报错</li></ul><h4 id="field的getGenericType和getType"><a href="#field的getGenericType和getType" class="headerlink" title="field的getGenericType和getType"></a>field的getGenericType和getType</h4><ul><li>都是获取字段的类型，getGenericType返回的是Type类型，getType返回的是Class类型</li><li>还有其他不同，暂时没有理解<a href="http://www.51gjie.com/java/793.html" target="_blank" rel="noopener">http://www.51gjie.com/java/793.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理一些在看项目时候遇到的小的知识点，先写个大概，后续再做详细的补充&lt;/p&gt;
&lt;h4 id=&quot;HTTP和TCP&quot;&gt;&lt;a href=&quot;#HTTP和TCP&quot; class=&quot;headerlink&quot; title=&quot;HTTP和TCP&quot;&gt;&lt;/a&gt;HTTP和TCP&lt;/h4&gt;&lt;p&gt;Http
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://yoursite.com/2019/05/11/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2019/05/11/第一篇博客/</id>
    <published>2019-05-11T09:26:16.000Z</published>
    <updated>2019-05-11T13:34:40.425Z</updated>
    
    <content type="html"><![CDATA[<p>时光匆匆，三年的研究生生涯马上就要结束。这是我毕业论文致谢里的第一句话，虽然很老套但是非常应景，在毕业之前的这段时间没有那么多的事情，突然想到做一个自己的博客，把自己的学习和生活记录下来，不用每次遇到问题的时候再去问度娘，而且很多都是重复的问题，虽然自己也在做笔记但很少回头看，打算以前的笔记不再管了，当初为了图省事写的非常简单有些已经想不起来是做什么的了，现在想想非常懊悔，这个坏毛病一定要改。今日在我的博客搭建完成之际，开始将今后所学习的技术记录在此，沉淀下去，和大家做交流，同时，在此也将记录我的生活，有趣的所见所闻什么的，朋友圈发的频繁遭人厌。<br>马上就要入职了，心里知道要回归到工程中了，不然入职后的压力会很大，但是也不知道自己工作内容是什么，浏览了一些博客发现需要学习的东西实在是太多了无从下手，而且就我自己而言没有在工程中应用过的技术即使理解了最后也会忘掉，所以学习的情绪很down，想找一些有趣的东西搞一下，于是本站诞生了。<br>emmm……第一篇博客就到这了，自己小学语文水平只能写到这了，给自己加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时光匆匆，三年的研究生生涯马上就要结束。这是我毕业论文致谢里的第一句话，虽然很老套但是非常应景，在毕业之前的这段时间没有那么多的事情，突然想到做一个自己的博客，把自己的学习和生活记录下来，不用每次遇到问题的时候再去问度娘，而且很多都是重复的问题，虽然自己也在做笔记但很少回头
      
    
    </summary>
    
      <category term="生活杂谈" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="生活杂谈" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
