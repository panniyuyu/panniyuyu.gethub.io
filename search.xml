<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[StringUtils]]></title>
    <url>%2F2019%2F07%2F26%2FStringUtils%2F</url>
    <content type="text"><![CDATA[StringUtils 工作中很多操作字符串的操作，使用到了工具类这里总结下，org.apache.commons.lang3包下的 split(String str, String separatorChars)–&gt;切分字符串123public static String[] split(String str, String separatorChars) &#123; return splitWorker(str, separatorChars, -1, false);&#125; 参数： int max -&gt;the maximum number of elements to include in the array. A zero or negative value implies no limit.这个参数代表返回的字符串的最大长度，0或者-1代表不限制长度 boolean preserveAllTokens -&gt; if {@code true}, adjacent separators are treated as empty token separators; if {@code false}, adjacent separators are treated as one separator. 这个参数是连续分隔符规则的标志，如果为true连续的分隔符都会匹配，最终得到的字符串数组会有空的值，jdk中的split就是这个规则；如果为false，连续的分隔符只会匹配一次，最终得到的数组不会有空值。eg(“1,2,3,,4,5”切分后，true得到[1,2,3,,4,5]而false得到[1,2,3,4,5])， 这也是与jdk中的split方法的区别，如果需要使用与jdk相同的规则，工具类中的splitPreserveAllTokens方法可以实现，该方法会调用splitWorker方法且最后的参数为true 所以split方法默认参数为-1和false表示数组长度不收限制，及使用第二个规则进行切割，确保得到的字符串数组没有空值原理： 先将字符串与分隔符做匹配 匹配到之后将分隔符之前的子串分割add到一个list集合中 最后使用list.toArray返回最终的数组 join 待续]]></content>
      <tags>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays]]></title>
    <url>%2F2019%2F07%2F26%2FArrays%2F</url>
    <content type="text"><![CDATA[ArrayscopyOf123456789public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(&quot;unchecked&quot;) T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 先看要被拷贝到的数组长度是不是够用，够用的话直接调用System.arraycopy方法；不够用创建一个新的与源数组同样长度的数组进行拷贝如果数组中是引用类型，Arrays.copy拷贝的是引用，不会新创建对象，如果要对拷贝的数组做修改操作源数组同样会受到影响，而字符串数组由于字符串常量池的存在，当修改字符串的时候会新创建一个字符串并将新的引用付给数组，所以源数组对应的字符串并不会发生变化 System.arraycopy123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 这是一个本地方法，就看一下参数吧 src—-the source array. srcPos—-starting position in the source array. dest—-the destination array. destPos—-starting position in the destination data. length—-the number of array elements to be copied. asList将字符串转成ArrayList集合 123public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 这里的ArrayList是Arrays中的一个内部类，继承了AbstractList方法，内部值实现了部分方法，简单点说这个集合是只读的，不能进行修改和删除操作，因为没有重写相关的方法。 copyOfRange按照范围拷贝数组 [from,to) 左开右闭123public static &lt;T&gt; T[] copyOfRange(T[] original, int from, int to) &#123; return copyOfRange(original, from, to, (Class&lt;? extends T[]&gt;) original.getClass());&#125; sort集合工具类 Collections.sort 其实就是调用 Arrays.sort 方法对集合进行排序的，该方法先调用 toArray 方法将集合转成object数组，然后再调用 Arrays.sort 方法对数组进行排序，最后再将排序号的数组通过迭代器set到新的集合中去。 123456public static void sort(Object[] a) &#123; if (LegacyMergeSort.userRequested) legacyMergeSort(a); else ComparableTimSort.sort(a, 0, a.length, null, 0, 0);&#125; 可以看到sort方法是通过userRequested的标志来选中排序的方式，从jdk7以后默认为false，使用TimSort的方式排序，（通过System.setProperty(“java.util.Arrays.useLegacyMergeSort”, “true”)修改） userRequested为true使用LegacyMergeSort的方式进行排序，当数组长度小于7时使用插入排序，当数组长度大于7时使用归并排序，归并到长度小于7的长度再次使用插入排序 userRequested为false采用TimSort的方式排序 TimSort 1.数组长度小于32时，首先在数组中从开头开始寻找升序的子数组，没有的话找降序的子数组再反转，然后将数组中的剩余元素使用二分查找的方式插入到子数组中 2.数组长度大于32时，将数组切分若干个长度在[16,32)的区块（jdk里叫run，我理解为区块） 3.每个区块再使用第一步的方式进行排序排序后将每个区块进行合并，合并的过程有两点优化 a.合并区块的过程中通过限制条件来完成将连续的三个区块中较小的两个优先合并降低复杂度 b.两个区块合并时，先将区块1的头元素和尾元素插入到区块2中，相当于缩小了插入区块2的范围降低复杂度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) &#123; assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length; int nRemaining = hi - lo; if (nRemaining &lt; 2) return; // Arrays of size 0 and 1 are always sorted // If array is small, do a &quot;mini-TimSort&quot; with no merges if (nRemaining &lt; MIN_MERGE) &#123; int initRunLen = countRunAndMakeAscending(a, lo, hi); binarySort(a, lo, hi, lo + initRunLen); return; &#125; /** * March over the array once, left to right, finding natural runs, * extending short natural runs to minRun elements, and merging runs * to maintain stack invariant. */ ComparableTimSort ts = new ComparableTimSort(a, work, workBase, workLen); int minRun = minRunLength(nRemaining); do &#123; // Identify next run int runLen = countRunAndMakeAscending(a, lo, hi); // If run is short, extend to min(minRun, nRemaining) if (runLen &lt; minRun) &#123; int force = nRemaining &lt;= minRun ? nRemaining : minRun; binarySort(a, lo, lo + force, lo + runLen); runLen = force; &#125; // Push run onto pending-run stack, and maybe merge ts.pushRun(lo, runLen); ts.mergeCollapse(); // Advance to find next run lo += runLen; nRemaining -= runLen; &#125; while (nRemaining != 0); // Merge all remaining runs to complete sort assert lo == hi; ts.mergeForceCollapse(); assert ts.stackSize == 1;&#125;]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList]]></title>
    <url>%2F2019%2F07%2F26%2FArrayList%2F</url>
    <content type="text"><![CDATA[ArrayListtoArray(T[] a)123456789public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a&apos;s runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a;&#125; 使用了Arrays.copyOf方法]]></content>
      <tags>
        <tag>jdk,collections</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis入门（续）-CRUD]]></title>
    <url>%2F2019%2F07%2F12%2FMyBatis%E5%85%A5%E9%97%A8%E7%BB%AD-CRUD%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[根据用户名查询 123&lt;select id=&quot;findUserByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.example.mybatisdemo.bean.User&quot;&gt; SELECT * FROM users WHERE name = #&#123;VALUE&#125; &lt;/select&gt; 1sqlSession.selectOne(&quot;test.findUserByName&quot;, &quot;yywang&quot;) 模糊查询，返回多个值 123&lt;select id=&quot;findUserLikeName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.example.mybatisdemo.bean.User&quot;&gt; SELECT * FROM users WHERE name like #&#123;VALUE&#125; &lt;/select&gt; 1sqlSession.selectList(&quot;test.findUserLikeName&quot;, &quot;%yy%&quot;); 添加数据 123456&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.example.mybatisdemo.bean.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT into users(uname,sex,age,udesc) values (#&#123;uname&#125;,#&#123;sex&#125;,#&#123;age&#125;,#&#123;udesc&#125;) &lt;/insert&gt; 12User user = new User(&quot;bangni&quot;,&quot;female&quot;,22,&quot;tc&quot;);sqlSession.commit(); // 必加 tips selectKey 用来配置返回主键 keyProperty 表中主键的名称 order 表示SELECT LAST_INSERT_ID()在insert语句发生的顺序，after意为insert执行之后返回，用于自增主键，UUID的方式可以配置为before resultType 返回值类型 注1：sql语句中有多个参数，占位符#{}也需要指定不同的表示方式，如上#{uname},#{sex}等 注2：sql没问题运行报错，因为之前的数据表设计问题，name和desc是关键字，这里开始做了修改 注3：修改之后运行通过，数据库查不到记录，想到之前测试Junit回自动回滚，于是添加@Rollback注解导入依赖后还是无果，最终加上session.commit()解决，由于MyBatis接管了JDBC的事务管理器，JDBC回自动提交而MyBatis不会，这里需要自行手动提交，修改删除同样 删除 123&lt;delete id=&quot;delUserById&quot; parameterType=&quot;int&quot;&gt; delete from users where id = #&#123;id&#125; &lt;/delete&gt; 12sqlSession.delete(&quot;test.delUserById&quot;,3); sqlSession.commit(); 更新 123&lt;update id=&quot;updateUserById&quot; parameterType=&quot;int&quot;&gt; update users set age = 0 where id = #&#123;id&#125; &lt;/update&gt; 12sqlSession.update(&quot;test.updateUserById&quot;,8); sqlSession.commit();]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA配置Junit测试]]></title>
    <url>%2F2019%2F07%2F12%2FIDEA%E9%85%8D%E7%BD%AEJunit%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[看了很多博客后感觉还是比较乱，这篇还不错马一下https://blog.csdn.net/hanchao5272/article/details/79197989 1.安装插件File-&gt;setting-&gt;Plugins-&gt;搜索并安装Junit Generator 2.0-&gt;重启IDEA 2.配置插件File-&gt;setting-&gt; OtherSettings-&gt;Junit Generator-&gt;properties 修改Output Path[输出路径]为${SOURCEPATH}/../../test/java/${PACKAGE}/${FILENAME} 修改 Default Template[默认模板]为JUnit4 选中JUnit4页签，将package test.$entry.packageName; 修改成package $entry.packageName; 3.配置测试的目录File-&gt;Project Structure-&gt;Modules中将测试目录设置为Test Source Floder 4.生成测试类 在要测试的类中用快捷键 alt+insert -&gt; Junit Test -&gt; Junit4 5.测试 鼠标右键菜单 将鼠标光标放在方法相关代码中，右键弹出菜单中会显示运行此测试方法的菜单，点击就会运行方法单独测试。将鼠标光标放在方法之外的代码中，右键弹出菜单中会显示运行此类的所有测试方法的菜单，点击就会运行所有测试方法。 快捷键 将鼠标光标放在方法相关代码中，通过快捷键Ctrl+Shift+F10，运行当前测试方法。 将鼠标光标放在方法之外的代码中，通过快捷键Ctrl+Shift+F10，运行当前类的所有测试方法。 快捷按钮 点击方法左侧的Run Test按钮，运行当前测试方法。 点击类左侧的Run Test按钮，运行当前类的所有测试方法。 6.测试结果 1.方法测试成功 2.方法测试失败 3.测试用时（毫秒） 4.期望值 5.实际值 6.异常信息 7.异常 原因：4.11以上版本不在包含hamcrest 解决：改用4.10 ^_^]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis入门]]></title>
    <url>%2F2019%2F07%2F12%2FMyBatis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[MyBatis环境首先准备数据库表 对应的实体类为 class User &#123;123456 private int id; private String name; private String sex; private int age; private String desc;&#125; 数据库配置文件 SqlMapConfig.xml 配置数据库环境相关 1234567891011&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; sql映射文件 user.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.example.mybatisdemo.bean.User&quot;&gt; SELECT * FROM user WHERE id =#&#123;VALUE&#125; &lt;/select&gt;&lt;/mapper&gt; 将sql映射添加到SqlMapConfig.xml中 最终的配置文件为 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mapper/user.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 测试 123456789String resource = &quot;SqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = factory.openSession(); // 参数1 sql映射中的 namespace + &quot;.&quot; + sqlId // 参数2为sql的参数 User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1); System.out.println(user.toString()); sqlSession.close(); 理解基于sql语句的轻量级ORM框架，将sql语句写入配置文件映射中，进一步解耦，但是多了一步操作感觉比hibernate繁琐一些，但是比hibernate要快，有舍有得吧（为什么快还不知道，后续再看吧╮(╯▽╰)╭ ）]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC入门]]></title>
    <url>%2F2019%2F07%2F11%2FSpringMVC%2F</url>
    <content type="text"><![CDATA[SpringMVC配置注解&amp;配置文件 注解web.xml ①指定Spring配置文件的位置 ②配置Listener，初始化SpringIOC容器 ③配置前端控制器servlet，其中可以自定义配置文件位置，不配置默认寻找xxxx-servlet.xml的配置文件 url-pattern中/和/*区别 /* 匹配所有url 有后缀或者无后缀都会匹配 .jsp .css .js / 只匹配无后缀的url 注：截图为项目中的配置 自己测试时改为 / 项目中拦截所有页面应该会有拦截器或者过滤器做处理，demo中如果配置成截图这样会报错 springmvc-servlet.xml 指定基础包名scan，将指定的包名注入SpringIOC容器（先要添加context的xsd约束） 1xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi中添加“http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; exclude-filter 指定类与Spring容器分开加载（先这么理解） 配置视图解析器（前缀和后缀） 方法中使用@RequestMapping(value=”search”) 理解为匹配URL中search的字样 方法return “iface/manage”; 从匹配的前后缀中寻找应该返回的视图，例如通过上图的配置找到/iface/manage.vm 在Controller类上添加@Controller，方法上添加@RequestMapping(“xxxx”)，即可完成映射 配置完成访问报错 没有jstl标签库，导入依赖即可 1234&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; 配置文件web.xml 和注解方式一样springmvc-servlet.xml ①配置处理器映射器 ②配置处理器适配器 ③配置视图解析器（同注解方式） ④配置映射（相当于注解中的@RequestMapping） 相较于注解方式该配置文件中多了对 处理器映射器、处理器适配器 以及映射的配置 实现方面在controller类中不添加任何注解，实现Controller接口，重写方法即可 demo：https://github.com/panniyuyu/frameworkdemo.git 理解通过使用不同方式对springMVC进行配置，感觉对SpringMVC框架大致的原理有一些认识 SpringMVC使将MVC的模式进一步拆分解耦，整个过程主要包含4个主要的部分依次是 前端控制器（DispatcherServlet）、处理器映射器（HandlerMapping）、处理器适配器（HandlerAdapter）、视图解析器（ViewResolver） 1.用户发起请求，被前端控制器（DispatcherServlet）拦截，并根据请求内容询问处理器映射器（HandlerMapping）改请求应该由哪个Controller处理，处理器映射器将匹配到的Controller信息返回给前端控制器 2.前端控制器知道该请求应该由哪个Controller处理，但不会自己处理，将Controller信息交给处理器适配器（HandlerAdapter）处理，返回ModelAndView对象 3.前端控制器得到ModelAndView对象将其转发给视图解析器，将对象解析成view页面返回 4.前端控制器将view页面相应给浏览器]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[org.apache.tomcat.util.bcel.classfile.ClassFormatException]]></title>
    <url>%2F2019%2F07%2F11%2F%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[org.apache.tomcat.util.bcel.classfile.ClassFormatException 原因：jdk版本不兼容 原环境 jkd8+tomcat7+spring4 解决：tomcat7换tomcat8]]></content>
      <tags>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA使用笔记]]></title>
    <url>%2F2019%2F07%2F11%2FIDEA%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[配置TomcatRun-&gt;Edit Configurations-&gt;Telplates中配置后在该页面左上角添加-&gt;选中Tomcat的Deployment点击部署(选用Artifacts方式) 配置文件取消Unicode编码File-&gt;Setting-&gt;搜索file encoding-&gt;勾选Transparent native-to-ascii conversion 文件目录变红色 解除版本控制即可 file-&gt;setting-&gt;version control-&gt;右上角加号-&gt;添加项目目录即可 新建的maven项目没有web项目的目录结构，也没有web.xml 增加main目录下增加/webapp/WEB-INF目录 File-&gt;Project Structure-&gt;facets-&gt;加号-&gt;选中目录 确认路径depolyment路径为…./webapp/WEB-INF/web.xml 确认路径resource路径为 …./webapp/ 直接创建maven web项目最为简单 createProject-&gt;maven-&gt;勾选Creater from archetype-&gt;选择 maven-archetype-webapp 右键没有new package修改目录性质，在该目录右键-&gt;Mark Directory as-&gt;Source Root 发布方式（参考https://www.cnblogs.com/dpl9963/p/10075456.html） jar：Java ARchrive，仅仅是编译好的Java类的聚合 war：Web application ARchrive，除Java类之外还包含jsp，config等静态资源的聚合 exploded：理解为展开不压缩，jar和war是压缩的目录节后，exploded表示不压缩的文件目录，开发是用该方式较好，文件更改后不用重新启动服务器看到效果 Debug模式 快捷键改为eclipse后，F5，F6不变，eclipse的F8变为F9（程序放行） 修改文件后没有效果必须重启tomcat runConfigurations中配置 部署项目到tomcat上，这里的url一定要改成 / 启动tomcat日志输出乱码 淇℃伅（https://www.cnblogs.com/Yin-BoKeYuan/p/10320622.html）打开到tomcat安装目录下的conf/文件夹 修改logging.properties文件，找到 java.util.logging.ConsoleHandler.encoding = utf-8更改为 java.util.logging.ConsoleHandler.encoding = GBK]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点复习]]></title>
    <url>%2F2019%2F07%2F09%2F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[整理一些在看项目时候遇到的小的知识点，先写个大概，后续再做详细的补充 HTTP和TCPHttp是在Tcp的基础之上的，也就是说Http的请求和相应是在建立Tcp链接之后发生的 幂等性一次或者多次请求同一个资源得到的结果是一样的，多次请求不会影响最终的结果。（增加去重的逻辑则无需满足幂等性） synchronized 关键字 在方法中锁住的是该类的实例对象 在静态方法中锁住的是类对象 代码块中（this）锁住的是该类的实例对象 代码块中（xxx.class）锁住的是类对象 volatile保证线程数据可见 transient 关键字不做序列化和反序列化操作 synchronized在方法中声名为什么还用线程安全的数据结构来存放变量该变量可能在其他地方被调用，如果该变量只在synchronized关键字声名在方法中使用，则无需使用线程安全的数据结构。 TPS （Transaction Per Second）服务器每秒处理的事务个数，一个事务是从向服务器发送请求开始，客户端接收到响应结束 QPS （Query Per Second）服务器每秒处理查询的次数，查询开始到返回结果结束 Git克隆分支命令git clone -b [分支名称] [git地址] Git提交代码到GitHub 创建仓库，在本地clone 本地在.git所在的目录打开git bansh 指定远程仓库 git remote add origin https://github.com/panniyuyu/frameworkdemo.git 会提示 remote origin already exists 执行删除命令后再重新指定远程仓库 git remote rm origin 添加文件git add * 提交改动git commit -m “xxxx” 推到远程仓库git push origin master wait()方法 会暂停当前线程，让出CPU时间，同时让出锁，等待notify()或者notifyAll()唤醒后重新获得锁执行 sleep()方法同样会暂停当前线程，让出CPU时间，与 wait()方法不同的是，sleep()方法不会释放锁，会阻塞当前的线程，且sleep()是Thread类中的方法, wait()是Object的方法 守护线程 Java中优先级低的线程，用来服务于用户线程的，当Java程序退出或者jvm退出时，守护线程自动退出，jvm运行时只需关注用户线程即可。 Jvm中的垃圾收集器可以理解为守护线程，当jvm退出时会自动退出 使用 thread.setDaemon(true)设置，要在start()方法之前 Class的isAssignableFrom方法 Class中的方法，如：a.isAssignableFrom(b) 在a是b的父类或接口，亦或是a、b是同一个类或者接口的情况下返回true，其他情况返回false Class的getFields和getDeclaredFields 都是获取类中的字段，getFields获取类中public的字段，getDeclaredFields获取类中所有声名的字段，不包含父类中的字段 Field的getModifiers 获取字段的修饰符，返回值为int型对应不同的类型 PUBLIC: 1 PRIVATE: 2 PROTECTED: 4 STATIC: 8 FINAL: 16 SYNCHRONIZED: 32 VOLATILE: 64 TRANSIENT: 128 NATIVE: 256 INTERFACE: 512 ABSTRACT: 1024 STRICT: 2048 Field的setAccessible(true) 字段被声名是私有的，在取值前必须设置accessible为true，不然会报错 field的getGenericType和getType 都是获取字段的类型，getGenericType返回的是Type类型，getType返回的是Class类型 还有其他不同，暂时没有理解http://www.51gjie.com/java/793.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2019%2F05%2F11%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[时光匆匆，三年的研究生生涯马上就要结束。这是我毕业论文致谢里的第一句话，虽然很老套但是非常应景，在毕业之前的这段时间没有那么多的事情，突然想到做一个自己的博客，把自己的学习和生活记录下来，不用每次遇到问题的时候再去问度娘，而且很多都是重复的问题，虽然自己也在做笔记但很少回头看，打算以前的笔记不再管了，当初为了图省事写的非常简单有些已经想不起来是做什么的了，现在想想非常懊悔，这个坏毛病一定要改。今日在我的博客搭建完成之际，开始将今后所学习的技术记录在此，沉淀下去，和大家做交流，同时，在此也将记录我的生活，有趣的所见所闻什么的，朋友圈发的频繁遭人厌。马上就要入职了，心里知道要回归到工程中了，不然入职后的压力会很大，但是也不知道自己工作内容是什么，浏览了一些博客发现需要学习的东西实在是太多了无从下手，而且就我自己而言没有在工程中应用过的技术即使理解了最后也会忘掉，所以学习的情绪很down，想找一些有趣的东西搞一下，于是本站诞生了。emmm……第一篇博客就到这了，自己小学语文水平只能写到这了，给自己加油！]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>生活杂谈</tag>
      </tags>
  </entry>
</search>
