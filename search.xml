<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一次Spring事务不回滚的踩坑记录]]></title>
    <url>%2F2019%2F08%2F16%2F%E4%B8%80%E6%AC%A1Spring%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%9B%9E%E6%BB%9A%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[一次Spring事务不回滚的踩坑记录Spring事务不回滚八成是不知道Spring默认在捕获到unchecked异常才会自动回滚，然而我早已踩过个坑，是一个有经验的人，当我自信满满的加上一行 1/0，并在catch中 throw new RuntimeException，debug之后我懵了，咋不回滚呢？重启Tomcat，浏览器缓存清理之后再试一次，还是不行！！！我就难受了，这和我预想的不一样，检查代码没有发现错误，那咋办呢？开始百度吧，百度的结果千篇一律，都是针对不了解Spring默认捕获unchecked异常的解决办法，这些早已在我的经验里了，有3种方法 1.手动抛出unchecked异常，让Spring去捕获，然后自动回滚数据 2.手动回滚，在发生异常的地方添加代码 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); 3.在注解的地方添加配置rollbackFor = { Exception.class }，让Spring在捕获到特定的异常自动回滚数据 3种方法我都知道，但是我一般只用第一种，因为简单，这次我选择用第二种方法试下，竟然没问题了，我意识到是我的问题了，开始检查代码，我的代码逻辑如下（见笑） 1234567891011121314boolean result = false;try &#123; // ...业务逻辑 System.out.println(1/0); // ...业务逻辑 result = true;&#125; catch (Exception e) &#123; LOGGER.error(e.getMessage(), e); // rollback throw new RuntimeException(e); result = false;&#125; finally &#123; return result;&#125; 还是不知道错在哪里，没有办法开始Debug，惊奇的发现RuntimeException竟然被忽略了，这才发现我finally中有return，被我自己蠢哭了，基础真是太重要了，我还盲目自信的知道Spring的事务如何使用，到头来连try catch finally都没搞清楚，真是太蠢了。接着我修改了代码： 123456789101112boolean result = false;try &#123; // ...业务逻辑 System.out.println(1/0); // ...业务逻辑 result = true;&#125; catch (Exception e) &#123; LOGGER.error(e.getMessage(), e); // rollback throw new RuntimeException(e);&#125; return result; 这下确实是回滚了，但是返回值是true，想得到的时false，这又难受了，再次Debug，很多次F6后我明白了，RuntimeException是被Spring框架里的层层代理catch了————————————————————————————————————————————————————————————–我把我自己给骗了，RuntimeException抛出程序已经终止了，即使再多的catch最后也不会回到result = true那一行，最终得出原因是其他ajax请求的结果返回到了前台给的提示让我误解了 到这里我意识到自己是真的菜，补习一下try catch finally吧找到一篇好文 总结一下 如果finally中有return，try和catch中的return会失效，并且catch中即使抛出unchecked异常也同样会失效（这是今天踩的坑）；如果finally中有异常相当于整个方法有了异常，那么就没有最终的返回值了,catch中有了异常同样的效果，所以catch和finally中不要出现异常 如果finally中没有return，try和catch中走最先到达return逻辑的地方，并且在return前将返回值暂存，即使finally中修改也不会有效果；（也就是说没有异常最先到达try块中的return，返回值是try块的返回值，catch和finally修改也不会生效；如果try块有异常最先到达catch块中的return，返回值是catch块的返回值，前提是catch块中没有异常，有异常整个方法都没有返回值） 综上所述，使用Spring事务避免不出错优先使用方法2和方法3，方法1比较绕并且对有返回值的逻辑不是很友好；finally块中尽量不要return，这样会忽略try和catch中的异常；最后，基础真的很重要]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Optional 使用及源码]]></title>
    <url>%2F2019%2F08%2F15%2FOptional%2F</url>
    <content type="text"><![CDATA[Optional 使用及源码分析A container object which may or may not contain a non-null value. 可能包含空值的容器对象。 怎么理解呢？就把它当成是和Collection一样的容器，Collection是通过不同的数据结构和API来操作容器中的元素；Optional则是提供API来判断容器中的元素是否为空，在此基础上还能根据是否为空的不同结果给出自定义的处理逻辑。这么说还是很抽象，直接上源码就会好理解一些。 成员变量1234// 空的Optional对象private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();// 容器中元素的值private final T value; 这个value是容器中元素的值，怎么理解呢，使用Optional是要通过它的API进行判空来达到避免NPE的现象，上面说到将Optional当成是一个容器，这个容器中的元素则是需要判空的对象，也就是说容器中的元素就是你传入的参数，这个value就是传参的值 构造方法无参构造，只是将value置为null 123private Optional() &#123; this.value = null;&#125; 有参构造 123private Optional(T value) &#123; this.value = Objects.requireNonNull(value);&#125; 其中返回Objects中的requireNonNull的方法，再看这个方法 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 很简单如果obj为空抛出异常，不为空返回本身，所以有参构造的效果就是确认value不为空并给value赋值，如果是空就抛异常 而且这两个构造函数是私有的，也就是说我们不能new出来 主要方法 empty()–返回空的Optional对象 1234public static &lt;T&gt; Optional&lt;T&gt; empty() &#123; Optional var0 = EMPTY; return var0;&#125; of(T var1)–调用了有参构造，即有值返回带有该值得Optional对象，为空则会抛异常 123public static &lt;T&gt; Optional&lt;T&gt; of(T var0) &#123; return new Optional(var0);&#125; ofNullable(T var0)–元素为null返回空的Option对象，不是null返回本身 123public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T var0) &#123; return var0 == null ? empty() : of(var0);&#125; get()–从名字就可以看出是获取元素的值，也就是返回value，如果是null的话会抛异常 1234567public T get() &#123; if (this.value == null) &#123; throw new NoSuchElementException(&quot;No value present&quot;); &#125; else &#123; return this.value; &#125;&#125; isPresent()–返回value是否为null 123public boolean isPresent() &#123; return this.value != null;&#125; ifPresent(Consumer&lt;? super T&gt; var)–如果元素不是空的话执行var1中的逻辑，Consumer之前有文章写过，是接收一个参数执行一个没有返回值得逻辑 12345public void ifPresent(Consumer&lt;? super T&gt; var1) &#123; if (this.value != null) &#123; var1.accept(this.value); &#125;&#125; filter(Predicate&lt;? super T&gt; var1)–首先确保predicate对象和value不是null，然后用predicate对象对value进行筛选，满足条件返回本身，不满足条件返回空的对象（看源码是这个意思，具体怎什么情况用还想不到~） 12345678public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; var1) &#123; Objects.requireNonNull(var1); if (!this.isPresent()) &#123; return this; &#125; else &#123; return var1.test(this.value) ? this : empty(); &#125;&#125; map(Function&lt;? super T, ? extends U&gt; var1)–同样确保var1不是null，之后value为空值返回空的Optional对象，value有值执行var1中的逻辑 1234public &lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; var1) &#123; Objects.requireNonNull(var1); return !this.isPresent() ? empty() : ofNullable(var1.apply(this.value));&#125; flatMap(Function&lt;? super T, Optional&lt; U &gt;&gt; var1)–与map方法相同,不同的是入参，根据不同的参数结构使用不同的方法 1234public &lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; var1) &#123; Objects.requireNonNull(var1); return !this.isPresent() ? empty() : (Optional)Objects.requireNonNull(var1.apply(this.value));&#125; T orElse(T var1)–获取value的值，不为空返回本身，为空返回入参var1 123public T orElse(T var1) &#123; return this.value != null ? this.value : var1;&#125; T orElseGet(Supplier&lt;? extends T&gt; var1)–与orElse的逻辑一样，不同的是value为空返回的是supplier对象的逻辑 123public T orElseGet(Supplier&lt;? extends T&gt; var1) &#123; return this.value != null ? this.value : var1.get();&#125; T orElseThrow(Supplier&lt;? extends X&gt; var1)–同样的逻辑，不同的是value为null会抛异常 1234567public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; var1) throws X &#123; if (this.value != null) &#123; return this.value; &#125; else &#123; throw (Throwable)var1.get(); &#125;&#125; 总结 of和ofNullable 都是取值，如果元素是null的话of会报空指针–不用，ofNullable将null转为空的对象没有空指针； get方法同样是取值，value是null也会抛异常–不用 最后，取值用ofNullable就完事了 isPresent和ifPresent isPresent返回元素是否为null，有返回值 ifPresent元素不为空执行一段逻辑，无返回值 最后，只判断用isPresent有逻辑用ifPresent filter、map和flatMap 都是将不是null的元素执行传入的逻辑，根据不同的需求选择方法 orElse、orElseGet和orElseThrow 都是将null的元素做转换，orElse返回传入的值，orElseGet返回传入的逻辑，这两个方法看需求没有逻辑有orElse有逻辑用orElseGet；orElseThrow元素为null抛异常–不用 栗子刚刚学习还不知道怎么使用，看到[一篇文章]（https://www.cnblogs.com/rjzheng/p/9163246.html） 给的栗子不错，很有借鉴意义，但是我对这篇文章中的orElse和orElseGet的栗子有不同意见。 栗子1 使用前 1234567891011public String getCity(User user) throws Exception&#123; if(user!=null)&#123; if(user.getAddress()!=null)&#123; Address address = user.getAddress(); if(address.getCity()!=null)&#123; return address.getCity(); &#125; &#125; &#125; throw new Excpetion(&quot;取值错误&quot;); &#125; 使用后 123456public String getCity(User user) throws Exception&#123; return Optional.ofNullable(user) .map(u-&gt; u.getAddress()) .map(a-&gt;a.getCity()) .orElseThrow(()-&gt;new Exception(&quot;取指错误&quot;));&#125; 栗子2 使用前 123if(user!=null)&#123; dosomething(user);&#125; 使用后 1234Optional.ofNullable(user) .ifPresent(u-&gt;&#123; dosomething(u); &#125;); 栗子3 使用前 123456789101112public User getUser(User user) throws Exception&#123; if(user!=null)&#123; String name = user.getName(); if(&quot;zhangsan&quot;.equals(name))&#123; return user; &#125; &#125;else&#123; user = new User(); user.setName(&quot;zhangsan&quot;); return user; &#125;&#125; 使用后 123456789public User getUser(User user) &#123; return Optional.ofNullable(user) .filter(u-&gt;&quot;zhangsan&quot;.equals(u.getName())) .orElseGet(()-&gt; &#123; User user1 = new User(); user1.setName(&quot;zhangsan&quot;); return user1; &#125;);&#125;]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 设置]]></title>
    <url>%2F2019%2F08%2F13%2Fmac-%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[外接键盘的调整键盘设置中将control和command互换就可以达到和Windows下的复制粘贴时一样的，切换程序则由alt+tab变成了ctrl+tab需要适应一下，不过复制，粘贴，撤销，保存这些不用再去适应新的快捷键了 idea中的调整preferences中找到keymap选择Eclipse(macOS)，这样加上第一步的配置复制粘贴这些快捷键与Windows相同，不用再去适应新的快捷键 自动补全变量keymap中搜索variable 默认为：option+command+L 通过以上设置后为：Ctrl+alt+L 另一种使用方法不做任何配置，idea中使用eclipse风格的快捷键，idea中的使用不影响，但是在idea以外就得适应mac中的快捷键，感觉还是这个方法更容易接受一些]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2F2019%2F08%2F05%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[语法包含3个部分：参数 -&gt; 表达式/代码块 (params) -&gt; expression (params) -&gt; statement (params) -&gt; { statements } 与内部类相同，lambda表达式不可以修改外部变量，这点与匿名内部类相同，不同的是lambda表达式不用将变量显示的声名为final，如果是在自己的作用域中定义局部变量可以进行修改，最终保证线程安全 （踩坑）lambda表达式中的this并不是代表当前使用lambda表达式的对象，而是外部类的对象 作用可代替匿名内部类 可以代替只包含一个抽象方法的接口，也叫做函数式接口，例如；Comparator、Runnable Java8内置了四大函数式接口分别为：Consumer，Supplier，Function，Predicate jdk8中提供@FunctionalInterface 注解来检查接口是否符号函数式接口的标准 可代替迭代操作 list.forEach(n -&gt; {}); 通过Stream操作集合 list.stream().filter()…collect(); 对数据处理 与Spark相似java8可以将集合转化为流（Stream），在对流进行map和reduce操作，与Spark相同这些方法也是惰性求值的 Java8的函数式接口消费型接口 Consumer 抽象方法-void accept(T t); 参数类型-T 返回类型-void 这个还没有用过，因为返回值为空并且传递一个参数，我感觉和集合的遍历差不多 list.forEach(n -&gt; sout(n)); 通过定义多个Consumer对象相当于定义多个逻辑块，最终consumer1.addThen(consumer2) 连接，也就是说consumer1逻辑完成后执行consumer2（为什么不写在一个逻辑里呢？我猜可能需要解耦吧） 供给型接口 Supplier 抽象方法-T get(); 参数类型-无参数 返回类型-T 这个感觉很简单，没有参数但要返回一个值，可能new一个对象的时候会用到吧，声名Supplier对象后直接调用get执行定义的逻辑（箭头后面的逻辑）返回一个值 函数型接口 Function&lt;T,R&gt; 抽象方法-R apply(T t) 参数类型-T 返回类型-R 同样是创建Function对象定义一个方法逻辑，接口中有Consumer接口同样的实现方法andThen，用法也相同，不同的是Function定义中有返回值，fun1.addThen(fun2)是将fun1执行的返回值传入fun2中再执行fun2中的逻辑，除此之外该接口还有一个实现方法compose，用法和andThen相反，fun1.compose(fun2) 是先执行fun2中的逻辑将返回值作为参数传入fun1中再执行fun1中的逻辑 断言型接口 Predicate 抽象方法-boolean test(T t) 参数类型-T 返回类型-boolean 定义的Predicate对象相当于筛选条件的对象，最终通过stream中的filter进行过滤，多个条件可以用and和or来进行组合相当于运算符 &amp;&amp; 和 || 多用做集合筛选 eg: 1234// 筛选大于18岁的女性用户Predicate&lt;User&gt; matchAge = u -&gt; u.age &gt; 18;Predicate&lt;User&gt; matchSex = u -&gt; u.sex.equals(&quot;f&quot;);resultList = userList.stream().filter(matchAge.and(matchSex)).collect(Collectors.toList()); 我的理解是在定义Predicate的对象时，-&gt; 前传入参数， -&gt; 后定义test的方法体，最终补充抽象方法test，通过stream的filter筛选相当于将集合中的每个元素都调用一次test方法，将返回值为true的筛选出来。]]></content>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StringUtils]]></title>
    <url>%2F2019%2F07%2F26%2FStringUtils%2F</url>
    <content type="text"><![CDATA[StringUtils 工作中很多操作字符串的操作，使用到了工具类这里总结下，org.apache.commons.lang3包下的 split(String str, String separatorChars)–&gt;切分字符串123public static String[] split(String str, String separatorChars) &#123; return splitWorker(str, separatorChars, -1, false);&#125; 参数： int max -&gt;the maximum number of elements to include in the array. A zero or negative value implies no limit.这个参数代表返回的字符串的最大长度，0或者-1代表不限制长度 boolean preserveAllTokens -&gt; if {@code true}, adjacent separators are treated as empty token separators; if {@code false}, adjacent separators are treated as one separator. 这个参数是连续分隔符规则的标志，如果为true连续的分隔符都会匹配，最终得到的字符串数组会有空的值，jdk中的split就是这个规则；如果为false，连续的分隔符只会匹配一次，最终得到的数组不会有空值。eg(“1,2,3,,4,5”切分后，true得到[1,2,3,,4,5]而false得到[1,2,3,4,5])， 这也是与jdk中的split方法的区别，如果需要使用与jdk相同的规则，工具类中的splitPreserveAllTokens方法可以实现，该方法会调用splitWorker方法且最后的参数为true 所以split方法默认参数为-1和false表示数组长度不收限制，及使用第二个规则进行切割，确保得到的字符串数组没有空值原理： 先将字符串与分隔符做匹配 匹配到之后将分隔符之前的子串分割add到一个list集合中 最后使用list.toArray返回最终的数组 join 待续]]></content>
      <tags>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays]]></title>
    <url>%2F2019%2F07%2F26%2FArrays%2F</url>
    <content type="text"><![CDATA[ArrayscopyOf123456789public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(&quot;unchecked&quot;) T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 先看要被拷贝到的数组长度是不是够用，够用的话直接调用System.arraycopy方法；不够用创建一个新的与源数组同样长度的数组进行拷贝如果数组中是引用类型，Arrays.copy拷贝的是引用，不会新创建对象，如果要对拷贝的数组做修改操作源数组同样会受到影响，而字符串数组由于字符串常量池的存在，当修改字符串的时候会新创建一个字符串并将新的引用付给数组，所以源数组对应的字符串并不会发生变化 System.arraycopy123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 这是一个本地方法，就看一下参数吧 src—-the source array. srcPos—-starting position in the source array. dest—-the destination array. destPos—-starting position in the destination data. length—-the number of array elements to be copied. asList将字符串转成ArrayList集合 123public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 这里的ArrayList是Arrays中的一个内部类，继承了AbstractList方法，内部值实现了部分方法，简单点说这个集合是只读的，不能进行修改和删除操作，因为没有重写相关的方法。 copyOfRange按照范围拷贝数组 [from,to) 左开右闭123public static &lt;T&gt; T[] copyOfRange(T[] original, int from, int to) &#123; return copyOfRange(original, from, to, (Class&lt;? extends T[]&gt;) original.getClass());&#125; sort集合工具类 Collections.sort 其实就是调用 Arrays.sort 方法对集合进行排序的，该方法先调用 toArray 方法将集合转成object数组，然后再调用 Arrays.sort 方法对数组进行排序，最后再将排序号的数组通过迭代器set到新的集合中去。 123456public static void sort(Object[] a) &#123; if (LegacyMergeSort.userRequested) legacyMergeSort(a); else ComparableTimSort.sort(a, 0, a.length, null, 0, 0);&#125; 可以看到sort方法是通过userRequested的标志来选中排序的方式，从jdk7以后默认为false，使用TimSort的方式排序，（通过System.setProperty(“java.util.Arrays.useLegacyMergeSort”, “true”)修改） userRequested为true使用LegacyMergeSort的方式进行排序，当数组长度小于7时使用插入排序，当数组长度大于7时使用归并排序，归并到长度小于7的长度再次使用插入排序 userRequested为false采用TimSort的方式排序 TimSort 1.数组长度小于32时，首先在数组中从开头开始寻找升序的子数组，没有的话找降序的子数组再反转，然后将数组中的剩余元素使用二分查找的方式插入到子数组中 2.数组长度大于32时，将数组切分若干个长度在[16,32)的区块（jdk里叫run，我理解为区块） 3.每个区块再使用第一步的方式进行排序排序后将每个区块进行合并，合并的过程有两点优化 a.合并区块的过程中通过限制条件来完成将连续的三个区块中较小的两个优先合并降低复杂度 b.两个区块合并时，先将区块1的头元素和尾元素插入到区块2中，相当于缩小了插入区块2的范围降低复杂度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) &#123; assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length; int nRemaining = hi - lo; if (nRemaining &lt; 2) return; // Arrays of size 0 and 1 are always sorted // If array is small, do a &quot;mini-TimSort&quot; with no merges if (nRemaining &lt; MIN_MERGE) &#123; int initRunLen = countRunAndMakeAscending(a, lo, hi); binarySort(a, lo, hi, lo + initRunLen); return; &#125; /** * March over the array once, left to right, finding natural runs, * extending short natural runs to minRun elements, and merging runs * to maintain stack invariant. */ ComparableTimSort ts = new ComparableTimSort(a, work, workBase, workLen); int minRun = minRunLength(nRemaining); do &#123; // Identify next run int runLen = countRunAndMakeAscending(a, lo, hi); // If run is short, extend to min(minRun, nRemaining) if (runLen &lt; minRun) &#123; int force = nRemaining &lt;= minRun ? nRemaining : minRun; binarySort(a, lo, lo + force, lo + runLen); runLen = force; &#125; // Push run onto pending-run stack, and maybe merge ts.pushRun(lo, runLen); ts.mergeCollapse(); // Advance to find next run lo += runLen; nRemaining -= runLen; &#125; while (nRemaining != 0); // Merge all remaining runs to complete sort assert lo == hi; ts.mergeForceCollapse(); assert ts.stackSize == 1;&#125;]]></content>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList]]></title>
    <url>%2F2019%2F07%2F26%2FArrayList%2F</url>
    <content type="text"><![CDATA[ArrayListtoArray(T[] a)123456789public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a&apos;s runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a;&#125; 使用了Arrays.copyOf方法]]></content>
      <tags>
        <tag>collections</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis入门（续）-CRUD]]></title>
    <url>%2F2019%2F07%2F12%2FMyBatis%E5%85%A5%E9%97%A8%E7%BB%AD-CRUD%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[根据用户名查询 123&lt;select id=&quot;findUserByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.example.mybatisdemo.bean.User&quot;&gt; SELECT * FROM users WHERE name = #&#123;VALUE&#125; &lt;/select&gt; 1sqlSession.selectOne(&quot;test.findUserByName&quot;, &quot;yywang&quot;) 模糊查询，返回多个值 123&lt;select id=&quot;findUserLikeName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;com.example.mybatisdemo.bean.User&quot;&gt; SELECT * FROM users WHERE name like #&#123;VALUE&#125; &lt;/select&gt; 1sqlSession.selectList(&quot;test.findUserLikeName&quot;, &quot;%yy%&quot;); 添加数据 123456&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.example.mybatisdemo.bean.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT into users(uname,sex,age,udesc) values (#&#123;uname&#125;,#&#123;sex&#125;,#&#123;age&#125;,#&#123;udesc&#125;) &lt;/insert&gt; 12User user = new User(&quot;bangni&quot;,&quot;female&quot;,22,&quot;tc&quot;);sqlSession.commit(); // 必加 tips selectKey 用来配置返回主键 keyProperty 表中主键的名称 order 表示SELECT LAST_INSERT_ID()在insert语句发生的顺序，after意为insert执行之后返回，用于自增主键，UUID的方式可以配置为before resultType 返回值类型 注1：sql语句中有多个参数，占位符#{}也需要指定不同的表示方式，如上#{uname},#{sex}等 注2：sql没问题运行报错，因为之前的数据表设计问题，name和desc是关键字，这里开始做了修改 注3：修改之后运行通过，数据库查不到记录，想到之前测试Junit回自动回滚，于是添加@Rollback注解导入依赖后还是无果，最终加上session.commit()解决，由于MyBatis接管了JDBC的事务管理器，JDBC回自动提交而MyBatis不会，这里需要自行手动提交，修改删除同样 删除 123&lt;delete id=&quot;delUserById&quot; parameterType=&quot;int&quot;&gt; delete from users where id = #&#123;id&#125; &lt;/delete&gt; 12sqlSession.delete(&quot;test.delUserById&quot;,3); sqlSession.commit(); 更新 123&lt;update id=&quot;updateUserById&quot; parameterType=&quot;int&quot;&gt; update users set age = 0 where id = #&#123;id&#125; &lt;/update&gt; 12sqlSession.update(&quot;test.updateUserById&quot;,8); sqlSession.commit(); 查看最后执行的SQL只需在配置文件中添加配置即可打印查询语句12345&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt; &lt;/settings&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA配置Junit测试]]></title>
    <url>%2F2019%2F07%2F12%2FIDEA%E9%85%8D%E7%BD%AEJunit%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[看了很多博客后感觉还是比较乱，这篇还不错马一下https://blog.csdn.net/hanchao5272/article/details/79197989 1.安装插件File-&gt;setting-&gt;Plugins-&gt;搜索并安装Junit Generator 2.0-&gt;重启IDEA 2.配置插件File-&gt;setting-&gt; OtherSettings-&gt;Junit Generator-&gt;properties 修改Output Path[输出路径]为${SOURCEPATH}/../../test/java/${PACKAGE}/${FILENAME} 修改 Default Template[默认模板]为JUnit4 选中JUnit4页签，将package test.$entry.packageName; 修改成package $entry.packageName; 3.配置测试的目录File-&gt;Project Structure-&gt;Modules中将测试目录设置为Test Source Floder 4.生成测试类 在要测试的类中用快捷键 alt+insert -&gt; Junit Test -&gt; Junit4 5.测试 鼠标右键菜单 将鼠标光标放在方法相关代码中，右键弹出菜单中会显示运行此测试方法的菜单，点击就会运行方法单独测试。将鼠标光标放在方法之外的代码中，右键弹出菜单中会显示运行此类的所有测试方法的菜单，点击就会运行所有测试方法。 快捷键 将鼠标光标放在方法相关代码中，通过快捷键Ctrl+Shift+F10，运行当前测试方法。 将鼠标光标放在方法之外的代码中，通过快捷键Ctrl+Shift+F10，运行当前类的所有测试方法。 快捷按钮 点击方法左侧的Run Test按钮，运行当前测试方法。 点击类左侧的Run Test按钮，运行当前类的所有测试方法。 6.测试结果 1.方法测试成功 2.方法测试失败 3.测试用时（毫秒） 4.期望值 5.实际值 6.异常信息 7.异常 原因：4.11以上版本不在包含hamcrest 解决：改用4.10 ^_^]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis入门]]></title>
    <url>%2F2019%2F07%2F12%2FMyBatis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[MyBatis环境首先准备数据库表 对应的实体类为 class User &#123;123456 private int id; private String name; private String sex; private int age; private String desc;&#125; 数据库配置文件 SqlMapConfig.xml 配置数据库环境相关 1234567891011&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; sql映射文件 user.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.example.mybatisdemo.bean.User&quot;&gt; SELECT * FROM user WHERE id =#&#123;VALUE&#125; &lt;/select&gt;&lt;/mapper&gt; 将sql映射添加到SqlMapConfig.xml中 最终的配置文件为 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mapper/user.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 测试 123456789String resource = &quot;SqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = factory.openSession(); // 参数1 sql映射中的 namespace + &quot;.&quot; + sqlId // 参数2为sql的参数 User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1); System.out.println(user.toString()); sqlSession.close(); 理解基于sql语句的轻量级ORM框架，将sql语句写入配置文件映射中，进一步解耦，但是多了一步操作感觉比hibernate繁琐一些，但是比hibernate要快，有舍有得吧（为什么快还不知道，后续再看吧╮(╯▽╰)╭ ）]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC入门]]></title>
    <url>%2F2019%2F07%2F11%2FSpringMVC%2F</url>
    <content type="text"><![CDATA[SpringMVC配置注解&amp;配置文件 注解web.xml ①指定Spring配置文件的位置 ②配置Listener，初始化SpringIOC容器 ③配置前端控制器servlet，其中可以自定义配置文件位置，不配置默认寻找xxxx-servlet.xml的配置文件 url-pattern中/和/*区别 /* 匹配所有url 有后缀或者无后缀都会匹配 .jsp .css .js / 只匹配无后缀的url 注：截图为项目中的配置 自己测试时改为 / 项目中拦截所有页面应该会有拦截器或者过滤器做处理，demo中如果配置成截图这样会报错 springmvc-servlet.xml 指定基础包名scan，将指定的包名注入SpringIOC容器（先要添加context的xsd约束） 1xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi中添加“http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; exclude-filter 指定类与Spring容器分开加载（先这么理解） 配置视图解析器（前缀和后缀） 方法中使用@RequestMapping(value=”search”) 理解为匹配URL中search的字样 方法return “iface/manage”; 从匹配的前后缀中寻找应该返回的视图，例如通过上图的配置找到/iface/manage.vm 在Controller类上添加@Controller，方法上添加@RequestMapping(“xxxx”)，即可完成映射 配置完成访问报错 没有jstl标签库，导入依赖即可 1234&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; 配置文件web.xml 和注解方式一样springmvc-servlet.xml ①配置处理器映射器 ②配置处理器适配器 ③配置视图解析器（同注解方式） ④配置映射（相当于注解中的@RequestMapping） 相较于注解方式该配置文件中多了对 处理器映射器、处理器适配器 以及映射的配置 实现方面在controller类中不添加任何注解，实现Controller接口，重写方法即可 demo：https://github.com/panniyuyu/frameworkdemo.git 理解通过使用不同方式对springMVC进行配置，感觉对SpringMVC框架大致的原理有一些认识 SpringMVC使将MVC的模式进一步拆分解耦，整个过程主要包含4个主要的部分依次是 前端控制器（DispatcherServlet）、处理器映射器（HandlerMapping）、处理器适配器（HandlerAdapter）、视图解析器（ViewResolver） 1.用户发起请求，被前端控制器（DispatcherServlet）拦截，并根据请求内容询问处理器映射器（HandlerMapping）改请求应该由哪个Controller处理，处理器映射器将匹配到的Controller信息返回给前端控制器 2.前端控制器知道该请求应该由哪个Controller处理，但不会自己处理，将Controller信息交给处理器适配器（HandlerAdapter）处理，返回ModelAndView对象 3.前端控制器得到ModelAndView对象将其转发给视图解析器，将对象解析成view页面返回 4.前端控制器将view页面相应给浏览器]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[org.apache.tomcat.util.bcel.classfile.ClassFormatException]]></title>
    <url>%2F2019%2F07%2F11%2F%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[org.apache.tomcat.util.bcel.classfile.ClassFormatException 原因：jdk版本不兼容 原环境 jkd8+tomcat7+spring4 解决：tomcat7换tomcat8]]></content>
      <tags>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA使用笔记]]></title>
    <url>%2F2019%2F07%2F11%2FIDEA%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[配置TomcatRun-&gt;Edit Configurations-&gt;Telplates中配置后在该页面左上角添加-&gt;选中Tomcat的Deployment点击部署(选用Artifacts方式) 配置文件取消Unicode编码File-&gt;Setting-&gt;搜索file encoding-&gt;勾选Transparent native-to-ascii conversion 文件目录变红色 解除版本控制即可 file-&gt;setting-&gt;version control-&gt;右上角加号-&gt;添加项目目录即可 新建的maven项目没有web项目的目录结构，也没有web.xml 增加main目录下增加/webapp/WEB-INF目录 File-&gt;Project Structure-&gt;facets-&gt;加号-&gt;选中目录 确认路径depolyment路径为…./webapp/WEB-INF/web.xml 确认路径resource路径为 …./webapp/ 直接创建maven web项目最为简单 createProject-&gt;maven-&gt;勾选Creater from archetype-&gt;选择 maven-archetype-webapp 右键没有new package修改目录性质，在该目录右键-&gt;Mark Directory as-&gt;Source Root 发布方式（参考https://www.cnblogs.com/dpl9963/p/10075456.html） jar：Java ARchrive，仅仅是编译好的Java类的聚合 war：Web application ARchrive，除Java类之外还包含jsp，config等静态资源的聚合 exploded：理解为展开不压缩，jar和war是压缩的目录节后，exploded表示不压缩的文件目录，开发是用该方式较好，文件更改后不用重新启动服务器看到效果 Debug模式 快捷键改为eclipse后，F5，F6不变，eclipse的F8变为F9（程序放行） 修改文件后没有效果必须重启tomcat runConfigurations中配置 部署项目到tomcat上，这里的url一定要改成 / 启动tomcat日志输出乱码 淇℃伅（https://www.cnblogs.com/Yin-BoKeYuan/p/10320622.html）打开到tomcat安装目录下的conf/文件夹 修改logging.properties文件，找到 java.util.logging.ConsoleHandler.encoding = utf-8更改为 java.util.logging.ConsoleHandler.encoding = GBK]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点复习]]></title>
    <url>%2F2019%2F07%2F09%2F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[整理一些在看项目时候遇到的小的知识点，先写个大概，后续再做详细的补充 HTTP和TCPHttp是在Tcp的基础之上的，也就是说Http的请求和相应是在建立Tcp链接之后发生的 幂等性一次或者多次请求同一个资源得到的结果是一样的，多次请求不会影响最终的结果。（增加去重的逻辑则无需满足幂等性） synchronized 关键字 在方法中锁住的是该类的实例对象 在静态方法中锁住的是类对象 代码块中（this）锁住的是该类的实例对象 代码块中（xxx.class）锁住的是类对象 volatile保证线程数据可见 transient 关键字不做序列化和反序列化操作 synchronized在方法中声名为什么还用线程安全的数据结构来存放变量该变量可能在其他地方被调用，如果该变量只在synchronized关键字声名在方法中使用，则无需使用线程安全的数据结构。 TPS （Transaction Per Second）服务器每秒处理的事务个数，一个事务是从向服务器发送请求开始，客户端接收到响应结束 QPS （Query Per Second）服务器每秒处理查询的次数，查询开始到返回结果结束 Git克隆分支命令git clone -b [分支名称] [git地址] Git提交代码到GitHub 创建仓库，在本地clone 本地在.git所在的目录打开git bansh 指定远程仓库 git remote add origin https://github.com/panniyuyu/frameworkdemo.git 会提示 remote origin already exists 执行删除命令后再重新指定远程仓库 git remote rm origin 添加文件git add * 提交改动git commit -m “xxxx” 推到远程仓库git push origin master wait()方法 会暂停当前线程，让出CPU时间，同时让出锁，等待notify()或者notifyAll()唤醒后重新获得锁执行 sleep()方法同样会暂停当前线程，让出CPU时间，与 wait()方法不同的是，sleep()方法不会释放锁，会阻塞当前的线程，且sleep()是Thread类中的方法, wait()是Object的方法 守护线程 Java中优先级低的线程，用来服务于用户线程的，当Java程序退出或者jvm退出时，守护线程自动退出，jvm运行时只需关注用户线程即可。 Jvm中的垃圾收集器可以理解为守护线程，当jvm退出时会自动退出 使用 thread.setDaemon(true)设置，要在start()方法之前 Class的isAssignableFrom方法 Class中的方法，如：a.isAssignableFrom(b) 在a是b的父类或接口，亦或是a、b是同一个类或者接口的情况下返回true，其他情况返回false Class的getFields和getDeclaredFields 都是获取类中的字段，getFields获取类中public的字段，getDeclaredFields获取类中所有声名的字段，不包含父类中的字段 Field的getModifiers 获取字段的修饰符，返回值为int型对应不同的类型 PUBLIC: 1 PRIVATE: 2 PROTECTED: 4 STATIC: 8 FINAL: 16 SYNCHRONIZED: 32 VOLATILE: 64 TRANSIENT: 128 NATIVE: 256 INTERFACE: 512 ABSTRACT: 1024 STRICT: 2048 Field的setAccessible(true) 字段被声名是私有的，在取值前必须设置accessible为true，不然会报错 field的getGenericType和getType 都是获取字段的类型，getGenericType返回的是Type类型，getType返回的是Class类型 还有其他不同，暂时没有理解http://www.51gjie.com/java/793.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2019%2F05%2F11%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[时光匆匆，三年的研究生生涯马上就要结束。这是我毕业论文致谢里的第一句话，虽然很老套但是非常应景，在毕业之前的这段时间没有那么多的事情，突然想到做一个自己的博客，把自己的学习和生活记录下来，不用每次遇到问题的时候再去问度娘，而且很多都是重复的问题，虽然自己也在做笔记但很少回头看，打算以前的笔记不再管了，当初为了图省事写的非常简单有些已经想不起来是做什么的了，现在想想非常懊悔，这个坏毛病一定要改。今日在我的博客搭建完成之际，开始将今后所学习的技术记录在此，沉淀下去，和大家做交流，同时，在此也将记录我的生活，有趣的所见所闻什么的，朋友圈发的频繁遭人厌。马上就要入职了，心里知道要回归到工程中了，不然入职后的压力会很大，但是也不知道自己工作内容是什么，浏览了一些博客发现需要学习的东西实在是太多了无从下手，而且就我自己而言没有在工程中应用过的技术即使理解了最后也会忘掉，所以学习的情绪很down，想找一些有趣的东西搞一下，于是本站诞生了。emmm……第一篇博客就到这了，自己小学语文水平只能写到这了，给自己加油！]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>生活杂谈</tag>
      </tags>
  </entry>
</search>
